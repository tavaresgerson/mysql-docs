### 9.5.2 Recuperação em Ponto no Tempo Usando Posições de Registro Binário

A última seção, Seção 9.5.1, “Recuperação em Ponto no Tempo Usando Registro Binário”, explica a ideia geral de usar o registro binário para realizar uma recuperação em ponto no tempo. A seção explica a operação em detalhes com um exemplo.

Como exemplo, suponha que por volta das 20:06:00 em 11 de março de 2020, uma instrução SQL foi executada que excluiu uma tabela. Você pode realizar uma recuperação em ponto no tempo para restaurar o servidor até seu estado imediatamente antes da exclusão da tabela. Aqui estão alguns passos de amostra para isso:

1. Restaure o último backup completo criado antes do ponto no tempo de interesse (chame-o de `tp`, que é 20:06:00 em 11 de março de 2020 em nosso exemplo). Quando terminar, anote a posição do registro binário até a qual você restaurou o servidor para uso posterior e reinicie o servidor.

   ::: info Nota

   Embora a última posição do registro binário recuperada também seja exibida pelo InnoDB após a restauração e o reinício do servidor, isso *não* é um meio confiável para obter a posição final do log da sua restauração, pois podem ter havido eventos DDL e alterações não do InnoDB que ocorreram após o tempo refletido pela posição exibida. Sua ferramenta de backup e restauração deve fornecer a você a última posição do registro binário para sua recuperação: por exemplo, se você estiver usando `mysqlbinlog` para a tarefa, verifique a posição de parada do replay do registro binário; se você estiver usando MySQL Enterprise Backup, a última posição do registro binário foi salva em seu backup. Veja Recuperação em Ponto no Tempo.

   :::

2. Encontre a posição precisa do evento de log binário correspondente ao momento até o qual deseja restaurar seu banco de dados. No nosso exemplo, dado que sabemos o horário aproximado em que a exclusão da tabela ocorreu (`tp`), podemos encontrar a posição do log verificando o conteúdo do log por volta desse tempo usando o utilitário `mysqlbinlog`. Use as opções `--start-datetime` e `--stop-datetime` para especificar um período de tempo curto por volta de `tp`, e então procure pelo evento na saída. Por exemplo:

   ```
   $> mysqlbinlog --start-datetime="2020-03-11 20:05:00" \
                      --stop-datetime="2020-03-11 20:08:00" --verbose \
            /var/lib/mysql/bin.123456 | grep -C 15 "DROP TABLE"

   /*!80014 SET @@session.original_server_version=80019*//*!*/;
   /*!80014 SET @@session.immediate_server_version=80019*//*!*/;
   SET @@SESSION.GTID_NEXT= 'ANONYMOUS'/*!*/;
   # at 232
   #200311 20:06:20 server id 1  end_log_pos 355 CRC32 0x2fc1e5ea 	Query	thread_id=16	exec_time=0	error_code=0
   SET TIMESTAMP=1583971580/*!*/;
   SET @@session.pseudo_thread_id=16/*!*/;
   SET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0, @@session.unique_checks=1, @@session.autocommit=1/*!*/;
   SET @@session.sql_mode=1168113696/*!*/;
   SET @@session.auto_increment_increment=1, @@session.auto_increment_offset=1/*!*/;
   /*!\C utf8mb4 *//*!*/;
   SET @@session.character_set_client=255,@@session.collation_connection=255,@@session.collation_server=255/*!*/;
   SET @@session.lc_time_names=0/*!*/;
   SET @@session.collation_database=DEFAULT/*!*/;
   /*!80011 SET @@session.default_collation_for_utf8mb4=255*//*!*/;
   DROP TABLE `pets`.`cats` /* generated by server */
   /*!*/;
   # at 355
   #200311 20:07:48 server id 1  end_log_pos 434 CRC32 0x123d65df 	Anonymous_GTID	last_committed=1	sequence_number=2	rbr_only=no	original_committed_timestamp=1583971668462467	immediate_commit_timestamp=1583971668462467	transaction_length=473
   # original_commit_timestamp=1583971668462467 (2020-03-11 20:07:48.462467 EDT)
   # immediate_commit_timestamp=1583971668462467 (2020-03-11 20:07:48.462467 EDT)
   /*!80001 SET @@session.original_commit_timestamp=1583971668462467*//*!*/;
   /*!80014 SET @@session.original_server_version=80019*//*!*/;
   /*!80014 SET @@session.immediate_server_version=80019*//*!*/;
   SET @@SESSION.GTID_NEXT= 'ANONYMOUS'/*!*/;
   # at 434
   #200311 20:07:48 server id 1  end_log_pos 828 CRC32 0x57fac9ac 	Query	thread_id=16	exec_time=0	error_code=0	Xid = 217
   use `pets`/*!*/;
   SET TIMESTAMP=1583971668/*!*/;
   /*!80013 SET @@session.sql_require_primary_key=0*//*!*/;
   CREATE TABLE dogs
   ```

   A partir da saída de `mysqlbinlog`, a declaração `DROP TABLE `pets`.`cats`` pode ser encontrada no segmento do log binário entre a linha `# at 232` e `# at 355`, o que significa que a declaração ocorre *após* a posição do log 232, e o log está na posição 355 após a declaração `DROP TABLE`.

   ::: info Nota

   Use apenas as opções `--start-datetime` e `--stop-datetime` para ajudá-lo a encontrar as posições reais dos eventos de interesse. Não é recomendado usar as duas opções para especificar o intervalo de segmento de log binário a ser aplicado: há um risco maior de perder eventos de log binário ao usar as opções. Use `--start-position` e `--stop-position` em vez disso.


   :::
3. Aplique os eventos no arquivo de log binário ao servidor, começando com a posição do log que você encontrou no passo 1 (suponha que seja 155) e terminando na posição que você encontrou no passo 2 que está *antes* do seu ponto no tempo de interesse (que é 232):

   ```
   $> mysqlbinlog --start-position=155 --stop-position=232 /var/lib/mysql/bin.123456 \
            | mysql -u root -p
   ```

   O comando recupera todas as transações da posição inicial até pouco antes da posição de parada. Como a saída de `mysqlbinlog` inclui declarações `SET TIMESTAMP` antes de cada declaração SQL registrada, os dados recuperados e os logs MySQL relacionados refletem os tempos originais em que as transações foram executadas.

Seu banco de dados foi restaurado ao ponto no tempo de interesse, `tp`, logo antes da tabela `pets.cats` ter sido excluída.
4. Além da recuperação do ponto no tempo que foi concluída, se você também quiser reexecutar todas as instruções *após* seu ponto no tempo de interesse, use novamente `mysqlbinlog` para aplicar todos os eventos após `tp` ao servidor. Observamos no passo 2 que, após a instrução que queríamos pular, o log está na posição 355; podemos usá-lo para a opção `--start-position`, para que quaisquer instruções após a posição sejam incluídas:

   ```
   $> mysqlbinlog --start-position=355 /var/lib/mysql/bin.123456 \
            | mysql -u root -p
   ```

Seu banco de dados foi restaurado ao último registro da instrução no arquivo de log binário, mas com o evento selecionado pulado.