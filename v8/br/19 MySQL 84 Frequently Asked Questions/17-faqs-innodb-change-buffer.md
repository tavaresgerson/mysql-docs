## A.16 Perguntas frequentes sobre o MySQL 8.4: Buffer de alterações InnoDB

<table><colgroup><col align="left" width="1%"/><col/></colgroup><tbody><tr class="question"><td align="left" valign="top"><p><b>A.16.1.</b></p></td><td align="left" valign="top"><p> Quais tipos de operações modificam índices secundários e resultam na bufferização de alterações? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> As operações <code>INSERT</code>, <code>UPDATE</code> e <code>DELETE</code> podem modificar índices secundários. Se uma página de índice afetada não estiver no pool de buffer, as alterações podem ser bufferizadas no buffer de alterações. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.16.2.</b></p></td><td align="left" valign="top"><p> Qual é o benefício do buffer de alterações do <code>InnoDB</code>? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> A bufferização de alterações de índices secundários quando as páginas de índice secundárias não estiverem no pool de buffer evita operações de I/O de acesso aleatório caras que seriam necessárias para ler imediatamente as páginas de índice afetadas do disco. As alterações bufferizadas podem ser aplicadas posteriormente, em lotes, à medida que as páginas são lidas para o pool de buffer por outras operações de leitura. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.16.3.</b></p></td><td align="left" valign="top"><p> O buffer de alterações suporta outros tipos de índices? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> Não. O buffer de alterações só suporta índices secundários. Índices agrupados, índices full-text e índices espaciais não são suportados. Os índices full-text têm seu próprio mecanismo de cache. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.16.4.</b></p></td><td align="left" valign="top"><p> Quanto espaço o <code>InnoDB</code> usa para o buffer de alterações? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> Antes da introdução da opção de configuração <code>innodb_change_buffer_max_size</code> no MySQL 5.6, o tamanho máximo do buffer de alterações no espaço de tabelas do sistema era de 1/3 do tamanho do pool de buffer <code>InnoDB</code>. </p><p> No MySQL 5.6 e versões posteriores, a opção de configuração <code>innodb_change_buffer_max_size</code> define o tamanho máximo do buffer de alterações como um porcentagem do tamanho total do pool de buffer. Por padrão, <code>innodb_change_buffer_max_size</code> está definido para 25. O limite máximo é 50. </p><p> O <code>InnoDB</code> não bufferiza uma operação se isso exceder o limite definido. </p><p> As páginas do buffer de alterações não são obrigadas a persistir no pool de buffer e podem ser etiquetadas por operações LRU. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.16.5.</b></p></td><td align="left" valign="top"><p> Como determinar o tamanho atual do buffer de alterações? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> O tamanho atual do buffer de alterações é relatado por <code>SHOW ENGINE INNODB STATUS \G</code>, sob o cabeçalho <code>INSERT BUFFER AND ADAPTIVE HASH INDEX</code>. Por exemplo: </p><pre class="programlisting copytoclipboard language-none"><code class="language-none">------------------------------------- INSERT BUFFER AND ADAPTIVE HASH INDEX ------------------------------------- Ibuf: size 1, free list len 0, seg size 2, 0 merges</code></pre><p> Dados relevantes incluem: </p> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: disc; "><li><p> <code>size</code>: O número de páginas usadas dentro do buffer de alterações. O tamanho do buffer de alterações é