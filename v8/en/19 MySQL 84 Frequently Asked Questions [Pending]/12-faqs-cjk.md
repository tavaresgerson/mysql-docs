## A.11 MySQL 8.4 FAQ: MySQL Chinese, Japanese, and Korean Character Sets

This set of Frequently Asked Questions derives from the experience of MySQL's Support and Development groups in handling many inquiries about CJK (Chinese-Japanese-Korean) issues.

A.11.1.  What CJK character sets are available in MySQL?

A.11.2.  I have inserted CJK characters into my table. Why does SELECT display them as “?” characters?

A.11.3.  What problems should I be aware of when working with the Big5 Chinese character set?

A.11.4.  Why do Japanese character set conversions fail?

A.11.5.  What should I do if I want to convert SJIS 81CA to cp932?

A.11.6.  How does MySQL represent the Yen (¥) sign?

A.11.7.  Of what issues should I be aware when working with Korean character sets in MySQL?

A.11.8.  Why do I get Incorrect string value error messages?

A.11.9.  Why does my GUI front end or browser display CJK characters incorrectly in my application using Access, PHP, or another API?

A.11.10.  I've upgraded to MySQL 8.4. How can I revert to behavior like that in MySQL 4.0 with regard to character sets?

A.11.11.  Why do some LIKE and FULLTEXT searches with CJK characters fail?

A.11.12.  How do I know whether character X is available in all character sets?

A.11.13.  Why do CJK strings sort incorrectly in Unicode? (I)

A.11.14.  Why do CJK strings sort incorrectly in Unicode? (II)

A.11.15.  Why are my supplementary characters rejected by MySQL?

A.11.16.  Should “CJK” be “CJKV”?

A.11.17.  Does MySQL permit CJK characters to be used in database and table names?

A.11.18.  Where can I find translations of the MySQL Manual into Chinese, Japanese, and Korean?

A.11.19.  Where can I get help with CJK and related issues in MySQL?

<table><colgroup><col align="left" width="1%"/><col/></colgroup><tbody><tr class="question"><td align="left" valign="top"><p><b>A.11.1.</b></p></td><td align="left" valign="top"><p> What CJK character sets are available in MySQL? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> The list of CJK character sets may vary depending on your MySQL version. For example, the <code>gb18030</code> character set is not supported prior to MySQL 5.7.4. However, since the name of the applicable language appears in the <code>DESCRIPTION</code> column for every entry in the <code>INFORMATION_SCHEMA.CHARACTER_SETS</code> table, you can obtain a current list of all the non-Unicode CJK character sets using this query: </p><pre class="programlisting copytoclipboard language-sql"><code class="language-sql">mysql&gt; SELECT CHARACTER_SET_NAME, DESCRIPTION FROM INFORMATION_SCHEMA.CHARACTER_SETS WHERE DESCRIPTION LIKE '%Chin%' OR DESCRIPTION LIKE '%Japanese%' OR DESCRIPTION LIKE '%Korean%' ORDER BY CHARACTER_SET_NAME; +--------------------+---------------------------------+ | CHARACTER_SET_NAME | DESCRIPTION                     | +--------------------+---------------------------------+ | big5               | Big5 Traditional Chinese        | | cp932              | SJIS for Windows Japanese       | | eucjpms            | UJIS for Windows Japanese       | | euckr              | EUC-KR Korean                   | | gb18030            | China National Standard GB18030 | | gb2312             | GB2312 Simplified Chinese       | | gbk                | GBK Simplified Chinese          | | sjis               | Shift-JIS Japanese              | | ujis               | EUC-JP Japanese                 | +--------------------+---------------------------------+</code></pre><p> (For more information, see Section 28.3.4, “The INFORMATION_SCHEMA CHARACTER_SETS Table”.) </p><p> MySQL supports three variants of the <span class="firstterm">GB</span> (<span class="foreignphrase"><em class="foreignphrase">Guojia Biaozhun</em></span>, or <span><em>National Standard</em></span>, or <span><em>Simplified Chinese</em></span>) character sets which are official in the People's Republic of China: <code>gb2312</code>, <code>gbk</code>, and (as of MySQL 5.7.4) <code>gb18030</code>. </p><p> Sometimes people try to insert <code>gbk</code> characters into <code>gb2312</code>, and it works most of the time because <code>gbk</code> is a superset of <code>gb2312</code>. But eventually they try to insert a rarer Chinese character and it does not work. (For an example, see Bug #16072). </p><p> Here, we try to clarify exactly what characters are legitimate in <code>gb2312</code> or <code>gbk</code>, with reference to the official documents. Please check these references before reporting <code>gb2312</code> or <code>gbk</code> bugs: </p> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: disc; "><li><p> The MySQL <code>gbk</code> character set is in reality <span class="quote">“<span class="quote">Microsoft code page 936</span>”</span>. This differs from the official <code>gbk</code> for characters <code>A1A4</code> (middle dot), <code>A1AA</code> (em dash), <code>A6E0-A6F5</code>, and <code>A8BB-A8C0</code>. </p></li><li><p> For a listing of <code>gbk</code>/Unicode mappings, see http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP936.TXT. </p></li></ul> </div> <p> It is also possible to store CJK characters in Unicode character sets, although the available collations may not sort characters quite as you expect: </p> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: disc; "><li><p> The <code>utf8</code> and <code>ucs2</code> character sets support the characters from Unicode Basic Multilingual Plane (BMP). These characters have code point values between <code>U+0000</code> and <code>U+FFFF</code>. </p></li><li><p> The <code>utf8mb4</code>, <code>utf16</code>, <code>utf16le</code>, and <code>utf32</code> character sets support BMP characters, as well as supplementary characters that lie outside the BMP. Supplementary characters have code point values between <code>U+10000</code> and <code>U+10FFFF</code>. </p></li></ul> </div> <p> The collation used for a Unicode character set determines the ability to sort (that is, distinguish) characters in the set: </p> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: disc; "><li><p> Collations based on Unicode Collation Algorithm (UCA) 4.0.0 distinguish only BMP characters. </p></li><li><p> Collations based on UCA 5.2.0 or 9.0.0 distinguish BMP and supplementary characters. </p></li><li><p> Non-UCA collations may not distinguish all Unicode characters. For example, the <code>utf8mb4</code> default collation is <code>utf8mb4_general_ci</code>, which distinguishes only BMP characters. </p></li></ul> </div> <p> Moreover, distinguishing characters is not the same as ordering them per the conventions of a given CJK language. Currently, MySQL has only one CJK-specific UCA collation, <code>gb18030_unicode_520_ci</code> (which requires use of the non-Unicode <code>gb18030</code> character set). </p><p> For information about Unicode collations and their differentiating properties, including collation properties for supplementary characters, see Section 12.10.1, “Unicode Character Sets”. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.11.2.</b></p></td><td align="left" valign="top"><p> I have inserted CJK characters into my table. Why does <code>SELECT</code> display them as <span class="quote">“<span class="quote">?</span>”</span> characters? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> This problem is usually due to a setting in MySQL that does not match the settings for the application program or the operating system. Here are some common steps for correcting these types of issues: </p> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: disc; "><li><p> <span><em>Be certain of what MySQL version you are using</em></span>. </p><p> Use the statement <code>SELECT VERSION();</code> to determine this. </p></li><li><p> <span><em>Make sure that the database is actually using the desired character set</em></span>. </p><p> People often think that the client character set is always the same as either the server character set or the character set used for display purposes. However, both of these are false assumptions. You can make sure by checking the result of <code>SHOW CREATE TABLE <em><code>tablename</code></em></code> or, better yet, by using this statement: </p><pre class="programlisting copytoclipboard language-sql"><code class="language-sql">SELECT character_set_name, collation_name FROM information_schema.columns WHERE table_schema = your_database_name AND table_name = your_table_name AND column_name = your_column_name;</code></pre></li><li><p> <span><em>Determine the hexadecimal value of the character or characters that are not being displayed correctly</em></span>. </p><p> You can obtain this information for a column <em><code>column_name</code></em> in the table <em><code>table_name</code></em> using the following query: </p><pre class="programlisting copytoclipboard language-sql"><code class="language-sql">SELECT HEX(<em>column_name</em>) FROM <em>table_name</em>;</code></pre><p> <code>3F</code> is the encoding for the <code>?</code> character; this means that <code>?</code> is the character actually stored in the column. This most often happens because of a problem converting a particular character from your client character set to the target character set. </p></li><li><p> <span><em>Make sure that a round trip is possible. When you select <em><code>literal</code></em> (or <em><code>_introducer hexadecimal-value</code></em>), do you obtain <em><code>literal</code></em> as a result</em></span>? </p><p> For example, the Japanese Katakana character <span class="foreignphrase"><em class="foreignphrase">Pe</em></span> (<code>ペ'</code>) exists in all CJK character sets, and has the code point value (hexadecimal coding) <code>0x30da</code>. To test a round trip for this character, use this query: </p><pre class="programlisting copytoclipboard language-sql one-line"><code class="language-sql">SELECT 'ペ' AS `ペ`;         /* or SELECT _ucs2 0x30da; */</code></pre><p> If the result is not also <code>ペ</code>, the round trip failed. </p><p> For bug reports regarding such failures, we might ask you to follow up with <code>SELECT HEX('ペ');</code>. Then we can determine whether the client encoding is correct. </p></li><li><p> <span><em>Make sure that the problem is not with the browser or other application, rather than with MySQL</em></span>. </p><p> Use the <span><strong>mysql</strong></span> client program to accomplish this task. If <span><strong>mysql</strong></span> displays characters correctly but your application does not, your problem is probably due to system settings. </p><p> To determine your settings, use the <code>SHOW VARIABLES</code> statement, whose output should resemble what is shown here: </p><pre class="programlisting copytoclipboard language-sql"><code class="language-sql">mysql&gt; SHOW VARIABLES LIKE 'char%'; +--------------------------+----------------------------------------+ | Variable_name            | Value                                  | +--------------------------+----------------------------------------+ | character_set_client     | utf8                                   | | character_set_connection | utf8                                   | | character_set_database   | latin1                                 | | character_set_filesystem | binary                                 | | character_set_results    | utf8                                   | | character_set_server     | latin1                                 | | character_set_system     | utf8                                   | | character_sets_dir       | /usr/local/mysql/share/mysql/charsets/ | +--------------------------+----------------------------------------+</code></pre><p> These are typical character-set settings for an international-oriented client (notice the use of <code>utf8</code> Unicode) connected to a server in the West (<code>latin1</code> is a West Europe character set). </p><p> Although Unicode (usually the <code>utf8</code> variant on Unix, and the <code>ucs2</code> variant on Windows) is preferable to Latin, it is often not what your operating system utilities support best. Many Windows users find that a Microsoft character set, such as <code>cp932</code> for Japanese Windows, is suitable. </p><p> If you cannot control the server settings, and you have no idea what setting your underlying computer uses, try changing to a common character set for the country that you're in (<code>euckr</code> = Korea; <code>gb18030</code>, <code>gb2312</code> or <code>gbk</code> = People's Republic of China; <code>big5</code> = Taiwan; <code>sjis</code>, <code>ujis</code>, <code>cp932</code>, or <code>eucjpms</code> = Japan; <code>ucs2</code> or <code>utf8</code> = anywhere). Usually it is necessary to change only the client and connection and results settings. The <code>SET NAMES</code>. statement changes all three at once. For example: </p><pre class="programlisting copytoclipboard language-sql one-line"><code class="language-sql">SET NAMES 'big5';</code></pre><p> Once the setting is correct, you can make it permanent by editing <code>my.cnf</code> or <code>my.ini</code>. For example you might add lines looking like these: </p><pre class="programlisting copytoclipboard language-ini"><code class="language-ini">[mysqld] character-set-server=big5 [client] default-character-set=big5</code></pre><p> It is also possible that there are issues with the API configuration setting being used in your application; see <em class="citetitle">Why does my GUI front end or browser not display CJK characters correctly...?</em> for more information. </p></li></ul> </div> </td></tr><tr class="question"><td align="left" valign="top"><p><b>A.11.3.</b></p></td><td align="left" valign="top"><p> What problems should I be aware of when working with the Big5 Chinese character set? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> MySQL supports the Big5 character set which is common in Hong Kong and Taiwan (Republic of China). The MySQL <code>big5</code> character set is in reality Microsoft code page 950, which is very similar to the original <code>big5</code> character set. </p><p> A feature request for adding <code>HKSCS</code> extensions has been filed. People who need this extension may find the suggested patch for Bug #13577 to be of interest. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.11.4.</b></p></td><td align="left" valign="top"><p> Why do Japanese character set conversions fail? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> MySQL supports the <code>sjis</code>, <code>ujis</code>, <code>cp932</code>, and <code>eucjpms</code> character sets, as well as Unicode. A common need is to convert between character sets. For example, there might be a Unix server (typically with <code>sjis</code> or <code>ujis</code>) and a Windows client (typically with <code>cp932</code>). </p><p> In the following conversion table, the <code>ucs2</code> column represents the source, and the <code>sjis</code>, <code>cp932</code>, <code>ujis</code>, and <code>eucjpms</code> columns represent the destinations; that is, the last 4 columns provide the hexadecimal result when we use <code>CONVERT(ucs2)</code> or we assign a <code>ucs2</code> column containing the value to an <code>sjis</code>, <code>cp932</code>, <code>ujis</code>, or <code>eucjpms</code> column. </p> <div class="informaltable"> <table><col style="width: 40%"/><col align="left" style="width: 12%"/><col align="right" style="width: 12%"/><col align="right" style="width: 12%"/><col align="right" style="width: 12%"/><col align="right" style="width: 12%"/><thead><tr> <th scope="col">Character Name</th> <th scope="col">ucs2</th> <th scope="col">sjis</th> <th scope="col">cp932</th> <th scope="col">ujis</th> <th scope="col">eucjpms</th> </tr></thead><tbody><tr> <th>BROKEN BAR</th> <td>00A6</td> <td>3F</td> <td>3F</td> <td>8FA2C3</td> <td>3F</td> </tr><tr> <th>FULLWIDTH BROKEN BAR</th> <td>FFE4</td> <td>3F</td> <td>FA55</td> <td>3F</td> <td>8FA2</td> </tr><tr> <th>YEN SIGN</th> <td>00A5</td> <td>3F</td> <td>3F</td> <td>20</td> <td>3F</td> </tr><tr> <th>FULLWIDTH YEN SIGN</th> <td>FFE5</td> <td>818F</td> <td>818F</td> <td>A1EF</td> <td>3F</td> </tr><tr> <th>TILDE</th> <td>007E</td> <td>7E</td> <td>7E</td> <td>7E</td> <td>7E</td> </tr><tr> <th>OVERLINE</th> <td>203E</td> <td>3F</td> <td>3F</td> <td>20</td> <td>3F</td> </tr><tr> <th>HORIZONTAL BAR</th> <td>2015</td> <td>815C</td> <td>815C</td> <td>A1BD</td> <td>A1BD</td> </tr><tr> <th>EM DASH</th> <td>2014</td> <td>3F</td> <td>3F</td> <td>3F</td> <td>3F</td> </tr><tr> <th>REVERSE SOLIDUS</th> <td>005C</td> <td>815F</td> <td>5C</td> <td>5C</td> <td>5C</td> </tr><tr> <th>FULLWIDTH REVERSE SOLIDUS</th> <td>FF3C</td> <td>3F</td> <td>815F</td> <td>3F</td> <td>A1C0</td> </tr><tr> <th>WAVE DASH</th> <td>301C</td> <td>8160</td> <td>3F</td> <td>A1C1</td> <td>3F</td> </tr><tr> <th>FULLWIDTH TILDE</th> <td>FF5E</td> <td>3F</td> <td>8160</td> <td>3F</td> <td>A1C1</td> </tr><tr> <th>DOUBLE VERTICAL LINE</th> <td>2016</td> <td>8161</td> <td>3F</td> <td>A1C2</td> <td>3F</td> </tr><tr> <th>PARALLEL TO</th> <td>2225</td> <td>3F</td> <td>8161</td> <td>3F</td> <td>A1C2</td> </tr><tr> <th>MINUS SIGN</th> <td>2212</td> <td>817C</td> <td>3F</td> <td>A1DD</td> <td>3F</td> </tr><tr> <th>FULLWIDTH HYPHEN-MINUS</th> <td>FF0D</td> <td>3F</td> <td>817C</td> <td>3F</td> <td>A1DD</td> </tr><tr> <th>CENT SIGN</th> <td>00A2</td> <td>8191</td> <td>3F</td> <td>A1F1</td> <td>3F</td> </tr><tr> <th>FULLWIDTH CENT SIGN</th> <td>FFE0</td> <td>3F</td> <td>8191</td> <td>3F</td> <td>A1F1</td> </tr><tr> <th>POUND SIGN</th> <td>00A3</td> <td>8192</td> <td>3F</td> <td>A1F2</td> <td>3F</td> </tr><tr> <th>FULLWIDTH POUND SIGN</th> <td>FFE1</td> <td>3F</td> <td>8192</td> <td>3F</td> <td>A1F2</td> </tr><tr> <th>NOT SIGN</th> <td>00AC</td> <td>81CA</td> <td>3F</td> <td>A2CC</td> <td>3F</td> </tr><tr> <th>FULLWIDTH NOT SIGN</th> <td>FFE2</td> <td>3F</td> <td>81CA</td> <td>3F</td> <td>A2CC</td> </tr></tbody></table> </div> <p> Now consider the following portion of the table. </p> <div class="informaltable"> <table><col style="width: 55%"/><col align="right" style="width: 15%"/><col align="right" style="width: 15%"/><col align="right" style="width: 15%"/><thead><tr> <th scope="col"></th> <th scope="col">ucs2</th> <th scope="col">sjis</th> <th scope="col">cp932</th> </tr></thead><tbody><tr> <th>NOT SIGN</th> <td>00AC</td> <td>81CA</td> <td>3F</td> </tr><tr> <th>FULLWIDTH NOT SIGN</th> <td>FFE2</td> <td>3F</td> <td>81CA</td> </tr></tbody></table> </div> <p> This means that MySQL converts the <code>NOT SIGN</code> (Unicode <code>U+00AC</code>) to <code>sjis</code> code point <code>0x81CA</code> and to <code>cp932</code> code point <code>3F</code>. (<code>3F</code> is the question mark (<span class="quote">“<span class="quote">?</span>”</span>. This is what is always used when the conversion cannot be performed.) </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.11.5.</b></p></td><td align="left" valign="top"><p> What should I do if I want to convert SJIS <code>81CA</code> to <code>cp932</code>? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> Our answer is: <span class="quote">“<span class="quote">?</span>”</span>. There are disadvantages to this, and many people would prefer a <span class="quote">“<span class="quote">loose</span>”</span> conversion, so that <code>81CA (NOT SIGN)</code> in <code>sjis</code> becomes <code>81CA (FULLWIDTH NOT SIGN)</code> in <code>cp932</code>. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.11.6.</b></p></td><td align="left" valign="top"><p> How does MySQL represent the Yen (<code>¥</code>) sign? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> A problem arises because some versions of Japanese character sets (both <code>sjis</code> and <code>euc</code>) treat <code>5C</code> as a <span class="firstterm">reverse solidus</span> (<code>\</code>, also known as a backslash), whereas others treat it as a yen sign (<code>¥</code>). </p><p> MySQL follows only one version of the JIS (Japanese Industrial Standards) standard description. In MySQL, <span><em><code>5C</code> is always the reverse solidus (<code>\</code>)</em></span>. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.11.7.</b></p></td><td align="left" valign="top"><p> Of what issues should I be aware when working with Korean character sets in MySQL? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> In theory, while there have been several versions of the <code>euckr</code> (<span class="firstterm">Extended Unix Code Korea</span>) character set, only one problem has been noted. We use the <span class="quote">“<span class="quote">ASCII</span>”</span> variant of EUC-KR, in which the code point <code>0x5c</code> is REVERSE SOLIDUS, that is <code>\</code>, instead of the <span class="quote">“<span class="quote">KS-Roman</span>”</span> variant of EUC-KR, in which the code point <code>0x5c</code> is <code>WON SIGN</code> (<code>₩</code>). This means that you cannot convert Unicode <code>U+20A9</code> to <code>euckr</code>: </p><pre class="programlisting copytoclipboard language-sql"><code class="language-sql">mysql&gt; SELECT CONVERT('₩' USING euckr) AS euckr, HEX(CONVERT('₩' USING euckr)) AS hexeuckr; +-------+----------+ | euckr | hexeuckr | +-------+----------+ | ?     | 3F       | +-------+----------+</code></pre></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.11.8.</b></p></td><td align="left" valign="top"><p> Why do I get <span class="errortext">Incorrect string value</span> error messages? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> To see the problem, create a table with one Unicode (<code>ucs2</code>) column and one Chinese (<code>gb2312</code>) column. </p><pre class="programlisting copytoclipboard language-sql"><code class="language-sql">mysql&gt; CREATE TABLE ch (ucs2 CHAR(3) CHARACTER SET ucs2, gb2312 CHAR(3) CHARACTER SET gb2312);</code></pre><p> In nonstrict SQL mode, try to place the rare character <code>汌</code> in both columns. </p><pre class="programlisting copytoclipboard language-sql"><code class="language-sql">mysql&gt; SET sql_mode = ''; mysql&gt; INSERT INTO ch VALUES ('A汌B','A汌B'); Query OK, 1 row affected, 1 warning (0.00 sec)</code></pre><p> The <code>INSERT</code> produces a warning. Use the following statement to see what it is: </p><pre class="programlisting copytoclipboard language-sql"><code class="language-sql">mysql&gt; SHOW WARNINGS\G *************************** 1. row *************************** Level: Warning Code: 1366 Message: Incorrect string value: '\xE6\xB1\x8CB' for column 'gb2312' at row 1</code></pre><p> So it is a warning about the <code>gb2312</code> column only. </p><pre class="programlisting copytoclipboard language-sql"><code class="language-sql">mysql&gt; SELECT ucs2,HEX(ucs2),gb2312,HEX(gb2312) FROM ch; +-------+--------------+--------+-------------+ | ucs2  | HEX(ucs2)    | gb2312 | HEX(gb2312) | +-------+--------------+--------+-------------+ | A汌B | 00416C4C0042 | A?B    | 413F42      | +-------+--------------+--------+-------------+</code></pre><p> Several things need explanation here: </p> <div class="orderedlist"> <ol class="orderedlist" type="1"><li><p> The <code>汌</code> character is not in the <code>gb2312</code> character set, as described earlier. </p></li><li><p> If you are using an old version of MySQL, you may see a different message. </p></li><li><p> A warning occurs rather than an error because MySQL is not set to use strict SQL mode. In nonstrict mode, MySQL tries to do what it can, to get the best fit, rather than give up. With strict SQL mode, the <span class="errortext">Incorrect string value</span> message occurs as an error rather than a warning, and the <code>INSERT</code> fails. </p></li></ol> </div> </td></tr><tr class="question"><td align="left" valign="top"><p><b>A.11.9.</b></p></td><td align="left" valign="top"><p> Why does my GUI front end or browser display CJK characters incorrectly in my application using Access, PHP, or another API? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> Obtain a direct connection to the server using the <span><strong>mysql</strong></span> client, and try the same query there. If <span><strong>mysql</strong></span> responds correctly, the trouble may be that your application interface requires initialization. Use <span><strong>mysql</strong></span> to tell you what character set or sets it uses with the statement <code>SHOW VARIABLES LIKE 'char%';</code>. If you are using Access, you are most likely connecting with Connector/ODBC. In this case, you should check Configuring Connector/ODBC. If, for example, you use <code>big5</code>, you would enter <code>SET NAMES 'big5'</code>. (In this case, no <code>;</code> character is required.) If you are using ASP, you might need to add <code>SET NAMES</code> in the code. Here is an example that has worked in the past: </p><pre class="programlisting copytoclipboard language-none"><code class="language-none">&lt;% Session.CodePage=0 Dim strConnection Dim Conn strConnection="driver={MySQL ODBC 3.51 Driver};server=<em>server</em>;uid=<em>username</em>;" \ &amp; "pwd=<em>password</em>;database=<em>database</em>;stmt=SET NAMES 'big5';" Set Conn = Server.CreateObject("ADODB.Connection") Conn.Open strConnection %&gt;</code></pre><p> In much the same way, if you are using any character set other than <code>latin1</code> with Connector/NET, you must specify the character set in the connection string. See Connector/NET Connections, for more information. </p><p> If you are using PHP, try this: </p><pre class="programlisting copytoclipboard language-php"><code class="language-php">&lt;?php $link = new mysqli($host, $usr, $pwd, $db);

  if( mysqli_connect_errno() ) { printf("Connect failed: %s\n", mysqli_connect_error()); exit(); }

  $link-&gt;query("SET NAMES 'utf8'"); ?&gt;</code></pre><p> In this case, we used <code>SET NAMES</code> to change <code>character_set_client</code>, <code>character_set_connection</code>, and <code>character_set_results</code>. </p><p> Another issue often encountered in PHP applications has to do with assumptions made by the browser. Sometimes adding or changing a <code>&lt;meta&gt;</code> tag suffices to correct the problem: for example, to insure that the user agent interprets page content as <code>UTF-8</code>, include <code>&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;</code> in the <code>&lt;head&gt;</code> section of the HTML page. </p><p> If you are using Connector/J, see Using Character Sets and Unicode. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.11.10.</b></p></td><td align="left" valign="top"><p> I've upgraded to MySQL 8.4. How can I revert to behavior like that in MySQL 4.0 with regard to character sets? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> In MySQL Version 4.0, there was a single <span class="quote">“<span class="quote">global</span>”</span> character set for both server and client, and the decision as to which character to use was made by the server administrator. This changed starting with MySQL Version 4.1. What happens now is a <span class="quote">“<span class="quote">handshake</span>”</span>, as described in Section 12.4, “Connection Character Sets and Collations”: </p> <div class="blockquote"> <blockquote class="blockquote"><p> When a client connects, it sends to the server the name of the character set that it wants to use. The server uses the name to set the <code>character_set_client</code>, <code>character_set_results</code>, and <code>character_set_connection</code> system variables. In effect, the server performs a <code>SET NAMES</code> operation using the character set name. </p></blockquote> </div> <p> The effect of this is that you cannot control the client character set by starting <span><strong>mysqld</strong></span> with <code class="option">--character-set-server=utf8</code>. However, some Asian customers prefer the MySQL 4.0 behavior. To make it possible to retain this behavior, we added a <span><strong>mysqld</strong></span> switch, <code class="option">--character-set-client-handshake</code>, which can be turned off with <code class="option">--skip-character-set-client-handshake</code>. If you start <span><strong>mysqld</strong></span> with <code class="option">--skip-character-set-client-handshake</code>, then, when a client connects, it sends to the server the name of the character set that it wants to use. However, <span><em>the server ignores this request from the client</em></span>. </p><p> By way of example, suppose that your favorite server character set is <code>latin1</code>. Suppose further that the client uses <code>utf8</code> because this is what the client's operating system supports. Start the server with <code>latin1</code> as its default character set: </p><pre class="programlisting copytoclipboard language-terminal one-line"><code class="language-terminal">mysqld --character-set-server=latin1</code></pre><p> And then start the client with the default character set <code>utf8</code>: </p><pre class="programlisting copytoclipboard language-terminal one-line"><code class="language-terminal">mysql --default-character-set=utf8</code></pre><p> The resulting settings can be seen by viewing the output of <code>SHOW VARIABLES</code>: </p><pre class="programlisting copytoclipboard language-sql"><code class="language-sql">mysql&gt; SHOW VARIABLES LIKE 'char%'; +--------------------------+----------------------------------------+ | Variable_name            | Value                                  | +--------------------------+----------------------------------------+ | character_set_client     | utf8                                   | | character_set_connection | utf8                                   | | character_set_database   | latin1                                 | | character_set_filesystem | binary                                 | | character_set_results    | utf8                                   | | character_set_server     | latin1                                 | | character_set_system     | utf8                                   | | character_sets_dir       | /usr/local/mysql/share/mysql/charsets/ | +--------------------------+----------------------------------------+</code></pre><p> Now stop the client, and stop the server using <span><strong>mysqladmin</strong></span>. Then start the server again, but this time tell it to skip the handshake like so: </p><pre class="programlisting copytoclipboard language-terminal one-line"><code class="language-terminal">mysqld --character-set-server=utf8 --skip-character-set-client-handshake</code></pre><p> Start the client with <code>utf8</code> once again as the default character set, then display the resulting settings: </p><pre class="programlisting copytoclipboard language-sql"><code class="language-sql">mysql&gt; SHOW VARIABLES LIKE 'char%'; +--------------------------+----------------------------------------+ | Variable_name            | Value                                  | +--------------------------+----------------------------------------+ | character_set_client     | latin1                                 | | character_set_connection | latin1                                 | | character_set_database   | latin1                                 | | character_set_filesystem | binary                                 | | character_set_results    | latin1                                 | | character_set_server     | latin1                                 | | character_set_system     | utf8                                   | | character_sets_dir       | /usr/local/mysql/share/mysql/charsets/ | +--------------------------+----------------------------------------+</code></pre><p> As you can see by comparing the differing results from <code>SHOW VARIABLES</code>, the server ignores the client's initial settings if the <code class="option">--skip-character-set-client-handshake</code> option is used. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.11.11.</b></p></td><td align="left" valign="top"><p> Why do some <code>LIKE</code> and <code>FULLTEXT</code> searches with CJK characters fail? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> For <code>LIKE</code> searches, there is a very simple problem with binary string column types such as <code>BINARY</code> and <code>BLOB</code>: we must know where characters end. With multibyte character sets, different characters might have different octet lengths. For example, in <code>utf8</code>, <code>A</code> requires one byte but <code>ペ</code> requires three bytes, as shown here: </p><pre class="programlisting copytoclipboard language-none"><code class="language-none">+-------------------------+---------------------------+ | OCTET_LENGTH(_utf8 'A') | OCTET_LENGTH(_utf8 'ペ') | +-------------------------+---------------------------+ |                       1 |                         3 | +-------------------------+---------------------------+</code></pre><p> If we do not know where the first character in a string ends, we do not know where the second character begins, in which case even very simple searches such as <code>LIKE '_A%'</code> fail. The solution is to use a nonbinary string column type defined to have the proper CJK character set. For example: <code>mycol TEXT CHARACTER SET sjis</code>. Alternatively, convert to a CJK character set before comparing. </p><p> This is one reason why MySQL cannot permit encodings of nonexistent characters. If it is not strict about rejecting bad input, it has no way of knowing where characters end. </p><p> For <code>FULLTEXT</code> searches, we must know where words begin and end. With Western languages, this is rarely a problem because most (if not all) of these use an easy-to-identify word boundary: the space character. However, this is not usually the case with Asian writing. We could use arbitrary halfway measures, like assuming that all Han characters represent words, or (for Japanese) depending on changes from Katakana to Hiragana due to grammatical endings. However, the only sure solution requires a comprehensive word list, which means that we would have to include a dictionary in the server for each Asian language supported. This is simply not feasible. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.11.12.</b></p></td><td align="left" valign="top"><p> How do I know whether character <em><code>X</code></em> is available in all character sets? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> The majority of simplified Chinese and basic nonhalfwidth Japanese Kana characters appear in all CJK character sets. The following stored procedure accepts a <code>UCS-2</code> Unicode character, converts it to other character sets, and displays the results in hexadecimal. </p><pre class="programlisting copytoclipboard language-sql"><code class="language-sql">DELIMITER //

CREATE PROCEDURE p_convert(ucs2_char CHAR(1) CHARACTER SET ucs2) BEGIN

CREATE TABLE tj (ucs2 CHAR(1) character set ucs2, utf8 CHAR(1) character set utf8, big5 CHAR(1) character set big5, cp932 CHAR(1) character set cp932, eucjpms CHAR(1) character set eucjpms, euckr CHAR(1) character set euckr, gb2312 CHAR(1) character set gb2312, gbk CHAR(1) character set gbk, sjis CHAR(1) character set sjis, ujis CHAR(1) character set ujis);

INSERT INTO tj (ucs2) VALUES (ucs2_char);

UPDATE tj SET utf8=ucs2, big5=ucs2, cp932=ucs2, eucjpms=ucs2, euckr=ucs2, gb2312=ucs2, gbk=ucs2, sjis=ucs2, ujis=ucs2;

/* If there are conversion problems, UPDATE produces warnings. */

SELECT hex(ucs2) AS ucs2, hex(utf8) AS utf8, hex(big5) AS big5, hex(cp932) AS cp932, hex(eucjpms) AS eucjpms, hex(euckr) AS euckr, hex(gb2312) AS gb2312, hex(gbk) AS gbk, hex(sjis) AS sjis, hex(ujis) AS ujis FROM tj;

DROP TABLE tj;

END//

DELIMITER ;</code></pre><p> The input can be any single <code>ucs2</code> character, or it can be the code value (hexadecimal representation) of that character. For example, from Unicode's list of <code>ucs2</code> encodings and names (http://www.unicode.org/Public/UNIDATA/UnicodeData.txt), we know that the Katakana character <span class="foreignphrase"><em class="foreignphrase">Pe</em></span> appears in all CJK character sets, and that its code value is <code>X'30DA'</code>. If we use this value as the argument to <code>p_convert()</code>, the result is as shown here: </p><pre class="programlisting copytoclipboard language-sql"><code class="language-sql">mysql&gt; CALL p_convert(X'30DA'); +------+--------+------+-------+---------+-------+--------+------+------+------+ | ucs2 | utf8   | big5 | cp932 | eucjpms | euckr | gb2312 | gbk  | sjis | ujis | +------+--------+------+-------+---------+-------+--------+------+------+------+ | 30DA | E3839A | C772 | 8379  | A5DA    | ABDA  | A5DA   | A5DA | 8379 | A5DA | +------+--------+------+-------+---------+-------+--------+------+------+------+</code></pre><p> Since none of the column values is <code>3F</code> (that is, the question mark character, <code>?</code>), we know that every conversion worked. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.11.13.</b></p></td><td align="left" valign="top"><p> Why do CJK strings sort incorrectly in Unicode? (I) </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> CJK sorting problems that occurred in older MySQL versions can be solved as of MySQL 8.0 by using the <code>utf8mb4</code> character set and the <code>utf8mb4_ja_0900_as_cs</code> collation. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.11.14.</b></p></td><td align="left" valign="top"><p> Why do CJK strings sort incorrectly in Unicode? (II) </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> CJK sorting problems that occurred in older MySQL versions can be solved as of MySQL 8.0 by using the <code>utf8mb4</code> character set and the <code>utf8mb4_ja_0900_as_cs</code> collation. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.11.15.</b></p></td><td align="left" valign="top"><p> Why are my supplementary characters rejected by MySQL? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> Supplementary characters lie outside the Unicode <span><em>Basic Multilingual Plane / Plane 0</em></span>. BMP characters have code point values between <code>U+0000</code> and <code>U+FFFF</code>. Supplementary characters have code point values between <code>U+10000</code> and <code>U+10FFFF</code>. </p><p> To store supplementary characters, you must use a character set that permits them: </p> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: disc; "><li><p> The <code>utf8</code> and <code>ucs2</code> character sets support BMP characters only. </p><p> The <code>utf8</code> character set permits only <code>UTF-8</code> characters that take up to three bytes. This has led to reports such as that found in Bug
            #12600, which we rejected as <span class="quote">“<span class="quote">not a bug</span>”</span>. With <code>utf8</code>, MySQL must truncate an input string when it encounters bytes that it does no understand. Otherwise, it is unknown how long the bad multibyte character is. </p><p> One possible workaround is to use <code>ucs2</code> instead of <code>utf8</code>, in which case the <span class="quote">“<span class="quote">bad</span>”</span> characters are changed to question marks. However, no truncation takes place. You can also change the data type to <code>BLOB</code> or <code>BINARY</code>, which perform no validity checking. </p></li><li><p> The <code>utf8mb4</code>, <code>utf16</code>, <code>utf16le</code>, and <code>utf32</code> character sets support BMP characters, as well as supplementary characters outside the BMP. </p></li></ul> </div> </td></tr><tr class="question"><td align="left" valign="top"><p><b>A.11.16.</b></p></td><td align="left" valign="top"><p> Should <span class="quote">“<span class="quote">CJK</span>”</span> be <span class="quote">“<span class="quote">CJKV</span>”</span>? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> No. The term <span class="quote">“<span class="quote">CJKV</span>”</span> (<span class="firstterm">Chinese Japanese Korean Vietnamese</span>) refers to Vietnamese character sets which contain Han (originally Chinese) characters. MySQL supports the modern Vietnamese script with Western characters, but does not support the old Vietnamese script using Han characters. </p><p> As of MySQL 5.6, there are Vietnamese collations for Unicode character sets, as described in Section 12.10.1, “Unicode Character Sets”. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.11.17.</b></p></td><td align="left" valign="top"><p> Does MySQL permit CJK characters to be used in database and table names? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> Yes. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.11.18.</b></p></td><td align="left" valign="top"><p> Where can I find translations of the MySQL Manual into Chinese, Japanese, and Korean? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> The Japanese translation of the MySQL 5.6 manual can be downloaded from https://dev.mysql.com/doc/. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.11.19.</b></p></td><td align="left" valign="top"><p> Where can I get help with CJK and related issues in MySQL? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> The following resources are available: </p> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: disc; "><li><p> A listing of MySQL user groups can be found at https://wikis.oracle.com/display/mysql/List+of+MySQL+User+Groups. </p></li><li><p> View feature requests relating to character set issues at http://tinyurl.com/y6xcuf. </p></li><li><p> Visit the MySQL Character Sets, Collation, Unicode Forum. http://forums.mysql.com/ also provides foreign-language forums. </p></li></ul> </div> <p> </p></td></tr></tbody></table>
