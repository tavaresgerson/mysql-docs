## A.14 MySQL 8.0 FAQ: Replication

In the following section, we provide answers to questions that are most frequently asked about MySQL Replication.

A.14.1. Must the replica be connected to the source all the time?

A.14.2. Must I enable networking on my source and replica to enable replication?

A.14.3. How do I know how late a replica is compared to the source? In other words, how do I know the date of the last statement replicated by the replica?

A.14.4. How do I force the source to block updates until the replica catches up?

A.14.5. What issues should I be aware of when setting up two-way replication?

A.14.6. How can I use replication to improve performance of my system?

A.14.7. What should I do to prepare client code in my own applications to use performance-enhancing replication?

A.14.8. When and how much can MySQL replication improve the performance of my system?

A.14.9. How can I use replication to provide redundancy or high availability?

A.14.10. How do I tell whether a replication source server is using statement-based or row-based binary logging format?

A.14.11. How do I tell a replica to use row-based replication?

A.14.12. How do I prevent GRANT and REVOKE statements from replicating to replica machines?

A.14.13. Does replication work on mixed operating systems (for example, the source runs on Linux while replicas run on macOS and Windows)?

A.14.14. Does replication work on mixed hardware architectures (for example, the source runs on a 64-bit machine while replicas run on 32-bit machines)?

<table border="0" style="width: 100%;"><colgroup><col/></colgroup><tbody><tr class="question"><td align="left" valign="top"><p><b>A.14.1.</b></p></td><td align="left" valign="top"><p> Must the replica be connected to the source all the time? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> No, it does not. The replica can go down or stay disconnected for hours or even days, and then reconnect and catch up on updates. For example, you can set up a source/replica relationship over a dial-up link where the link is up only sporadically and for short periods of time. The implication of this is that, at any given time, the replica is not guaranteed to be in synchrony with the source unless you take some special measures. </p><p> To ensure that catchup can occur for a replica that has been disconnected, you must not remove binary log files from the source that contain information that has not yet been replicated to the replicas. Asynchronous replication can work only if the replica is able to continue reading the binary log from the point where it last read events. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.14.2.</b></p></td><td align="left" valign="top"><p> Must I enable networking on my source and replica to enable replication? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> Yes, networking must be enabled on the source and replica. If networking is not enabled, the replica cannot connect to the source and transfer the binary log. Verify that the <code>skip_networking</code> system variable has not been enabled in the configuration file for either server. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.14.3.</b></p></td><td align="left" valign="top"><p> How do I know how late a replica is compared to the source? In other words, how do I know the date of the last statement replicated by the replica? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> Check the <code>Seconds_Behind_Master</code> column in the output from <code>SHOW REPLICA | SLAVE STATUS</code>. See Section 19.1.7.1, “Checking Replication Status”. </p><p> When the replication SQL thread executes an event read from the source, it modifies its own time to the event timestamp. (This is why <code>TIMESTAMP</code> is well replicated.) In the <code>Time</code> column in the output of <code>SHOW PROCESSLIST</code>, the number of seconds displayed for the replication SQL thread is the number of seconds between the timestamp of the last replicated event and the real time of the replica machine. You can use this to determine the date of the last replicated event. Note that if your replica has been disconnected from the source for one hour, and then reconnects, you may immediately see large <code>Time</code> values such as 3600 for the replication SQL thread in <code>SHOW PROCESSLIST</code>. This is because the replica is executing statements that are one hour old. See Section 19.2.3, “Replication Threads”. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.14.4.</b></p></td><td align="left" valign="top"><p> How do I force the source to block updates until the replica catches up? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> Use the following procedure: </p> <div class="orderedlist"> <ol class="orderedlist" type="1"><li class="listitem"><p> On the source, execute these statements: </p><pre class="programlisting copytoclipboard language-sql"><code class="language-sql">mysql&gt; FLUSH TABLES WITH READ LOCK; mysql&gt; SHOW MASTER STATUS;</code></pre><p> Record the replication coordinates (the current binary log file name and position) from the output of the <code>SHOW</code> statement. </p></li><li class="listitem"><p> On the replica, issue the following statement, where the arguments to the <code>SOURCE_POS_WAIT()</code> or <code>MASTER_POS_WAIT()</code> function are the replication coordinate values obtained in the previous step: </p><pre class="programlisting copytoclipboard language-sql"><code class="language-sql">mysql&gt; SELECT MASTER_POS_WAIT('<em class="replaceable">log_name</em>', <em class="replaceable">log_pos</em>);

Or from MySQL 8.0.26: mysql&gt; SELECT SOURCE_POS_WAIT('<em class="replaceable">log_name</em>', <em class="replaceable">log_pos</em>);</code></pre><p> The <code>SELECT</code> statement blocks until the replica reaches the specified log file and position. At that point, the replica is in synchrony with the source and the statement returns. </p></li><li class="listitem"><p> On the source, issue the following statement to enable the source to begin processing updates again: </p><pre class="programlisting copytoclipboard language-sql one-line"><code class="language-sql">mysql&gt; UNLOCK TABLES;</code></pre></li></ol> </div> </td></tr><tr class="question"><td align="left" valign="top"><p><b>A.14.5.</b></p></td><td align="left" valign="top"><p> What issues should I be aware of when setting up two-way replication? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> MySQL replication currently does not support any locking protocol between source and replica to guarantee the atomicity of a distributed (cross-server) update. In other words, it is possible for client A to make an update to co-source 1, and in the meantime, before it propagates to co-source 2, client B could make an update to co-source 2 that makes the update of client A work differently than it did on co-source 1. Thus, when the update of client A makes it to co-source 2, it produces tables that are different from what you have on co-source 1, even after all the updates from co-source 2 have also propagated. This means that you should not chain two servers together in a two-way replication relationship unless you are sure that your updates can safely happen in any order, or unless you take care of mis-ordered updates somehow in the client code. </p><p> You should also realize that two-way replication actually does not improve performance very much (if at all) as far as updates are concerned. Each server must do the same number of updates, just as you would have a single server do. The only difference is that there is a little less lock contention because the updates originating on another server are serialized in one replication thread. Even this benefit might be offset by network delays. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.14.6.</b></p></td><td align="left" valign="top"><p> How can I use replication to improve performance of my system? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> Set up one server as the source and direct all writes to it. Then configure as many replicas as you have the budget and rackspace for, and distribute the reads among the source and the replicas. You can also start the replicas with the <code>--skip-innodb</code> option, enable the <code>low_priority_updates</code> system variable, and set the <code>delay_key_write</code> system variable to <code>ALL</code> to get speed improvements on the replica end. In this case, the replica uses nontransactional <code>MyISAM</code> tables instead of <code>InnoDB</code> tables to get more speed by eliminating transactional overhead. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.14.7.</b></p></td><td align="left" valign="top"><p> What should I do to prepare client code in my own applications to use performance-enhancing replication? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> See the guide to using replication as a scale-out solution, Section 19.4.5, “Using Replication for Scale-Out”. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.14.8.</b></p></td><td align="left" valign="top"><p> When and how much can MySQL replication improve the performance of my system? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> MySQL replication is most beneficial for a system that processes frequent reads and infrequent writes. In theory, by using a single-source/multiple-replica setup, you can scale the system by adding more replicas until you either run out of network bandwidth, or your update load grows to the point that the source cannot handle it. </p><p> To determine how many replicas you can use before the added benefits begin to level out, and how much you can improve performance of your site, you must know your query patterns, and determine empirically by benchmarking the relationship between the throughput for reads and writes on a typical source and a typical replica. The example here shows a rather simplified calculation of what you can get with replication for a hypothetical system. Let <code>reads</code> and <code>writes</code> denote the number of reads and writes per second, respectively. </p><p> Let's say that system load consists of 10% writes and 90% reads, and we have determined by benchmarking that <code>reads</code> is 1200 - 2 * <code>writes</code>. In other words, the system can do 1,200 reads per second with no writes, the average write is twice as slow as the average read, and the relationship is linear. Suppose that the source and each replica have the same capacity, and that we have one source and <em class="replaceable"><code>N</code></em> replicas. Then we have for each server (source or replica): </p><p> <code>reads</code> = 1200 - 2 * <code>writes</code> </p><p> <code>reads</code> = 9 * <code>writes</code> / (<em class="replaceable"><code>N</code></em> + 1) (reads are split, but writes replicated to all replicas) </p><p> 9 * <code>writes</code> / (<em class="replaceable"><code>N</code></em> + 1) + 2 * <code>writes</code> = 1200 </p><p> <code>writes</code> = 1200 / (2 + 9/(<em class="replaceable"><code>N</code></em> + 1)) </p><p> The last equation indicates the maximum number of writes for <em class="replaceable"><code>N</code></em> replicas, given a maximum possible read rate of 1,200 per second and a ratio of nine reads per write. </p><p> This analysis yields the following conclusions: </p> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p> If <em class="replaceable"><code>N</code></em> = 0 (which means we have no replication), our system can handle about 1200/11 = 109 writes per second. </p></li><li class="listitem"><p> If <em class="replaceable"><code>N</code></em> = 1, we get up to 184 writes per second. </p></li><li class="listitem"><p> If <em class="replaceable"><code>N</code></em> = 8, we get up to 400 writes per second. </p></li><li class="listitem"><p> If <em class="replaceable"><code>N</code></em> = 17, we get up to 480 writes per second. </p></li><li class="listitem"><p> Eventually, as <em class="replaceable"><code>N</code></em> approaches infinity (and our budget negative infinity), we can get very close to 600 writes per second, increasing system throughput about 5.5 times. However, with only eight servers, we increase it nearly four times. </p></li></ul> </div> <p> These computations assume infinite network bandwidth and neglect several other factors that could be significant on your system. In many cases, you may not be able to perform a computation similar to the one just shown that accurately predicts what happens on your system if you add <em class="replaceable"><code>N</code></em> replicas. However, answering the following questions should help you decide whether and by how much replication may improve the performance of your system: </p> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p> What is the read/write ratio on your system? </p></li><li class="listitem"><p> How much more write load can one server handle if you reduce the reads? </p></li><li class="listitem"><p> For how many replicas do you have bandwidth available on your network? </p></li></ul> </div> </td></tr><tr class="question"><td align="left" valign="top"><p><b>A.14.9.</b></p></td><td align="left" valign="top"><p> How can I use replication to provide redundancy or high availability? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> How you implement redundancy is entirely dependent on your application and circumstances. High-availability solutions (with automatic failover) require active monitoring and either custom scripts or third party tools to provide the failover support from the original MySQL server to the replica. </p><p> To handle the process manually, you should be able to switch from a failed source to a pre-configured replica by altering your application to talk to the new server or by adjusting the DNS for the MySQL server from the failed server to the new server. </p><p> For more information and some example solutions, see Section 19.4.8, “Switching Sources During Failover”. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.14.10.</b></p></td><td align="left" valign="top"><p> How do I tell whether a replication source server is using statement-based or row-based binary logging format? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> Check the value of the <code>binlog_format</code> system variable: </p><pre class="programlisting copytoclipboard language-sql one-line"><code class="language-sql">mysql&gt; SHOW VARIABLES LIKE 'binlog_format';</code></pre><p> The value shown is always one of <code>STATEMENT</code>, <code>ROW</code>, or <code>MIXED</code>. For <code>MIXED</code> mode, statement-based logging is used by default but replication switches automatically to row-based logging under certain conditions, such as unsafe statements. For information about when this may occur, see Section 7.4.4.3, “Mixed Binary Logging Format”. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.14.11.</b></p></td><td align="left" valign="top"><p> How do I tell a replica to use row-based replication? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> Replicas automatically know which format to use. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.14.12.</b></p></td><td align="left" valign="top"><p> How do I prevent <code>GRANT</code> and <code>REVOKE</code> statements from replicating to replica machines? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> Start the server with the <code>--replicate-wild-ignore-table=mysql.%</code> option to ignore replication for tables in the <code>mysql</code> database. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.14.13.</b></p></td><td align="left" valign="top"><p> Does replication work on mixed operating systems (for example, the source runs on Linux while replicas run on macOS and Windows)? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> Yes. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.14.14.</b></p></td><td align="left" valign="top"><p> Does replication work on mixed hardware architectures (for example, the source runs on a 64-bit machine while replicas run on 32-bit machines)? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> Yes. </p></td></tr></tbody></table>
