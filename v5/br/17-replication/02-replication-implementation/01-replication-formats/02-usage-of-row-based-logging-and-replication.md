#### 16.2.1.2 Uso de Row-Based Logging e Replication

O MySQL utiliza logging baseado em statement (SBL), logging baseado em row (RBL) ou logging de formato misto. O tipo de Binary Log utilizado afeta o tamanho e a eficiência do logging. Portanto, a escolha entre Row-Based Replication (RBR) ou Statement-Based Replication (SBR) depende da sua aplicação e ambiente. Esta seção descreve problemas conhecidos ao usar um log de formato baseado em row e algumas melhores práticas para seu uso em Replication.

Para informações adicionais, consulte [Section 16.2.1, “Replication Formats”](replication-formats.html "16.2.1 Replication Formats") e [Section 16.2.1.1, “Advantages and Disadvantages of Statement-Based and Row-Based Replication”](replication-sbr-rbr.html "16.2.1.1 Advantages and Disadvantages of Statement-Based and Row-Based Replication").

Para informações sobre problemas específicos do NDB Cluster Replication (que depende do Row-Based Replication), consulte [Section 21.7.3, “Known Issues in NDB Cluster Replication”](mysql-cluster-replication-issues.html "21.7.3 Known Issues in NDB Cluster Replication").

* **Logging baseado em row de temporary tables.** Conforme observado em [Section 16.4.1.29, “Replication and Temporary Tables”](replication-features-temptables.html "16.4.1.29 Replication and Temporary Tables"), temporary tables não são replicadas ao usar o formato baseado em row. Ao usar logging de formato misto, statements "seguros" envolvendo temporary tables são registrados usando o formato baseado em statement. Para obter mais informações, consulte [Section 16.2.1.1, “Advantages and Disadvantages of Statement-Based and Row-Based Replication”](replication-sbr-rbr.html "16.2.1.1 Advantages and Disadvantages of Statement-Based and Row-Based Replication").

  Temporary tables não são replicadas ao usar o formato baseado em row porque não há necessidade. Além disso, como temporary tables só podem ser lidas a partir do Thread que as criou, raramente há algum benefício obtido ao replicá-las, mesmo usando o formato baseado em statement.

  Você pode mudar do formato de Binary Logging baseado em statement para o baseado em row em tempo de execução, mesmo quando temporary tables tiverem sido criadas. A partir do MySQL 5.7.25, o servidor MySQL rastreia o modo de logging que estava em vigor quando cada temporary table foi criada. Quando uma determinada sessão do cliente termina, o servidor registra um statement `DROP TEMPORARY TABLE IF EXISTS` para cada temporary table que ainda existe e que foi criada quando o Binary Logging baseado em statement estava em uso. Se o Binary Logging baseado em row ou de formato misto estivesse em uso quando a tabela foi criada, o statement `DROP TEMPORARY TABLE IF EXISTS` não é registrado. Em releases anteriores, o statement `DROP TEMPORARY TABLE IF EXISTS` era registrado independentemente do modo de logging que estava em vigor.

  Statements DML não transacionais envolvendo temporary tables são permitidos ao usar [`binlog_format=ROW`](replication-options-binary-log.html#sysvar_binlog_format), contanto que quaisquer tabelas não transacionais afetadas pelos statements sejam temporary tables (Bug #14272672).

* **RBL e sincronização de nontransactional tables.** Quando muitas rows são afetadas, o conjunto de alterações é dividido em vários events; quando o statement Commit, todos esses events são escritos no Binary Log. Ao executar na replica, um Table Lock é aplicado em todas as tabelas envolvidas e, em seguida, as rows são aplicadas em modo de lote (batch mode). Dependendo do Engine usado para a cópia da tabela na replica, isso pode ou não ser eficaz.

* **Latência e tamanho do Binary Log.** O RBL escreve as alterações para cada row no Binary Log e, portanto, seu tamanho pode aumentar rapidamente. Isso pode aumentar significativamente o tempo necessário para realizar na replica alterações que correspondam às da source. Você deve estar ciente do potencial dessa Latência em suas aplicações.

* **Lendo o Binary Log.** [**mysqlbinlog**](mysqlbinlog.html "4.6.7 mysqlbinlog — Utility for Processing Binary Log Files") exibe events baseados em row no Binary Log usando o statement `BINLOG` (consulte [Section 13.7.6.1, “BINLOG Statement”](binlog.html "13.7.6.1 BINLOG Statement")). Este statement exibe um event como uma string codificada em base 64, cujo significado não é evidente. Quando invocado com as opções [`--base64-output=DECODE-ROWS`](mysqlbinlog.html#option_mysqlbinlog_base64-output) e [`--verbose`](mysqlbinlog.html#option_mysqlbinlog_verbose), o [**mysqlbinlog**](mysqlbinlog.html "4.6.7 mysqlbinlog — Utility for Processing Binary Log Files") formata o conteúdo do Binary Log para ser legível por humanos. Quando os events do Binary Log foram escritos no formato baseado em row e você deseja ler ou se recuperar de uma falha de Replication ou Database, você pode usar este comando para ler o conteúdo do Binary Log. Para mais informações, consulte [Section 4.6.7.2, “mysqlbinlog Row Event Display”](mysqlbinlog-row-events.html "4.6.7.2 mysqlbinlog Row Event Display").

* **Erros de execução do Binary Log e modo de execução da replica.** O uso de [`slave_exec_mode=IDEMPOTENT`](replication-options-replica.html#sysvar_slave_exec_mode) é geralmente útil apenas com MySQL NDB Cluster Replication, para o qual `IDEMPOTENT` é o valor padrão. (Consulte [Section 21.7.10, “NDB Cluster Replication: Bidirectional and Circular Replication”](mysql-cluster-replication-multi-source.html "21.7.10 NDB Cluster Replication: Bidirectional and Circular Replication")). Quando [`slave_exec_mode`](replication-options-replica.html#sysvar_slave_exec_mode) é `IDEMPOTENT`, uma falha ao aplicar alterações do RBL porque a row original não pode ser encontrada não dispara um erro nem causa a falha da Replication. Isso significa que é possível que os Updates não sejam aplicados na replica, fazendo com que a source e a replica não estejam mais sincronizadas. Problemas de Latência e o uso de nontransactional tables com RBR quando [`slave_exec_mode`](replication-options-replica.html#sysvar_slave_exec_mode) é `IDEMPOTENT` podem fazer com que a source e a replica divirjam ainda mais. Para obter mais informações sobre [`slave_exec_mode`](replication-options-replica.html#sysvar_slave_exec_mode), consulte [Section 5.1.7, “Server System Variables”](server-system-variables.html "5.1.7 Server System Variables").

  Para outros cenários, definir [`slave_exec_mode`](replication-options-replica.html#sysvar_slave_exec_mode) como `STRICT` é geralmente suficiente; este é o valor padrão para Storage Engines diferentes de [`NDB`](mysql-cluster.html "Chapter 21 MySQL NDB Cluster 7.5 and NDB Cluster 7.6").

* **Filtragem baseada em Server ID não suportada.** Você pode filtrar com base no Server ID usando a opção `IGNORE_SERVER_IDS` para o statement [`CHANGE MASTER TO`](change-master-to.html "13.4.2.1 CHANGE MASTER TO Statement"). Esta opção funciona com formatos de logging baseados em statement e em row. Outro método para filtrar alterações em algumas replicas é usar uma cláusula `WHERE` que inclua a relação `@@server_id <> id_value` com statements [`UPDATE`](update.html "13.2.11 UPDATE Statement") e [`DELETE`](delete.html "13.2.2 DELETE Statement"). Por exemplo, `WHERE @@server_id <> 1`. No entanto, isso não funciona corretamente com Row-Based Logging. Para usar a variável de sistema [`server_id`](replication-options.html#sysvar_server_id) para filtragem de statement, use Statement-Based Logging.

* **RBL, nontransactional tables e replicas paradas.** Ao usar Row-Based Logging, se o servidor replica for parado enquanto um Replication Thread estiver atualizando uma nontransactional table, o Database da replica poderá atingir um estado inconsistente. Por esta razão, é recomendável que você use um Transactional Storage Engine, como [`InnoDB`](innodb-storage-engine.html "Chapter 14 The InnoDB Storage Engine"), para todas as tabelas replicadas usando o formato baseado em row. O uso de [`STOP SLAVE`](stop-slave.html "13.4.2.6 STOP SLAVE Statement") ou [`STOP SLAVE SQL_THREAD`](stop-slave.html "13.4.2.6 STOP SLAVE Statement") antes de desligar o servidor replica ajuda a evitar que problemas ocorram e é sempre recomendado, independentemente do formato de logging ou do Storage Engine que você utiliza.