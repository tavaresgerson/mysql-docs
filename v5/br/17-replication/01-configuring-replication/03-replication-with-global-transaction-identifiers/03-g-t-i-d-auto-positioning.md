#### 16.1.3.3 Posicionamento Automático (Auto-Positioning) de GTID

GTIDs substituem os pares de arquivo-offset que eram previamente necessários para determinar pontos de partida, parada ou retomada do fluxo de dados entre o source e a replica. Quando GTIDs estão em uso, todas as informações que a replica precisa para se sincronizar com o source são obtidas diretamente do fluxo de dados de replicação.

Para iniciar uma replica usando replicação baseada em GTID, você não deve incluir as opções `MASTER_LOG_FILE` ou `MASTER_LOG_POS` na instrução [`CHANGE MASTER TO`](change-master-to.html "13.4.2.1 CHANGE MASTER TO Statement") usada para direcionar a replica a replicar de um determinado source. Essas opções especificam o nome do arquivo de log e a posição inicial dentro do arquivo, mas com GTIDs a replica não precisa desses dados não locais. Em vez disso, você precisa habilitar a opção `MASTER_AUTO_POSITION`. Para instruções completas sobre como configurar e iniciar sources e replicas usando replicação baseada em GTID, consulte [Seção 16.1.3.4, “Configurando a Replicação Usando GTIDs”](replication-gtids-howto.html "16.1.3.4 Setting Up Replication Using GTIDs").

A opção `MASTER_AUTO_POSITION` é desabilitada por padrão. Se a replicação multi-source estiver habilitada na replica, você precisará definir esta opção para cada canal de replicação aplicável. Desabilitar a opção `MASTER_AUTO_POSITION` novamente faz com que a replica reverta para a replicação baseada em posição.

Quando uma replica tem GTIDs habilitados ([`GTID_MODE=ON`](replication-options-gtids.html#sysvar_gtid_mode), `ON_PERMISSIVE` ou `OFF_PERMISSIVE`) e a opção `MASTER_AUTO_POSITION` habilitada, o posicionamento automático é ativado para a conexão com o source. O source deve ter [`GTID_MODE=ON`](replication-options-gtids.html#sysvar_gtid_mode) definido para que a conexão seja bem-sucedida. No handshake inicial, a replica envia um conjunto (set) de GTIDs contendo as transações que ela já recebeu, cometeu, ou ambas. Este set de GTIDs é igual à união do set de GTIDs na variável de sistema [`gtid_executed`](replication-options-gtids.html#sysvar_gtid_executed) (`@@GLOBAL.gtid_executed`), e o set de GTIDs registrados na tabela [`replication_connection_status`](performance-schema-replication-connection-status-table.html "25.12.11.2 The replication_connection_status Table") do Performance Schema como transações recebidas (o resultado da instrução `SELECT RECEIVED_TRANSACTION_SET FROM PERFORMANCE_SCHEMA.replication_connection_status`).

O source responde enviando todas as transações registradas em seu binary log cujo GTID não está incluído no set de GTIDs enviado pela replica. Para fazer isso, o source primeiro identifica o arquivo de binary log apropriado para começar a trabalhar, verificando o `Previous_gtids_log_event` no cabeçalho de cada um de seus arquivos de binary log, começando pelo mais recente. Quando o source encontra o primeiro `Previous_gtids_log_event` que não contém transações que a replica está perdendo, ele começa com esse arquivo de binary log. Este método é eficiente e só leva um tempo significativo se a replica estiver muito atrasada em relação ao source por um grande número de arquivos de binary log. O source então lê as transações naquele arquivo de binary log e nos arquivos subsequentes até o atual, enviando as transações com GTIDs que estão faltando na replica, e ignorando as transações que estavam no set de GTIDs enviado pela replica. O tempo decorrido até que a replica receba a primeira transação ausente depende do seu offset no arquivo de binary log. Esta troca garante que o source envie apenas as transações com um GTID que a replica ainda não recebeu ou cometeu. Se a replica receber transações de mais de um source, como no caso de uma topologia de diamante, a função de ignorar automaticamente (auto-skip) garante que as transações não sejam aplicadas duas vezes.

Se qualquer uma das transações que deveriam ser enviadas pelo source tiver sido removida (purged) do binary log do source, ou adicionada ao set de GTIDs na variável de sistema [`gtid_purged`](replication-options-gtids.html#sysvar_gtid_purged) por outro método, o source envia o erro [`ER_MASTER_HAS_PURGED_REQUIRED_GTIDS`](/doc/mysql-errors/5.7/en/server-error-reference.html#error_er_master_has_purged_required_gtids) para a replica, e a replicação não é iniciada. Os GTIDs das transações removidas ausentes são identificados e listados no log de erros do source na mensagem de aviso [`ER_FOUND_MISSING_GTIDS`](/doc/mysql-errors/5.7/en/server-error-reference.html#error_er_found_missing_gtids). A replica não pode se recuperar automaticamente deste erro porque partes do histórico de transações necessárias para alcançar o source foram removidas. Tentar reconectar sem a opção `MASTER_AUTO_POSITION` habilitada resultará apenas na perda das transações removidas na replica. A abordagem correta para se recuperar desta situação é fazer com que a replica replique as transações ausentes listadas na mensagem [`ER_FOUND_MISSING_GTIDS`](/doc/mysql-errors/5.7/en/server-error-reference.html#error_er_found_missing_gtids) de outro source, ou fazer com que a replica seja substituída por uma nova replica criada a partir de um backup mais recente. Considere revisar o período de expiração do binary log no source para garantir que a situação não ocorra novamente.

Se durante a troca de transações for descoberto que a replica recebeu ou cometeu transações com o UUID do source no GTID, mas o próprio source não tem um registro delas, o source envia o erro [`ER_SLAVE_HAS_MORE_GTIDS_THAN_MASTER`](/doc/mysql-errors/5.7/en/server-error-reference.html#error_er_slave_has_more_gtids_than_master) para a replica e a replicação não é iniciada. Esta situação pode ocorrer se um source que não tem [`sync_binlog=1`](replication-options-binary-log.html#sysvar_sync_binlog) definido sofrer uma falha de energia ou falha do sistema operacional, e perder transações committed que ainda não foram sincronizadas com o arquivo de binary log, mas foram recebidas pela replica. O source e a replica podem divergir se quaisquer clientes commitarem transações no source após ele ser reiniciado, o que pode levar à situação em que o source e a replica estão usando o mesmo GTID para transações diferentes. A abordagem correta para se recuperar desta situação é verificar manualmente se o source e a replica divergiram. Se o mesmo GTID estiver agora em uso para transações diferentes, você precisa realizar a resolução manual de conflitos para transações individuais conforme necessário, ou remover o source ou a replica da topologia de replicação. Se o problema for apenas a falta de transações no source, você pode transformar o source em uma replica, permitir que ele alcance os outros servidores na topologia de replicação e, em seguida, transformá-lo em um source novamente, se necessário.