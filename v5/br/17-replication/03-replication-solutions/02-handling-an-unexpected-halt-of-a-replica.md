### 16.3.2 Tratamento de um Parada Inesperada de uma Replicação

Para que a replicação seja resiliente a interrupções inesperadas do servidor (às vezes descrita como segura em caso de falha), é necessário que a replica possa recuperar seu estado antes de ser interrompida. Esta seção descreve o impacto de uma interrupção inesperada de uma replica durante a replicação e como configurar uma replica para ter a melhor chance de recuperação e continuar a replicação.

Após uma parada inesperada de uma replica, ao reiniciar, o thread de replicação SQL deve recuperar informações sobre quais transações já foram executadas. As informações necessárias para a recuperação são armazenadas no repositório de metadados do aplicador da replica. Em versões mais antigas do MySQL Server, esse repositório só poderia ser criado como um arquivo no diretório de dados que foi atualizado após a transação ter sido aplicada. No MySQL 5.7, você pode, em vez disso, usar uma tabela `[InnoDB]` (innodb-storage-engine.html) chamada `mysql.slave_relay_log_info` para armazenar o repositório de metadados do aplicador. Como uma tabela, as atualizações no repositório de metadados do aplicador são comprometidas junto com as transações, o que significa que as informações de progresso da replica registradas nesse repositório estão sempre consistentes com o que foi aplicado ao banco de dados, mesmo em caso de uma parada inesperada do servidor. Para configurar o MySQL 5.7 para armazenar o repositório de metadados do aplicador como uma tabela `[InnoDB]` (innodb-storage-engine.html), defina a variável de sistema `[relay_log_info_repository]` (replication-options-replica.html#sysvar_relay_log_info_repository) para `TABLE`. Para mais informações sobre o repositório de metadados do aplicador, consulte Seção 16.2.4, “Repositórios de Log de Relay e Metadados de Replicação”.

O processo de recuperação pelo qual uma replica se recupera de uma parada inesperada varia dependendo da configuração da replica. Os detalhes do processo de recuperação são influenciados pelo método de replicação escolhido, se a replica é monofila ou multifila, e pelo ajuste de variáveis de sistema relevantes. O objetivo geral do processo de recuperação é identificar quais transações já haviam sido aplicadas no banco de dados da replica antes da parada inesperada ocorrer e recuperar e aplicar as transações que a replica perdeu após a parada inesperada.

- Para a replicação baseada em GTID, o processo de recuperação precisa dos GTIDs das transações que já foram recebidas ou comprometidas pela replica. As transações ausentes podem ser recuperadas da fonte usando o autoposicionamento de GTID, que compara automaticamente as transações da fonte com as transações da replica e identifica as transações ausentes.

- Para a replicação baseada na posição do arquivo, o processo de recuperação precisa de um fio de replicação SQL preciso (aplicador) que mostre a última transação aplicada na réplica. Com base nessa posição, o fio de I/O de replicação (receptor) recupera do log binário da fonte todas as transações que devem ser aplicadas na réplica a partir desse ponto.

A replicação baseada no GTID facilita a configuração da replicação para ser resiliente a interrupções inesperadas. A autoposição do GTID significa que a replica pode identificar e recuperar transações ausentes de forma confiável, mesmo que haja lacunas na sequência de transações aplicadas.

As informações a seguir fornecem combinações de configurações apropriadas para diferentes tipos de réplica, garantindo a recuperação na medida do possível, desde que isso esteja sob o controle da replicação.

Importante

Alguns fatores fora do controle da replicação podem afetar o processo de recuperação da replicação e o estado geral da replicação após o processo de recuperação. Em particular, as configurações que influenciam o processo de recuperação para os motores de armazenamento individuais podem resultar na perda de transações no caso de uma parada inesperada de uma replica, tornando-as indisponíveis para o processo de recuperação da replicação. A configuração `innodb_flush_log_at_trx_commit=1`, mencionada na lista abaixo, é uma configuração chave para uma configuração de replicação que usa `InnoDB` com transações. No entanto, outras configurações específicas de `InnoDB` ou para outros motores de armazenamento, especialmente aquelas relacionadas ao esvaziamento ou sincronização, também podem ter um impacto. Sempre verifique e aplique as recomendações feitas pelos motores de armazenamento escolhidos sobre configurações seguras em caso de falha.

A combinação de configurações a seguir em uma réplica é a mais resistente a interrupções inesperadas:

- Quando a replicação baseada em GTID está em uso (`gtid_mode=ON`), defina `MASTER_AUTO_POSITION=1`, o que ativa a autoposição de GTID para a conexão com a fonte para identificar e recuperar automaticamente as transações ausentes. Esta opção é definida usando uma declaração `ALTERAR MASTER PARA. Se a replica tiver vários canais de replicação, você precisa definir esta opção individualmente para cada canal. Para obter detalhes sobre como a autoposição de GTID funciona, consulte Seção 16.1.3.3, “Autoposição de GTID”. Quando a replicação baseada na posição de arquivo está em uso, `MASTER_AUTO_POSITION=1\` não é usado, e, em vez disso, a posição do log binário ou a posição do log de retransmissão é usada para controlar onde a replicação começa.

- Defina `sync_relay_log=1`, que instrui a thread de I/O de replicação a sincronizar o log de relevo com o disco após cada transação recebida ser escrita nele. Isso significa que o registro da replica da posição atual lida no log binário da fonte (no repositório de metadados da fonte) nunca fica à frente do registro das transações salvas no log de relevo. Observe que, embora essa configuração seja a mais segura, também é a mais lenta devido ao número de escritas no disco envolvidas. Com `sync_relay_log > 1`, ou `sync_relay_log=0` (onde a sincronização é gerenciada pelo sistema operacional), no caso de uma parada inesperada de uma replica, pode haver transações comprometidas que não foram sincronizadas com o disco. Tais transações podem fazer com que o processo de recuperação falhe se a replica em recuperação, com base nas informações que ela tem no log de relevo na última sincronização com o disco, tentar recuperar e aplicar as transações novamente em vez de ignorá-las. Definir `sync_relay_log=1` é particularmente importante para uma replica multi-threaded, onde o processo de recuperação falha se as lacunas na sequência de transações não puderem ser preenchidas usando as informações no log de relevo. Para uma replica single-threaded, o processo de recuperação só precisa usar o log de relevo se as informações relevantes não estiverem disponíveis no repositório de metadados do aplicável.

- Defina `innodb_flush_log_at_trx_commit=1`, que sincroniza os logs do `InnoDB` com o disco antes de cada transação ser confirmada. Esta configuração, que é a padrão, garante que as tabelas do `InnoDB` e os logs do `InnoDB` sejam salvos no disco, para que não haja mais a necessidade de informações no log de retransmissão em relação à transação. Combinada com a configuração `sync_relay_log=1`, esta configuração garante ainda que o conteúdo das tabelas do `InnoDB` e dos logs do `InnoDB` seja consistente com o conteúdo do log de retransmissão em todos os momentos, para que a purga dos arquivos do log de retransmissão não cause lacunas não preenchíveis no histórico de transações da replica em caso de uma parada inesperada.

- Defina `relay_log_info_repository = TABLE`, que armazena a posição do fio de SQL de replicação na tabela `mysql.slave_relay_log_info` do banco de dados `InnoDB` (`innodb-storage-engine.html`), e a atualiza junto com o commit da transação para garantir um registro sempre preciso. Esta configuração *não* é a padrão no MySQL 5.7. Se o ajuste padrão `FILE` for usado, as informações são armazenadas em um arquivo no diretório de dados que é atualizado após a transação ter sido aplicada. Isso cria um risco de perda de sincronia com a fonte, dependendo da etapa de processamento em que a replica se detém, ou até mesmo da corrupção do próprio arquivo. Com a configuração `relay_log_info_repository = FILE`, a recuperação não é garantida.

- Defina [`relay_log_recovery = ON`](https://replication-options-replica.html#sysvar_relay_log_recovery), que habilita a recuperação automática do log de retransmissão imediatamente após a inicialização do servidor. Esta variável global tem o valor padrão `OFF` e é somente de leitura durante a execução, mas você pode defini-la como `ON` com a opção [`--relay-log-recovery`](https://replication-options-replica.html#sysvar_relay_log_recovery) na inicialização da replica após uma parada inesperada de uma replica. Observe que essa configuração ignora os arquivos de log de retransmissão existentes, caso estejam corrompidos ou inconsistentes. O processo de recuperação do log de retransmissão inicia um novo arquivo de log de retransmissão e recupera as transações da fonte, começando na posição do fio SQL de replicação registrada no repositório de metadados do aplicável. Os arquivos de log de retransmissão anteriores são removidos ao longo do tempo pelo mecanismo de purga normal da replica.

Para uma replica multisserial, a partir do MySQL 5.7.13, definir `relay_log_recovery = ON` automaticamente lida com quaisquer inconsistências e lacunas na sequência de transações executadas a partir do log de retransmissão. Essas lacunas podem ocorrer quando a replicação baseada em posição de arquivo está em uso. (Para mais detalhes, consulte Seção 16.4.1.32, “Inconsistências de Transações e Replicação”.) O processo de recuperação do log de retransmissão lida com as lacunas usando o mesmo método que a instrução `START SLAVE UNTIL SQL_AFTER_MTS_GAPS` faria. Quando a replica atinge um estado consistente sem lacunas, o processo de recuperação do log de retransmissão continua a buscar transações adicionais da fonte, começando na posição do fio de SQL de retransmissão. Em versões do MySQL anteriores ao MySQL 5.7.13, esse processo não era automático e exigia iniciar o servidor com `relay_log_recovery = OFF`, iniciar a replica com `START SLAVE UNTIL SQL_AFTER_MTS_GAPS` para corrigir quaisquer inconsistências de transações, e depois reiniciar a replica com `relay_log_recovery = ON`. Quando a replicação baseada em GTID está em uso, a partir do MySQL 5.7.28, uma replica multisserial verifica primeiro se `MASTER_AUTO_POSITION` está definido como `ON`, e se estiver, omite o passo de calcular as transações que devem ser ignoradas ou não ignoradas, para que os antigos logs de retransmissão não sejam necessários para o processo de recuperação.
