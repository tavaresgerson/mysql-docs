### 16.3.7 Trocando Sources Durante um Failover

Você pode instruir uma Replica a mudar para um novo Source usando a instrução [`CHANGE MASTER TO`](change-master-to.html "13.4.2.1 CHANGE MASTER TO Statement"). A Replica não verifica se os Databases no Source são compatíveis com aqueles na Replica; ela simplesmente começa a ler e executar eventos das coordenadas especificadas no Binary Log do novo Source. Em uma situação de Failover, todos os servidores no grupo estão tipicamente executando os mesmos eventos do mesmo arquivo de Binary Log, então mudar o Source dos eventos não deve afetar a estrutura ou integridade do Database, desde que você tome cuidado ao fazer a mudança.

Replicas devem ser executadas com o Binary Logging habilitado (a opção [`--log-bin`](replication-options-binary-log.html#option_mysqld_log-bin)), que é o padrão. Se você não estiver usando GTIDs para a Replication, as Replicas também devem ser executadas com [`--log-slave-updates=OFF`](replication-options-binary-log.html#sysvar_log_slave_updates) (o log de atualizações da Replica é o padrão). Dessa forma, a Replica está pronta para se tornar um Source sem reiniciar o [**mysqld**](mysqld.html "4.3.1 mysqld — The MySQL Server") da Replica. Assuma que você tem a estrutura mostrada na [Figure 16.4, “Redundância Usando Replication, Estrutura Inicial”](replication-solutions-switch.html#figure_replication-redundancy-before "Figure 16.4 Redundância Usando Replication, Estrutura Inicial").

**Figure 16.4 Redundância Usando Replication, Estrutura Inicial**

![Dois Web Clients direcionam leituras e escritas de Database para um único Source server MySQL. O Source server MySQL replica para Replica 1, Replica 2 e Replica 3.](images/redundancy-before.png)

Neste diagrama, o `Source` detém o Database Source, os hosts `Replica*` são Replicas, e as máquinas `Web Client` estão emitindo leituras e escritas no Database. Web Clients que emitem apenas leituras (e que normalmente estariam conectados às Replicas) não são mostrados, pois não precisam mudar para um novo servidor em caso de falha. Para um exemplo mais detalhado de uma estrutura de Replication de Scale-Out de leitura/escrita, consulte a [Seção 16.3.4, “Usando Replication para Scale-Out”](replication-solutions-scaleout.html "16.3.4 Usando Replication para Scale-Out").

Cada Replica MySQL (`Replica 1`, `Replica 2`, e `Replica 3`) é uma Replica rodando com Binary Logging habilitado, e com [`--log-slave-updates=OFF`](replication-options-binary-log.html#sysvar_log_slave_updates). Como as atualizações recebidas por uma Replica do Source não são escritas no Binary Log quando [`--log-slave-updates=OFF`](replication-options-binary-log.html#sysvar_log_slave_updates) é especificado, o Binary Log em cada Replica está inicialmente vazio. Se por alguma razão o `Source` se tornar indisponível, você pode escolher uma das Replicas para se tornar o novo Source. Por exemplo, se você escolher a `Replica 1`, todos os `Web Clients` devem ser redirecionados para a `Replica 1`, que escreve as atualizações em seu Binary Log. A `Replica 2` e a `Replica 3` devem então replicar a partir da `Replica 1`.

O motivo para executar a Replica com [`--log-slave-updates=OFF`](replication-options-binary-log.html#sysvar_log_slave_updates) é impedir que as Replicas recebam atualizações duas vezes, caso você faça com que uma das Replicas se torne o novo Source. Se a `Replica 1` tiver [`--log-slave-updates`](replication-options-binary-log.html#sysvar_log_slave_updates) habilitado, que é o padrão, ela escreve qualquer atualização que receber do `Source` em seu próprio Binary Log. Isso significa que, quando a `Replica 2` muda do `Source` para a `Replica 1` como seu Source, ela pode receber atualizações da `Replica 1` que já recebeu do `Source`.

Certifique-se de que todas as Replicas processaram quaisquer instruções em seu Relay Log. Em cada Replica, execute `STOP SLAVE IO_THREAD`, depois verifique a saída de [`SHOW PROCESSLIST`](show-processlist.html "13.7.5.29 SHOW PROCESSLIST Statement") até ver `Has read all relay log`. Quando isso for verdadeiro para todas as Replicas, elas podem ser reconfiguradas para a nova configuração. Na Replica `Replica 1` que está sendo promovida para se tornar o Source, execute [`STOP SLAVE`](stop-slave.html "13.4.2.6 STOP SLAVE Statement") e [`RESET MASTER`](reset-master.html "13.4.1.2 RESET MASTER Statement").

Nas outras Replicas, `Replica 2` e `Replica 3`, use [`STOP SLAVE`](stop-slave.html "13.4.2.6 STOP SLAVE Statement") e `CHANGE MASTER TO MASTER_HOST='Replica1'` (onde `'Replica1'` representa o nome de host real da `Replica 1`). Para usar `CHANGE MASTER TO`, adicione todas as informações sobre como conectar-se à `Replica 1` a partir da `Replica 2` ou `Replica 3` (*`user`*, *`password`*, *`port`*). Ao executar a instrução neste cenário, não há necessidade de especificar o nome do arquivo de Binary Log da `Replica 1` ou a posição do Log a ser lida, já que o primeiro arquivo de Binary Log e a posição 4 são os padrões. Finalmente, execute [`START SLAVE`](start-slave.html "13.4.2.5 START SLAVE Statement") na `Replica 2` e `Replica 3`.

Uma vez que a nova configuração de Replication esteja implementada, você precisa instruir cada `Web Client` a direcionar suas instruções para a `Replica 1`. A partir desse momento, todas as atualizações enviadas pelo `Web Client` para a `Replica 1` são escritas no Binary Log da `Replica 1`, que então contém todas as atualizações enviadas para a `Replica 1` desde que o `Source` se tornou indisponível.

A estrutura de servidor resultante é mostrada na [Figure 16.5, “Redundância Usando Replication, Após Falha do Source”](replication-solutions-switch.html#figure_replication-redundancy-after "Figure 16.5 Redundância Usando Replication, Após Falha do Source").

**Figure 16.5 Redundância Usando Replication, Após Falha do Source**

![O Source server MySQL falhou e não está mais conectado à topologia de Replication. Os dois Web Clients agora direcionam leituras e escritas de Database para a Replica 1, que é o novo Source. A Replica 1 replica para a Replica 2 e a Replica 3.](images/redundancy-after.png)

Quando o `Source` estiver disponível novamente, você deve torná-lo uma Replica da `Replica 1`. Para fazer isso, execute no `Source` a mesma instrução [`CHANGE MASTER TO`](change-master-to.html "13.4.2.1 CHANGE MASTER TO Statement") que foi executada anteriormente na `Replica 2` e `Replica 3`. O `Source` então se torna uma Replica da `Replica 1` e recebe as escritas do `Web Client` que perdeu enquanto estava offline.

Para tornar o `Source` novamente um Source, use o procedimento anterior como se a `Replica 1` estivesse indisponível e o `Source` fosse o novo Source. Durante este procedimento, não se esqueça de executar [`RESET MASTER`](reset-master.html "13.4.1.2 RESET MASTER Statement") no `Source` antes de fazer da `Replica 1`, `Replica 2` e `Replica 3` Replicas do `Source`. Se você não fizer isso, as Replicas podem receber escritas obsoletas das aplicações `Web Client` datadas de antes do ponto em que o `Source` se tornou indisponível.

Você deve estar ciente de que não há sincronização entre Replicas, mesmo quando elas compartilham o mesmo Source, e, portanto, algumas Replicas podem estar consideravelmente à frente de outras. Isso significa que, em alguns casos, o procedimento descrito no exemplo anterior pode não funcionar conforme o esperado. Na prática, no entanto, os Relay Logs em todas as Replicas devem estar relativamente próximos.

Uma maneira de manter as aplicações informadas sobre a localização do Source é ter uma entrada DNS dinâmica para o host Source. Com o `BIND`, você pode usar o **nsupdate** para atualizar o DNS dinamicamente.