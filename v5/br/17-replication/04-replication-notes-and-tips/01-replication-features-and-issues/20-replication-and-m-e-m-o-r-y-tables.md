#### 16.4.1.20 Replicação e Tabelas MEMORY

Quando um servidor source (origem) de replicação é desligado e reiniciado, suas tabelas [`MEMORY`](memory-storage-engine.html "15.3 The MEMORY Storage Engine") ficam vazias. Para replicar esse efeito nas replicas, na primeira vez que o source usa uma determinada tabela [`MEMORY`](memory-storage-engine.html "15.3 The MEMORY Storage Engine") após a inicialização, ele registra um evento que notifica as replicas de que a tabela deve ser esvaziada. Isso é feito escrevendo uma instrução [`DELETE`](delete.html "13.2.2 DELETE Statement") ou (a partir do MySQL 5.7.32) [`TRUNCATE TABLE`](truncate-table.html "13.1.34 TRUNCATE TABLE Statement") para essa tabela no binary log. Este evento gerado é identificável por um comentário no binary log e, se GTIDs estiverem em uso no servidor, ele terá um GTID atribuído. A instrução é sempre registrada no formato statement, mesmo que o formato de binary logging esteja definido como `ROW`, e é escrita mesmo que o modo `read_only` ou `super_read_only` esteja definido no servidor. Observe que a replica ainda terá dados desatualizados em uma tabela [`MEMORY`](memory-storage-engine.html "15.3 The MEMORY Storage Engine") durante o intervalo entre a reinicialização do source e seu primeiro uso da tabela. Para evitar esse intervalo, onde uma Query direta para a replica poderia retornar dados obsoletos (stale data), você pode definir a variável de sistema [`init_file`](server-system-variables.html#sysvar_init_file) para nomear um arquivo contendo instruções que populam a tabela `MEMORY` no source durante a inicialização.

Quando um servidor replica é desligado e reiniciado, suas tabelas [`MEMORY`](memory-storage-engine.html "15.3 The MEMORY Storage Engine") ficam vazias. Isso faz com que a replica fique fora de sincronia com o source e pode levar a outras falhas ou fazer com que a replica pare:

*   Updates e deletes em formato Row recebidos do source podem falhar com `Can't find record in 'memory_table'`.
*   Instruções como [`INSERT INTO ... SELECT FROM memory_table`](insert-select.html "13.2.5.1 INSERT ... SELECT Statement") podem inserir um conjunto diferente de linhas no source e na replica.

A replica também grava uma instrução [`DELETE`](delete.html "13.2.2 DELETE Statement") ou (a partir do MySQL 5.7.32) [`TRUNCATE TABLE`](truncate-table.html "13.1.34 TRUNCATE TABLE Statement") em seu próprio binary log, que é transmitida para quaisquer replicas downstream, fazendo com que elas esvaziem suas próprias tabelas [`MEMORY`](memory-storage-engine.html "15.3 The MEMORY Storage Engine").

A maneira segura de reiniciar uma replica que está replicando tabelas [`MEMORY`](memory-storage-engine.html "15.3 The MEMORY Storage Engine") é primeiro descartar (drop) ou deletar todas as linhas das tabelas [`MEMORY`](memory-storage-engine.html "15.3 The MEMORY Storage Engine") no source e esperar até que essas alterações tenham sido replicadas para a replica. Então, é seguro reiniciar a replica.

Um método de reinicialização alternativo pode ser aplicado em alguns casos. Quando [`binlog_format=ROW`](replication-options-binary-log.html#sysvar_binlog_format), você pode impedir que a replica pare se você definir [`slave_exec_mode=IDEMPOTENT`](replication-options-replica.html#sysvar_slave_exec_mode) antes de iniciar a replica novamente. Isso permite que a replica continue a replicar, mas suas tabelas [`MEMORY`](memory-storage-engine.html "15.3 The MEMORY Storage Engine") ainda diferirão das do source. Isso é aceitável se a lógica da aplicação permitir que o conteúdo das tabelas [`MEMORY`](memory-storage-engine.html "15.3 The MEMORY Storage Engine") seja perdido com segurança (por exemplo, se as tabelas [`MEMORY`](memory-storage-engine.html "15.3 The MEMORY Storage Engine") forem usadas para caching). [`slave_exec_mode=IDEMPOTENT`](replication-options-replica.html#sysvar_slave_exec_mode) se aplica globalmente a todas as tabelas, então pode ocultar outros erros de replicação em tabelas que não são [`MEMORY`](memory-storage-engine.html "15.3 The MEMORY Storage Engine").

(O método que acabamos de descrever não é aplicável no NDB Cluster, onde [`slave_exec_mode`](replication-options-replica.html#sysvar_slave_exec_mode) é sempre `IDEMPOTENT` e não pode ser alterado.)

O tamanho das tabelas [`MEMORY`](memory-storage-engine.html "15.3 The MEMORY Storage Engine") é limitado pelo valor da variável de sistema [`max_heap_table_size`](server-system-variables.html#sysvar_max_heap_table_size), que não é replicada (consulte [Section 16.4.1.37, “Replication and Variables”](replication-features-variables.html "16.4.1.37 Replication and Variables")). Uma alteração em `max_heap_table_size` entra em vigor para tabelas `MEMORY` que são criadas ou atualizadas usando [`ALTER TABLE ... ENGINE = MEMORY`](alter-table.html "13.1.8 ALTER TABLE Statement") ou [`TRUNCATE TABLE`](truncate-table.html "13.1.34 TRUNCATE TABLE Statement") após a alteração, ou para todas as tabelas [`MEMORY`](memory-storage-engine.html "15.3 The MEMORY Storage Engine") após a reinicialização do servidor. Se você aumentar o valor desta variável no source sem fazer o mesmo na replica, torna-se possível que uma tabela no source cresça mais do que sua contraparte na replica, levando a inserts que são bem-sucedidos no source, mas falham na replica com erros de `Table is full`. Este é um problema conhecido (Bug #48666). Nesses casos, você deve definir o valor global de [`max_heap_table_size`](server-system-variables.html#sysvar_max_heap_table_size) na replica, bem como no source, e depois reiniciar a replicação. Também é recomendado que você reinicie os servidores MySQL do source e da replica, para garantir que o novo valor tenha efeito completo (global) em cada um deles.

Consulte [Section 15.3, “The MEMORY Storage Engine”](memory-storage-engine.html "15.3 The MEMORY Storage Engine"), para obter mais informações sobre tabelas [`MEMORY`](memory-storage-engine.html "15.3 The MEMORY Storage Engine").