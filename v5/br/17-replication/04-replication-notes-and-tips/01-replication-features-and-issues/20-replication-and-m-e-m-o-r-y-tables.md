#### 16.4.1.20 Replicação e tabelas de MEMORY

Quando um servidor de origem de replicação é desligado e reiniciado, suas tabelas de `MEMORY` ficam vazias. Para replicar esse efeito nas réplicas, na primeira vez que a fonte usar uma determinada tabela de `MEMORY` após a inicialização, ela registra um evento que notifica as réplicas de que a tabela deve ser esvaziada escrevendo uma declaração de `DELETE` ou (a partir do MySQL 5.7.32) `TRUNCATE TABLE` para essa tabela no log binário. Esse evento gerado é identificável por um comentário no log binário, e, se GTIDs estiverem em uso no servidor, ele recebe um GTID atribuído. A declaração é sempre registrada no formato de declaração, mesmo que o formato de registro binário esteja configurado como `ROW`, e é escrita mesmo que o modo `read_only` ou `super_read_only` esteja configurado no servidor. Observe que a réplica ainda tem dados desatualizados em uma tabela de `MEMORY` durante o intervalo entre o reinício da fonte e seu primeiro uso da tabela. Para evitar esse intervalo quando uma consulta direta à réplica poderia retornar dados desatualizados, você pode configurar a variável de sistema `init_file` para nomear um arquivo que contenha declarações que preenchem a tabela `MEMORY` na fonte durante a inicialização.

Quando um servidor replicador é desligado e reiniciado, suas tabelas de `MEMORY` ficam vazias. Isso faz com que o replicador fique fora de sincronia com a fonte e pode levar a outros falhas ou fazer com que o replicador pare:

- As atualizações e exclusões em formato de linha recebidas da fonte podem falhar com a mensagem `Não foi possível encontrar o registro na 'memory_table'`.

- Declarações como `INSERT INTO ... SELECT FROM memory_table` podem inserir um conjunto diferente de linhas na fonte e na replica.

A replica também escreve uma declaração `DELETE` ou (a partir do MySQL 5.7.32) `TRUNCATE TABLE` em seu próprio log binário, que é passado para quaisquer réplicas subsequentes, fazendo com que elas limpem suas próprias tabelas de `MEMORY`.

A maneira segura de reiniciar uma réplica que está replicando as tabelas de `MEMORY` é primeiro excluir ou excluir todas as linhas das tabelas de `MEMORY` na fonte e esperar até que essas alterações tenham sido replicadas para a réplica. Em seguida, é seguro reiniciar a réplica.

Em alguns casos, pode ser aplicado um método alternativo de reinício. Quando [`binlog_format=ROW`](https://pt.wikipedia.org/wiki/Binlog), você pode impedir que a réplica seja parada se definir [`slave_exec_mode=IDEMPOTENT`](https://pt.wikipedia.org/wiki/R%C3%A9plica_de_replic%C3%A3o) antes de reiniciar a réplica. Isso permite que a réplica continue a replicar, mas suas tabelas de [`MEMORY`](https://pt.wikipedia.org/wiki/Mem%C3%B3ria_de_armazenamento) ainda diferem das do(a) origem. Isso é aceitável se a lógica da aplicação for tal que o conteúdo das tabelas de [`MEMORY`](https://pt.wikipedia.org/wiki/Mem%C3%B3ria_de_armazenamento) possa ser perdido com segurança (por exemplo, se as tabelas de [`MEMORY`](https://pt.wikipedia.org/wiki/Mem%C3%B3ria_de_armazenamento) forem usadas para cache). [`slave_exec_mode=IDEMPOTENT`](https://pt.wikipedia.org/wiki/R%C3%A9plica_de_replic%C3%A3o) aplica-se globalmente a todas as tabelas, então pode ocultar outros erros de replicação em tabelas não-[`MEMORY`](https://pt.wikipedia.org/wiki/Mem%C3%B3ria_de_armazenamento).

(O método descrito acima não é aplicável no NDB Cluster, onde [`slave_exec_mode`](https://docs.mariadb.org/en/stable/replication-options-replica.html#sysvar_slave_exec_mode) é sempre `IDEMPOTENT` e não pode ser alterado.)

O tamanho das tabelas de `MEMORY` é limitado pelo valor da variável de sistema `max_heap_table_size`, que não é replicada (veja Seção 16.4.1.37, “Replicação e Variáveis”). Uma mudança no `max_heap_table_size` entra em vigor para as tabelas de `MEMORY` que são criadas ou atualizadas usando `ALTER TABLE ... ENGINE = MEMORY` ou `TRUNCATE TABLE` após a mudança, ou para todas as tabelas de `MEMORY` após o reinício do servidor. Se você aumentar o valor dessa variável na fonte sem fazer isso na replica, torna-se possível que uma tabela na fonte cresça mais do que sua contraparte na replica, levando a inserções que têm sucesso na fonte, mas falham na replica com erros de Table is full. Esse é um problema conhecido (Bug #48666). Nesses casos, você deve definir o valor global de `max_heap_table_size` na replica, assim como na fonte, e, em seguida, reiniciar a replicação. Também é recomendável que você reinicie os servidores MySQL da fonte e da replica, para garantir que o novo valor tenha efeito completo (global) em cada um deles.

Consulte a Seção 15.3, “O Motor de Armazenamento de MEMORY” para obter mais informações sobre as tabelas de `MEMORY` (memory-storage-engine.html).
