## A.11 FAQ do MySQL 5.7: Conjuntos de Caracteres Chineses, Japoneses e Coreanos no MySQL

Este conjunto de Perguntas Frequentes deriva da experiência dos grupos de Suporte e Desenvolvimento do MySQL ao lidar com muitas consultas sobre questões CJK (Chinês-Japonês-Coreano).

A.11.1. [Quais conjuntos de caracteres CJK estão disponíveis no MySQL?](faqs-cjk.html#faq-cjk-what-cjk-avail)

A.11.2. [Eu inseri caracteres CJK na minha tabela. Por que o SELECT os exibe como caracteres “?”?](faqs-cjk.html#faq-cjk-why-cjk-question-marks)

A.11.3. [Quais problemas devo estar ciente ao trabalhar com o conjunto de caracteres Big5 Chinês?](faqs-cjk.html#faq-cjk-what-problems-big5)

A.11.4. [Por que as conversões de conjuntos de caracteres japoneses falham?](faqs-cjk.html#faq-cjk-what-japanese-chars-fail)

A.11.5. [O que devo fazer se quiser converter SJIS 81CA para cp932?](faqs-cjk.html#faq-cjk-how-convert-81ca-cp932)

A.11.6. [Como o MySQL representa o sinal de Yen (¥)?](faqs-cjk.html#faq-cjk-how-represent-yen)

A.11.7. [De quais problemas devo estar ciente ao trabalhar com conjuntos de caracteres coreanos no MySQL?](faqs-cjk.html#faq-cjk-what-problems-korean)

A.11.8. [Por que eu recebo mensagens de erro Incorrect string value?](faqs-cjk.html#faq-cjk-why-incorrect-string-value)

A.11.9. [Por que minha interface gráfica (GUI) ou meu navegador exibe caracteres CJK incorretamente na minha aplicação usando Access, PHP ou outra API?](faqs-cjk.html#faq-cjk-why-gui-not-display-cjk)

A.11.10. [Eu atualizei para o MySQL 5.7. Como posso reverter para um comportamento semelhante ao do MySQL 4.0 em relação aos conjuntos de caracteres?](faqs-cjk.html#faq-cjk-how-use-4-0-charset)

A.11.11. [Por que algumas buscas LIKE e FULLTEXT com caracteres CJK falham?](faqs-cjk.html#faq-cjk-why-cjk-fail-searches)

A.11.12. [Como eu sei se o caractere X está disponível em todos os conjuntos de caracteres?](faqs-cjk.html#faq-cjk-how-know-avail-characters)

A.11.13. [Por que strings CJK são ordenadas incorretamente em Unicode? (I)](faqs-cjk.html#faq-cjk-how-cjk-sort-unicode-1)

A.11.14. [Por que strings CJK são ordenadas incorretamente em Unicode? (II)](faqs-cjk.html#faq-cjk-how-cjk-sort-unicode-2)

A.11.15. [Por que meus caracteres suplementares são rejeitados pelo MySQL?](faqs-cjk.html#faq-cjk-why-supplement-char-rejected)

A.11.16. [O termo “CJK” deveria ser “CJKV”?](faqs-cjk.html#faq-cjk-why-cjk-not-cjkv)

A.11.17. [O MySQL permite que caracteres CJK sejam usados em nomes de Database e Table?](faqs-cjk.html#faq-cjk-how-cjk-db-table-names)

A.11.18. [Onde posso encontrar traduções do Manual do MySQL para Chinês, Japonês e Coreano?](faqs-cjk.html#faq-cjk-where-doc-translations)

A.11.19. [Onde posso obter ajuda com questões CJK e relacionadas no MySQL?](faqs-cjk.html#faq-cjk-help-with-cjk)

<table border="0" style="width: 100%;"><colgroup><col align="left" width="1%"/><col/></colgroup><tbody><tr class="question"><td align="left" valign="top"><p><b>A.11.1.</b></p></td><td align="left" valign="top"><p> Quais conjuntos de caracteres CJK estão disponíveis no MySQL? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> A lista de conjuntos de caracteres CJK pode variar dependendo da sua versão do MySQL. Por exemplo, o conjunto de caracteres <code>gb18030</code> não é suportado antes do MySQL 5.7.4. No entanto, como o nome do idioma aplicável aparece na coluna <code>DESCRIPTION</code> para cada entrada na tabela <code>INFORMATION_SCHEMA.CHARACTER_SETS</code>, você pode obter uma lista atual de todos os conjuntos de caracteres CJK não-Unicode usando esta Query: </p><pre class="programlisting copytoclipboard language-sql"><code class="language-sql">mysql&gt; SELECT CHARACTER_SET_NAME, DESCRIPTION FROM INFORMATION_SCHEMA.CHARACTER_SETS WHERE DESCRIPTION LIKE '%Chin%' OR DESCRIPTION LIKE '%Japanese%' OR DESCRIPTION LIKE '%Korean%' ORDER BY CHARACTER_SET_NAME; +--------------------+---------------------------------+ | CHARACTER_SET_NAME | DESCRIPTION                     | +--------------------+---------------------------------+ | big5               | Big5 Traditional Chinese        | | cp932              | SJIS for Windows Japanese       | | eucjpms            | UJIS for Windows Japanese       | | euckr              | EUC-KR Korean                   | | gb18030            | China National Standard GB18030 | | gb2312             | GB2312 Simplified Chinese       | | gbk                | GBK Simplified Chinese          | | sjis               | Shift-JIS Japanese              | | ujis               | EUC-JP Japanese                 | +--------------------+---------------------------------+</code></pre><p> (Para mais informações, consulte Seção 24.3.2, “A Tabela INFORMATION_SCHEMA CHARACTER_SETS”.) </p><p> O MySQL suporta três variantes dos conjuntos de caracteres <span class="firstterm">GB</span> (<span class="foreignphrase"><em class="foreignphrase">Guojia Biaozhun</em></span>, ou <span><em>Padrão Nacional</em></span>, ou <span><em>Chinês Simplificado</em></span>) que são oficiais na República Popular da China: <code>gb2312</code>, <code>gbk</code> e (a partir do MySQL 5.7.4) <code>gb18030</code>. </p><p> Às vezes, as pessoas tentam inserir caracteres <code>gbk</code> em <code>gb2312</code>, e funciona na maioria das vezes porque <code>gbk</code> é um superconjunto de <code>gb2312</code>. Mas, eventualmente, elas tentam inserir um caractere chinês mais raro e isso não funciona. (Para um exemplo, consulte Bug #16072). </p><p> Aqui, tentamos esclarecer exatamente quais caracteres são legítimos em <code>gb2312</code> ou <code>gbk</code>, com referência aos documentos oficiais. Por favor, verifique estas referências antes de relatar bugs de <code>gb2312</code> ou <code>gbk</code>: </p> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p> O conjunto de caracteres <code>gbk</code> do MySQL é na verdade <span class="quote">“<span class="quote">Microsoft code page 936</span>”</span>. Isso difere do <code>gbk</code> oficial para os caracteres <code>A1A4</code> (ponto central), <code>A1AA</code> (travessão), <code>A6E0-A6F5</code> e <code>A8BB-A8C0</code>. </p></li><li class="listitem"><p> Para uma listagem dos mapeamentos <code>gbk</code>/Unicode, consulte http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP936.TXT. </p></li></ul> </div> <p> Também é possível armazenar caracteres CJK em conjuntos de caracteres Unicode, embora os Collation disponíveis possam não ordenar os caracteres exatamente como você espera: </p> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p> Os conjuntos de caracteres <code>utf8</code> e <code>ucs2</code> suportam os caracteres do Basic Multilingual Plane (BMP) do Unicode. Estes caracteres têm valores de Code Point entre <code>U+0000</code> e <code>U+FFFF</code>. </p></li><li class="listitem"><p> Os conjuntos de caracteres <code>utf8mb4</code>, <code>utf16</code>, <code>utf16le</code> e <code>utf32</code> suportam caracteres BMP, bem como caracteres suplementares que estão fora do BMP. Caracteres suplementares têm valores de Code Point entre <code>U+10000</code> e <code>U+10FFFF</code>. </p></li></ul> </div> <p> O Collation usado para um conjunto de caracteres Unicode determina a capacidade de ordenar (ou seja, distinguir) caracteres no conjunto: </p> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p> Collation baseados no Unicode Collation Algorithm (UCA) 4.0.0 distinguem apenas caracteres BMP. </p></li><li class="listitem"><p> Collation baseados em UCA 5.2.0 ou 9.0.0 distinguem caracteres BMP e suplementares. </p></li><li class="listitem"><p> Collation não-UCA podem não distinguir todos os caracteres Unicode. Por exemplo, o Collation padrão <code>utf8mb4</code> é <code>utf8mb4_general_ci</code>, que distingue apenas caracteres BMP. </p></li></ul> </div> <p> Além disso, distinguir caracteres não é o mesmo que ordená-los de acordo com as convenções de um determinado idioma CJK. Atualmente, o MySQL tem apenas um Collation UCA específico para CJK, <code>gb18030_unicode_520_ci</code> (que requer o uso do conjunto de caracteres não-Unicode <code>gb18030</code>). </p><p> Para obter informações sobre Collation Unicode e suas propriedades de diferenciação, incluindo propriedades de Collation para caracteres suplementares, consulte Seção 10.10.1, “Conjuntos de Caracteres Unicode”. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.11.2.</b></p></td><td align="left" valign="top"><p> Eu inseri caracteres CJK na minha tabela. Por que o <code>SELECT</code> os exibe como caracteres <span class="quote">“<span class="quote">?</span>”</span>? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> Este problema geralmente se deve a uma configuração no MySQL que não corresponde às configurações do programa de aplicação ou do sistema operacional. Aqui estão algumas etapas comuns para corrigir esses tipos de problemas: </p> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p> <span><em>Tenha certeza de qual versão do MySQL você está usando</em></span>. </p><p> Use a instrução <code>SELECT VERSION();</code> para determinar isso. </p></li><li class="listitem"><p> <span><em>Certifique-se de que o Database esteja realmente usando o conjunto de caracteres desejado</em></span>. </p><p> As pessoas frequentemente pensam que o conjunto de caracteres do cliente é sempre o mesmo que o conjunto de caracteres do servidor ou o conjunto de caracteres usado para fins de exibição. No entanto, ambas são suposições falsas. Você pode ter certeza verificando o resultado de <code>SHOW CREATE TABLE <em><code>tablename</code></em></code> ou, melhor ainda, usando esta instrução: </p><pre class="programlisting copytoclipboard language-sql"><code class="language-sql">SELECT character_set_name, collation_name FROM information_schema.columns WHERE table_schema = your_database_name AND table_name = your_table_name AND column_name = your_column_name;</code></pre></li><li class="listitem"><p> <span><em>Determine o valor hexadecimal do caractere ou caracteres que não estão sendo exibidos corretamente</em></span>. </p><p> Você pode obter esta informação para uma coluna <em><code>column_name</code></em> na tabela <em><code>table_name</code></em> usando a seguinte Query: </p><pre class="programlisting copytoclipboard language-sql"><code class="language-sql">SELECT HEX(<em>column_name</em>) FROM <em>table_name</em>;</code></pre><p> <code>3F</code> é a codificação para o caractere <code>?</code>; isso significa que <code>?</code> é o caractere realmente armazenado na coluna. Isso acontece mais frequentemente devido a um problema na conversão de um caractere específico do seu conjunto de caracteres do cliente para o conjunto de caracteres de destino. </p></li><li class="listitem"><p> <span><em>Certifique-se de que uma viagem de ida e volta (round trip) seja possível. Quando você seleciona <em><code>literal</code></em> (ou <em><code>_introducer valor-hexadecimal</code></em>), você obtém <em><code>literal</code></em> como resultado</em></span>? </p><p> Por exemplo, o caractere Katakana japonês <span class="foreignphrase"><em class="foreignphrase">Pe</em></span> (<code>ペ'</code>) existe em todos os conjuntos de caracteres CJK e tem o valor do Code Point (codificação hexadecimal) <code>0x30da</code>. Para testar uma viagem de ida e volta para este caractere, use esta Query: </p><pre class="programlisting copytoclipboard language-sql one-line"><code class="language-sql">SELECT 'ペ' AS `ペ`;         /* ou SELECT _ucs2 0x30da; */</code></pre><p> Se o resultado não for também <code>ペ</code>, a viagem de ida e volta falhou. </p><p> Para relatórios de bugs sobre tais falhas, podemos pedir que você acompanhe com <code>SELECT HEX('ペ');</code>. Então podemos determinar se a codificação do cliente está correta. </p></li><li class="listitem"><p> <span><em>Certifique-se de que o problema não seja com o navegador ou outra aplicação, e sim com o MySQL</em></span>. </p><p> Use o programa cliente <span><strong>mysql</strong></span> para realizar esta tarefa. Se <span><strong>mysql</strong></span> exibir os caracteres corretamente, mas sua aplicação não, seu problema provavelmente se deve às configurações do sistema. </p><p> Para determinar suas configurações, use a instrução <code>SHOW VARIABLES</code>, cuja saída deve se assemelhar ao que é mostrado aqui: </p><pre class="programlisting copytoclipboard language-sql"><code class="language-sql">mysql&gt; SHOW VARIABLES LIKE 'char%'; +--------------------------+----------------------------------------+ | Variable_name            | Value                                  | +--------------------------+----------------------------------------+ | character_set_client     | utf8                                   | | character_set_connection | utf8                                   | | character_set_database   | latin1                                 | | character_set_filesystem | binary                                 | | character_set_results    | utf8                                   | | character_set_server     | latin1                                 | | character_set_system     | utf8                                   | | character_sets_dir       | /usr/local/mysql/share/mysql/charsets/ | +--------------------------+----------------------------------------+</code></pre><p> Estas são configurações típicas de conjunto de caracteres para um cliente orientado internacionalmente (observe o uso de <code>utf8</code> Unicode) conectado a um servidor no Ocidente (<code>latin1</code> é um conjunto de caracteres da Europa Ocidental). </p><p> Embora o Unicode (geralmente a variante <code>utf8</code> no Unix, e a variante <code>ucs2</code> no Windows) seja preferível ao Latin, muitas vezes não é o que os utilitários do seu sistema operacional melhor suportam. Muitos usuários do Windows acham que um conjunto de caracteres da Microsoft, como <code>cp932</code> para Windows japonês, é adequado. </p><p> Se você não pode controlar as configurações do servidor, e não tem ideia de qual configuração seu computador subjacente usa, tente mudar para um conjunto de caracteres comum para o país em que você está (<code>euckr</code> = Coreia; <code>gb18030</code>, <code>gb2312</code> ou <code>gbk</code> = República Popular da China; <code>big5</code> = Taiwan; <code>sjis</code>, <code>ujis</code>, <code>cp932</code> ou <code>eucjpms</code> = Japão; <code>ucs2</code> ou <code>utf8</code> = em qualquer lugar). Geralmente, é necessário alterar apenas as configurações de cliente, conexão e resultados. A instrução <code>SET NAMES</code> altera todas as três de uma vez. Por exemplo: </p><pre class="programlisting copytoclipboard language-sql one-line"><code class="language-sql">SET NAMES 'big5';</code></pre><p> Assim que a configuração estiver correta, você pode torná-la permanente editando <code>my.cnf</code> ou <code>my.ini</code>. Por exemplo, você pode adicionar linhas parecidas com estas: </p><pre class="programlisting copytoclipboard language-ini"><code class="language-ini">[mysqld] character-set-server=big5 [client] default-character-set=big5</code></pre><p> Também é possível que existam problemas com a configuração da API que está sendo usada em sua aplicação; consulte <em class="citetitle">Por que minha interface gráfica (GUI) ou meu navegador não exibe caracteres CJK corretamente...?</em> para mais informações. </p></li></ul> </div> </td></tr><tr class="question"><td align="left" valign="top"><p><b>A.11.3.</b></p></td><td align="left" valign="top"><p> Quais problemas devo estar ciente ao trabalhar com o conjunto de caracteres Big5 Chinês? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> O MySQL suporta o conjunto de caracteres Big5 que é comum em Hong Kong e Taiwan (República da China). O conjunto de caracteres <code>big5</code> do MySQL é na verdade o Microsoft code page 950, que é muito semelhante ao conjunto de caracteres <code>big5</code> original. </p><p> Uma solicitação de recurso para adicionar extensões <code>HKSCS</code> foi registrada. Pessoas que precisam desta extensão podem achar o patch sugerido para o Bug #13577 de interesse. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.11.4.</b></p></td><td align="left" valign="top"><p> Por que as conversões de conjuntos de caracteres japoneses falham? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> O MySQL suporta os conjuntos de caracteres <code>sjis</code>, <code>ujis</code>, <code>cp932</code> e <code>eucjpms</code>, bem como Unicode. Uma necessidade comum é converter entre conjuntos de caracteres. Por exemplo, pode haver um servidor Unix (tipicamente com <code>sjis</code> ou <code>ujis</code>) e um cliente Windows (tipicamente com <code>cp932</code>). </p><p> Na tabela de conversão a seguir, a coluna <code>ucs2</code> representa a origem, e as colunas <code>sjis</code>, <code>cp932</code>, <code>ujis</code> e <code>eucjpms</code> representam os destinos; ou seja, as últimas 4 colunas fornecem o resultado hexadecimal quando usamos <code>CONVERT(ucs2)</code> ou atribuímos um valor de coluna <code>ucs2</code> a uma coluna <code>sjis</code>, <code>cp932</code>, <code>ujis</code> ou <code>eucjpms</code>. </p> <div class="informaltable"> <table summary="Resultado da atribuição de vários caracteres ucs2 a uma coluna que usa o conjunto de caracteres sjis, cp932, ujis ou eucjpms."><col style="width: 40%"/><col align="left" style="width: 12%"/><col align="right" style="width: 12%"/><col align="right" style="width: 12%"/><col align="right" style="width: 12%"/><col align="right" style="width: 12%"/><thead><tr> <th>Nome do Caractere</th> <th>ucs2</th> <th>sjis</th> <th>cp932</th> <th>ujis</th> <th>eucjpms</th> </tr></thead><tbody><tr> <th>BROKEN BAR (BARRA QUEBRADA)</th> <td>00A6</td> <td>3F</td> <td>3F</td> <td>8FA2C3</td> <td>3F</td> </tr><tr> <th>FULLWIDTH BROKEN BAR (BARRA QUEBRADA LARGURA TOTAL)</th> <td>FFE4</td> <td>3F</td> <td>FA55</td> <td>3F</td> <td>8FA2</td> </tr><tr> <th>YEN SIGN (SINAL DE YEN)</th> <td>00A5</td> <td>3F</td> <td>3F</td> <td>20</td> <td>3F</td> </tr><tr> <th>FULLWIDTH YEN SIGN (SINAL DE YEN LARGURA TOTAL)</th> <td>FFE5</td> <td>818F</td> <td>818F</td> <td>A1EF</td> <td>3F</td> </tr><tr> <th>TILDE (TIL)</th> <td>007E</td> <td>7E</td> <td>7E</td> <td>7E</td> <td>7E</td> </tr><tr> <th>OVERLINE (SOBRE-LINHA)</th> <td>203E</td> <td>3F</td> <td>3F</td> <td>20</td> <td>3F</td> </tr><tr> <th>HORIZONTAL BAR (BARRA HORIZONTAL)</th> <td>2015</td> <td>815C</td> <td>815C</td> <td>A1BD</td> <td>A1BD</td> </tr><tr> <th>EM DASH (TRAVESSÃO)</th> <td>2014</td> <td>3F</td> <td>3F</td> <td>3F</td> <td>3F</td> </tr><tr> <th>REVERSE SOLIDUS (BARRA INVERTIDA)</th> <td>005C</td> <td>815F</td> <td>5C</td> <td>5C</td> <td>5C</td> </tr><tr> <th>FULLWIDTH REVERSE SOLIDUS (BARRA INVERTIDA LARGURA TOTAL)</th> <td>FF3C</td> <td>3F</td> <td>815F</td> <td>3F</td> <td>A1C0</td> </tr><tr> <th>WAVE DASH (TRAÇO ONDULADO)</th> <td>301C</td> <td>8160</td> <td>3F</td> <td>A1C1</td> <td>3F</td> </tr><tr> <th>FULLWIDTH TILDE (TIL LARGURA TOTAL)</th> <td>FF5E</td> <td>3F</td> <td>8160</td> <td>3F</td> <td>A1C1</td> </tr><tr> <th>DOUBLE VERTICAL LINE (LINHA VERTICAL DUPLA)</th> <td>2016</td> <td>8161</td> <td>3F</td> <td>A1C2</td> <td>3F</td> </tr><tr> <th>PARALLEL TO (PARALELO A)</th> <td>2225</td> <td>3F</td> <td>8161</td> <td>3F</td> <td>A1C2</td> </tr><tr> <th>MINUS SIGN (SINAL DE MENOS)</th> <td>2212</td> <td>817C</td> <td>3F</td> <td>A1DD</td> <td>3F</td> </tr><tr> <th>FULLWIDTH HYPHEN-MINUS (HÍFEN-MENOS LARGURA TOTAL)</th> <td>FF0D</td> <td>3F</td> <td>817C</td> <td>3F</td> <td>A1DD</td> </tr><tr> <th>CENT SIGN (SINAL DE CENT)</th> <td>00A2</td> <td>8191</td> <td>3F</td> <td>A1F1</td> <td>3F</td> </tr><tr> <th>FULLWIDTH CENT SIGN (SINAL DE CENT LARGURA TOTAL)</th> <td>FFE0</td> <td>3F</td> <td>8191</td> <td>3F</td> <td>A1F1</td> </tr><tr> <th>POUND SIGN (SINAL DE LIBRA)</th> <td>00A3</td> <td>8192</td> <td>3F</td> <td>A1F2</td> <td>3F</td> </tr><tr> <th>FULLWIDTH POUND SIGN (SINAL DE LIBRA LARGURA TOTAL)</th> <td>FFE1</td> <td>3F</td> <td>8192</td> <td>3F</td> <td>A1F2</td> </tr><tr> <th>NOT SIGN (SINAL DE NÃO)</th> <td>00AC</td> <td>81CA</td> <td>3F</td> <td>A2CC</td> <td>3F</td> </tr><tr> <th>FULLWIDTH NOT SIGN (SINAL DE NÃO LARGURA TOTAL)</th> <td>FFE2</td> <td>3F</td> <td>81CA</td> <td>3F</td> <td>A2CC</td> </tr></tbody></table> </div> <p> Agora considere a seguinte porção da tabela. </p> <div class="informaltable"> <table summary="Resultado da atribuição dos caracteres ucs2 NOT SIGN e FULLWIDTH NOT SIGN a uma coluna que usa o conjunto de caracteres sjis, cp932 ou ujis."><col style="width: 55%"/><col align="right" style="width: 15%"/><col align="right" style="width: 15%"/><col align="right" style="width: 15%"/><thead><tr> <th></th> <th>ucs2</th> <th>sjis</th> <th>cp932</th> </tr></thead><tbody><tr> <th>NOT SIGN (SINAL DE NÃO)</th> <td>00AC</td> <td>81CA</td> <td>3F</td> </tr><tr> <th>FULLWIDTH NOT SIGN (SINAL DE NÃO LARGURA TOTAL)</th> <td>FFE2</td> <td>3F</td> <td>81CA</td> </tr></tbody></table> </div> <p> Isso significa que o MySQL converte o <code>NOT SIGN</code> (Unicode <code>U+00AC</code>) para o Code Point <code>0x81CA</code> em <code>sjis</code> e para o Code Point <code>3F</code> em <code>cp932</code>. (<code>3F</code> é o ponto de interrogação (<span class="quote">“<span class="quote">?</span>”</span>. Isso é o que é sempre usado quando a conversão não pode ser realizada.) </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.11.5.</b></p></td><td align="left" valign="top"><p> O que devo fazer se quiser converter SJIS <code>81CA</code> para <code>cp932</code>? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> Nossa resposta é: <span class="quote">“<span class="quote">?</span>”</span>. Existem desvantagens nisso, e muitas pessoas prefeririam uma conversão <span class="quote">“<span class="quote">solta</span>”</span> (loose), de modo que <code>81CA (NOT SIGN)</code> em <code>sjis</code> se torne <code>81CA (FULLWIDTH NOT SIGN)</code> em <code>cp932</code>. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.11.6.</b></p></td><td align="left" valign="top"><p> Como o MySQL representa o sinal de Yen (<code>¥</code>)? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> Surge um problema porque algumas versões de conjuntos de caracteres japoneses (tanto <code>sjis</code> quanto <code>euc</code>) tratam <code>5C</code> como um <span class="firstterm">reverse solidus</span> (<code>\</code>, também conhecido como backslash), enquanto outras o tratam como um sinal de yen (<code>¥</code>). </p><p> O MySQL segue apenas uma versão da descrição padrão JIS (Japanese Industrial Standards). No MySQL, <span><em><code>5C</code> é sempre o reverse solidus (<code>\</code>)</em></span>. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.11.7.</b></p></td><td align="left" valign="top"><p> De quais problemas devo estar ciente ao trabalhar com conjuntos de caracteres coreanos no MySQL? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> Em teoria, embora tenha havido várias versões do conjunto de caracteres <code>euckr</code> (<span class="firstterm">Extended Unix Code Korea</span>), apenas um problema foi notado. Usamos a variante <span class="quote">“<span class="quote">ASCII</span>”</span> de EUC-KR, na qual o Code Point <code>0x5c</code> é REVERSE SOLIDUS, ou seja, <code>\</code>, em vez da variante <span class="quote">“<span class="quote">KS-Roman</span>”</span> de EUC-KR, na qual o Code Point <code>0x5c</code> é <code>WON SIGN</code> (<code>₩</code>). Isso significa que você não pode converter Unicode <code>U+20A9</code> para <code>euckr</code>: </p><pre class="programlisting copytoclipboard language-sql"><code class="language-sql">mysql&gt; SELECT CONVERT('₩' USING euckr) AS euckr, HEX(CONVERT('₩' USING euckr)) AS hexeuckr; +-------+----------+ | euckr | hexeuckr | +-------+----------+ | ?     | 3F       | +-------+----------+</code></pre></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.11.8.</b></p></td><td align="left" valign="top"><p> Por que eu recebo mensagens de erro <span class="errortext">Incorrect string value</span>? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> Para ver o problema, crie uma tabela com uma coluna Unicode (<code>ucs2</code>) e uma coluna Chinesa (<code>gb2312</code>). </p><pre class="programlisting copytoclipboard language-sql"><code class="language-sql">mysql&gt; CREATE TABLE ch (ucs2 CHAR(3) CHARACTER SET ucs2, gb2312 CHAR(3) CHARACTER SET gb2312);</code></pre><p> No modo SQL não-strict, tente colocar o caractere raro <code>汌</code> em ambas as colunas. </p><pre class="programlisting copytoclipboard language-sql"><code class="language-sql">mysql&gt; SET sql_mode = ''; mysql&gt; INSERT INTO ch VALUES ('A汌B','A汌B'); Query OK, 1 row affected, 1 warning (0.00 sec)</code></pre><p> O <code>INSERT</code> produz um Warning. Use a seguinte instrução para ver qual é: </p><pre class="programlisting copytoclipboard language-sql"><code class="language-sql">mysql&gt; SHOW WARNINGS\G *************************** 1. row *************************** Level: Warning Code: 1366 Message: Incorrect string value: '\xE6\xB1\x8CB' for column 'gb2312' at row 1</code></pre><p> Então é um Warning apenas sobre a coluna <code>gb2312</code>. </p><pre class="programlisting copytoclipboard language-sql"><code class="language-sql">mysql&gt; SELECT ucs2,HEX(ucs2),gb2312,HEX(gb2312) FROM ch; +-------+--------------+--------+-------------+ | ucs2  | HEX(ucs2)    | gb2312 | HEX(gb2312) | +-------+--------------+--------+-------------+ | A汌B | 00416C4C0042 | A?B    | 413F42      | +-------+--------------+--------+-------------+</code></pre><p> Várias coisas precisam de explicação aqui: </p> <div class="orderedlist"> <ol class="orderedlist" type="1"><li class="listitem"><p> O caractere <code>汌</code> não está no conjunto de caracteres <code>gb2312</code>, conforme descrito anteriormente. </p></li><li class="listitem"><p> Se você estiver usando uma versão antiga do MySQL, poderá ver uma mensagem diferente. </p></li><li class="listitem"><p> Um Warning ocorre em vez de um Error porque o MySQL não está configurado para usar o modo SQL strict. No modo não-strict, o MySQL tenta fazer o que pode, para obter o melhor ajuste, em vez de desistir. Com o modo SQL strict, a mensagem <span class="errortext">Incorrect string value</span> ocorre como um Error em vez de um Warning, e o <code>INSERT</code> falha. </p></li></ol> </div> </td></tr><tr class="question"><td align="left" valign="top"><p><b>A.11.9.</b></p></td><td align="left" valign="top"><p> Por que minha interface gráfica (GUI) ou meu navegador exibe caracteres CJK incorretamente na minha aplicação usando Access, PHP ou outra API? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> Obtenha uma conexão direta com o servidor usando o cliente <span><strong>mysql</strong></span> e tente a mesma Query lá. Se o <span><strong>mysql</strong></span> responder corretamente, o problema pode ser que sua interface de aplicação requer inicialização. Use o <span><strong>mysql</strong></span> para informar qual(is) conjunto(s) de caracteres ele usa com a instrução <code>SHOW VARIABLES LIKE 'char%';</code>. Se você estiver usando o Access, é muito provável que esteja se conectando com o Connector/ODBC. Neste caso, você deve verificar a Configuração do Connector/ODBC. Se, por exemplo, você usar <code>big5</code>, você inseriria <code>SET NAMES 'big5'</code>. (Neste caso, o caractere <code>;</code> não é obrigatório.) Se você estiver usando ASP, pode ser necessário adicionar <code>SET NAMES</code> no código. Aqui está um exemplo que funcionou no passado: </p><pre class="programlisting copytoclipboard language-none"><code class="language-none">&lt;% Session.CodePage=0 Dim strConnection Dim Conn strConnection="driver={MySQL ODBC 3.51 Driver};server=<em>server</em>;uid=<em>username</em>;" \ &amp; "pwd=<em>password</em>;database=<em>database</em>;stmt=SET NAMES 'big5';" Set Conn = Server.CreateObject("ADODB.Connection") Conn.Open strConnection %&gt;</code></pre><p> Da mesma forma, se você estiver usando qualquer conjunto de caracteres diferente de <code>latin1</code> com o Connector/NET, você deve especificar o conjunto de caracteres na string de conexão. Consulte Conexões do Connector/NET, para mais informações. </p><p> Se você estiver usando PHP, tente isto: </p><pre class="programlisting copytoclipboard language-php"><code class="language-php">&lt;?php $link = new mysqli($host, $usr, $pwd, $db);

  if( mysqli_connect_errno() ) { printf("Connect failed: %s\n", mysqli_connect_error()); exit(); }

  $link-&gt;query("SET NAMES 'utf8'"); ?&gt;</code></pre><p> Neste caso, usamos <code>SET NAMES</code> para alterar <code>character_set_client</code>, <code>character_set_connection</code> e <code>character_set_results</code>. </p><p> Outro problema frequentemente encontrado em aplicações PHP tem a ver com suposições feitas pelo navegador. Às vezes, adicionar ou alterar uma tag <code>&lt;meta&gt;</code> é suficiente para corrigir o problema: por exemplo, para garantir que o agente do usuário interprete o conteúdo da página como <code>UTF-8</code>, inclua <code>&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;</code> na seção <code>&lt;head&gt;</code> da página HTML. </p><p> Se você estiver usando o Connector/J, consulte Uso de Conjuntos de Caracteres e Unicode. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.11.10.</b></p></td><td align="left" valign="top"><p> Eu atualizei para o MySQL 5.7. Como posso reverter para um comportamento semelhante ao do MySQL 4.0 em relação aos conjuntos de caracteres? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> No MySQL Versão 4.0, havia um único conjunto de caracteres <span class="quote">“<span class="quote">global</span>”</span> para servidor e cliente, e a decisão sobre qual caractere usar era tomada pelo administrador do servidor. Isso mudou a partir do MySQL Versão 4.1. O que acontece agora é um <span class="quote">“<span class="quote">handshake</span>”</span> (aperto de mão), conforme descrito na Seção 10.4, “Conjuntos de Caracteres e Collation de Conexão”: </p> <div class="blockquote"> <blockquote class="blockquote"><p> Quando um cliente se conecta, ele envia ao servidor o nome do conjunto de caracteres que deseja usar. O servidor usa o nome para definir as variáveis de sistema <code>character_set_client</code>, <code>character_set_results</code> e <code>character_set_connection</code>. Na verdade, o servidor executa uma operação <code>SET NAMES</code> usando o nome do conjunto de caracteres. </p></blockquote> </div> <p> O efeito disso é que você não pode controlar o conjunto de caracteres do cliente iniciando o <span><strong>mysqld</strong></span> com <code>--character-set-server=utf8</code>. No entanto, alguns clientes asiáticos preferem o comportamento do MySQL 4.0. Para tornar possível manter esse comportamento, adicionamos uma opção do <span><strong>mysqld</strong></span>, <code>--character-set-client-handshake</code>, que pode ser desativada com <code>--skip-character-set-client-handshake</code>. Se você iniciar o <span><strong>mysqld</strong></span> com <code>--skip-character-set-client-handshake</code>, então, quando um cliente se conecta, ele envia ao servidor o nome do conjunto de caracteres que deseja usar. No entanto, <span><em>o servidor ignora esta solicitação do cliente</em></span>. </p><p> A título de exemplo, suponha que seu conjunto de caracteres de servidor favorito seja <code>latin1</code>. Suponha ainda que o cliente use <code>utf8</code> porque é isso que o sistema operacional do cliente suporta. Inicie o servidor com <code>latin1</code> como seu conjunto de caracteres padrão: </p><pre class="programlisting copytoclipboard language-terminal one-line"><code class="language-terminal">mysqld --character-set-server=latin1</code></pre><p> E então inicie o cliente com o conjunto de caracteres padrão <code>utf8</code>: </p><pre class="programlisting copytoclipboard language-terminal one-line"><code class="language-terminal">mysql --default-character-set=utf8</code></pre><p> As configurações resultantes podem ser vistas visualizando a saída de <code>SHOW VARIABLES</code>: </p><pre class="programlisting copytoclipboard language-sql"><code class="language-sql">mysql&gt; SHOW VARIABLES LIKE 'char%'; +--------------------------+----------------------------------------+ | Variable_name            | Value                                  | +--------------------------+----------------------------------------+ | character_set_client     | utf8                                   | | character_set_connection | utf8                                   | | character_set_database   | latin1                                 | | character_set_filesystem | binary                                 | | character_set_results    | utf8                                   | | character_set_server     | latin1                                 | | character_set_system     | utf8                                   | | character_sets_dir       | /usr/local/mysql/share/mysql/charsets/ | +--------------------------+----------------------------------------+</code></pre><p> Agora pare o cliente e pare o servidor usando <span><strong>mysqladmin</strong></span>. Em seguida, inicie o servidor novamente, mas desta vez diga para ele pular o handshake, assim: </p><pre class="programlisting copytoclipboard language-terminal one-line"><code class="language-terminal">mysqld --character-set-server=utf8 --skip-character-set-client-handshake</code></pre><p> Inicie o cliente com <code>utf8</code> mais uma vez como o conjunto de caracteres padrão e, em seguida, exiba as configurações resultantes: </p><pre class="programlisting copytoclipboard language-sql"><code class="language-sql">mysql&gt; SHOW VARIABLES LIKE 'char%'; +--------------------------+----------------------------------------+ | Variable_name            | Value                                  | +--------------------------+----------------------------------------+ | character_set_client     | latin1                                 | | character_set_connection | latin1                                 | | character_set_database   | latin1                                 | | character_set_filesystem | binary                                 | | character_set_results    | latin1                                 | | character_set_server     | latin1                                 | | character_set_system     | utf8                                   | | character_sets_dir       | /usr/local/mysql/share/mysql/charsets/ | +--------------------------+----------------------------------------+</code></pre><p> Como você pode ver comparando os diferentes resultados de <code>SHOW VARIABLES</code>, o servidor ignora as configurações iniciais do cliente se a opção <code>--skip-character-set-client-handshake</code> for usada. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.11.11.</b></p></td><td align="left" valign="top"><p> Por que algumas buscas <code>LIKE</code> e <code>FULLTEXT</code> com caracteres CJK falham? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> Para buscas <code>LIKE</code>, há um problema muito simples com tipos de coluna de string binária, como <code>BINARY</code> e <code>BLOB</code>: precisamos saber onde os caracteres terminam. Com conjuntos de caracteres multibyte, diferentes caracteres podem ter diferentes comprimentos de octeto. Por exemplo, em <code>utf8</code>, <code>A</code> requer um byte, mas <code>ペ</code> requer três bytes, conforme mostrado aqui: </p><pre class="programlisting copytoclipboard language-none"><code class="language-none">+-------------------------+---------------------------+ | OCTET_LENGTH(_utf8 'A') | OCTET_LENGTH(_utf8 'ペ') | +-------------------------+---------------------------+ |                       1 |                         3 | +-------------------------+---------------------------+</code></pre><p> Se não soubermos onde o primeiro caractere em uma string termina, não saberemos onde o segundo caractere começa, e nesse caso, mesmo buscas muito simples, como <code>LIKE '_A%'</code>, falham. A solução é usar um tipo de coluna de string não-binária definido para ter o conjunto de caracteres CJK apropriado. Por exemplo: <code>mycol TEXT CHARACTER SET sjis</code>. Alternativamente, converta para um conjunto de caracteres CJK antes de comparar. </p><p> Esta é uma razão pela qual o MySQL não pode permitir codificações de caracteres inexistentes. Se não for rigoroso ao rejeitar entradas ruins, não tem como saber onde os caracteres terminam. </p><p> Para buscas <code>FULLTEXT</code>, precisamos saber onde as palavras começam e terminam. Em idiomas ocidentais, isso raramente é um problema porque a maioria (se não todos) usa um limite de palavra fácil de identificar: o caractere de espaço. No entanto, este geralmente não é o caso com a escrita asiática. Poderíamos usar medidas arbitrárias, como assumir que todos os caracteres Han representam palavras, ou (para japonês) depender de mudanças de Katakana para Hiragana devido a terminações gramaticais. No entanto, a única solução segura requer uma lista abrangente de palavras, o que significa que teríamos que incluir um dicionário no servidor para cada idioma asiático suportado. Isso simplesmente não é viável. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.11.12.</b></p></td><td align="left" valign="top"><p> Como eu sei se o caractere <em><code>X</code></em> está disponível em todos os conjuntos de caracteres? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> A maioria dos caracteres chineses simplificados e os caracteres Kana japoneses básicos não-halfwidth aparecem em todos os conjuntos de caracteres CJK. O seguinte stored procedure aceita um caractere Unicode <code>UCS-2</code>, converte-o para outros conjuntos de caracteres e exibe os resultados em hexadecimal. </p><pre class="programlisting copytoclipboard language-sql"><code class="language-sql">DELIMITER //

CREATE PROCEDURE p_convert(ucs2_char CHAR(1) CHARACTER SET ucs2) BEGIN

CREATE TABLE tj (ucs2 CHAR(1) character set ucs2, utf8 CHAR(1) character set utf8, big5 CHAR(1) character set big5, cp932 CHAR(1) character set cp932, eucjpms CHAR(1) character set eucjpms, euckr CHAR(1) character set euckr, gb2312 CHAR(1) character set gb2312, gbk CHAR(1) character set gbk, sjis CHAR(1) character set sjis, ujis CHAR(1) character set ujis);

INSERT INTO tj (ucs2) VALUES (ucs2_char);

UPDATE tj SET utf8=ucs2, big5=ucs2, cp932=ucs2, eucjpms=ucs2, euckr=ucs2, gb2312=ucs2, gbk=ucs2, sjis=ucs2, ujis=ucs2;

/* Se houver problemas de conversão, UPDATE produz warnings. */

SELECT hex(ucs2) AS ucs2, hex(utf8) AS utf8, hex(big5) AS big5, hex(cp932) AS cp932, hex(eucjpms) AS eucjpms, hex(euckr) AS euckr, hex(gb2312) AS gb2312, hex(gbk) AS gbk, hex(sjis) AS sjis, hex(ujis) AS ujis FROM tj;

DROP TABLE tj;

END//

DELIMITER ;</code></pre><p> A entrada pode ser qualquer caractere <code>ucs2</code> único, ou pode ser o valor do Code (representação hexadecimal) desse caractere. Por exemplo, da lista de codificações e nomes <code>ucs2</code> do Unicode (http://www.unicode.org/Public/UNIDATA/UnicodeData.txt), sabemos que o caractere Katakana <span class="foreignphrase"><em class="foreignphrase">Pe</em></span> aparece em todos os conjuntos de caracteres CJK, e que seu valor de Code é <code>X'30DA'</code>. Se usarmos este valor como argumento para <code>p_convert()</code>, o resultado é como mostrado aqui: </p><pre class="programlisting copytoclipboard language-sql"><code class="language-sql">mysql&gt; CALL p_convert(X'30DA'); +------+--------+------+-------+---------+-------+--------+------+------+------+ | ucs2 | utf8   | big5 | cp932 | eucjpms | euckr | gb2312 | gbk  | sjis | ujis | +------+--------+------+-------+---------+-------+--------+------+------+------+ | 30DA | E3839A | C772 | 8379  | A5DA    | ABDA  | A5DA   | A5DA | 8379 | A5DA | +------+--------+------+-------+---------+-------+--------+------+------+------+</code></pre><p> Como nenhum dos valores da coluna é <code>3F</code> (ou seja, o caractere de ponto de interrogação, <code>?</code>), sabemos que cada conversão funcionou. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.11.13.</b></p></td><td align="left" valign="top"><p> Por que strings CJK são ordenadas incorretamente em Unicode? (I) </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"> <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"> <div class="admon-title"> Nota </div> <p> Os problemas de ordenação CJK descritos aqui podem ocorrer para versões do MySQL anteriores ao MySQL 8.0. A partir do MySQL 8.0, eles podem ser resolvidos usando o conjunto de caracteres <code>utf8mb4</code> e o Collation <code>utf8mb4_ja_0900_as_cs</code>. </p> </div> <p> Às vezes, as pessoas observam que o resultado de uma busca <code>utf8_unicode_ci</code> ou <code>ucs2_unicode_ci</code>, ou de uma ordenação <code>ORDER BY</code>, não é o que um falante nativo esperaria. Embora nunca descartemos a possibilidade de haver um bug, descobrimos no passado que muitas pessoas não leem corretamente a tabela padrão de pesos para o Unicode Collation Algorithm. O MySQL usa as tabelas encontradas em http://www.unicode.org/Public/UCA/: </p> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p> Tabela UCA 4.0.0: http://www.unicode.org/Public/UCA/4.0.0/allkeys-4.0.0.txt </p><p> Isso inclui Collation com <code><em><code>xxx</code></em>_unicode_ci</code> sem número de versão no nome do Collation. </p></li><li class="listitem"><p> Tabela UCA 5.2.0: http://www.unicode.org/Public/UCA/5.2.0/allkeys.txt </p><p> Isso inclui Collation com <code>_520_</code> no nome do Collation. </p></li><li class="listitem"><p> Tabela UCA 9.0.0: http://www.unicode.org/Public/UCA/9.0.0/allkeys.txt </p><p> Isso inclui Collation com <code>_0900_</code> no nome do Collation. </p></li></ul> </div> <p> Para lidar com versões mais recentes do UCA, criamos novos Collation. Somos muito cautelosos em mudar a ordenação de Collation existentes porque isso afeta Indexes, o que pode levar a situações como a relatada no Bug #16526, ilustrada a seguir: </p><pre class="programlisting copytलिपboard language-sql"><code class="language-sql">mysql&gt; CREATE TABLE tj (s1 CHAR(1) CHARACTER SET utf8 COLLATE utf8_unicode_ci); Query OK, 0 rows affected (0.05 sec)

mysql&gt; INSERT INTO tj VALUES ('が'),('か'); Query OK, 2 rows affected (0.00 sec) Records: 2  Duplicates: 0  Warnings: 0

mysql&gt; SELECT * FROM tj WHERE s1 = 'か'; +------+ | s1   | +------+ | が  | | か  | +------+</code></pre><p> O caractere na primeira linha de resultado não é o que procuramos. Por que o MySQL o recuperou? Primeiro, procuramos o valor do Code Point Unicode, o que é possível lendo o número hexadecimal da versão <code>ucs2</code> dos caracteres: </p><pre class="programlisting copytoclipboard language-sql"><code class="language-sql">mysql&gt; SELECT s1, HEX(CONVERT(s1 USING ucs2)) FROM tj; +------+-----------------------------+ | s1   | HEX(CONVERT(s1 USING ucs2)) | +------+-----------------------------+ | が  | 304C                        | | か  | 304B                        | +------+-----------------------------+</code></pre><p> Agora procuramos por <code>304B</code> e <code>304C</code> na tabela <code>4.0.0 allkeys</code> e encontramos estas linhas: </p><pre class="programlisting copytoclipboard language-none"><code class="language-none">304B  ; [.1E57.0020.000E.304B] # HIRAGANA LETTER KA 304C  ; [.1E57.0020.000E.304B][.0000.0140.0002.3099] # HIRAGANA LETTER GA; QQCM</code></pre><p> Os nomes oficiais do Unicode (seguindo a marca <span class="quote">“<span class="quote">#</span>”</span>) nos informam o silabário japonês (Hiragana), a classificação informal (letra, dígito ou pontuação) e o identificador ocidental (<code>KA</code> ou <code>GA</code>, que por acaso são componentes sonoros e não-sonoros do mesmo par de letras). Mais importante, o <span class="firstterm">peso primário</span> (o primeiro número hexadecimal dentro dos colchetes) é <code>1E57</code> em ambas as linhas. Para comparações tanto em buscas quanto em ordenação, o MySQL presta atenção apenas ao peso primário, ignorando todos os outros números. Isso significa que estamos ordenando <code>が</code> e <code>か</code> corretamente de acordo com a especificação Unicode. Se quiséssemos distingui-los, teríamos que usar um Collation não-UCA (Unicode Collation Algorithm) (<code>utf8_bin</code> ou <code>utf8_general_ci</code>), ou comparar os valores <code>HEX()</code>, ou usar <code>ORDER BY CONVERT(s1 USING sjis)</code>. Estar correto <span class="quote">“<span class="quote">de acordo com o Unicode</span>”</span> não é suficiente, é claro: a pessoa que enviou o bug estava igualmente correta. Para resolver isso, precisamos de outro Collation para japonês de acordo com o padrão JIS X 4061, no qual pares de letras sonoras/não-sonoras como <code>KA</code>/<code>GA</code> são distinguíveis para fins de ordenação. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.11.14.</b></p></td><td align="left" valign="top"><p> Por que strings CJK são ordenadas incorretamente em Unicode? (II) </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"> <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"> <div class="admon-title"> Nota </div> <p> Os problemas de ordenação CJK descritos aqui podem ocorrer para versões do MySQL anteriores ao MySQL 8.0. A partir do MySQL 8.0, eles podem ser resolvidos usando o conjunto de caracteres <code>utf8mb4</code> e o Collation <code>utf8mb4_ja_0900_as_cs</code>. </p> </div> <p> Se você estiver usando Unicode (<code>ucs2</code> ou <code>utf8</code>), e souber qual é a ordem de classificação do Unicode (consulte Seção A.11, “FAQ do MySQL 5.7: Conjuntos de Caracteres Chineses, Japoneses e Coreanos no MySQL”), mas o MySQL ainda parece ordenar sua tabela incorretamente, primeiro verifique o conjunto de caracteres na definição da tabela: </p><pre class="programlisting copytoclipboard language-sql"><code class="language-sql">mysql&gt; SHOW CREATE TABLE t\G ******************** 1. row ****************** Table: t Create Table: CREATE TABLE `t` ( `s1` char(1) CHARACTER SET ucs2 DEFAULT NULL ) ENGINE=MyISAM DEFAULT CHARSET=latin1</code></pre><p> Como o conjunto de caracteres para a coluna <code>s1</code> parece estar correto (<code>ucs2</code>), verifique qual informação a tabela <code>INFORMATION_SCHEMA.COLUMNS</code> pode fornecer sobre esta coluna: </p><pre class="programlisting copytoclipboard language-sql"><code class="language-sql">mysql&gt; SELECT COLUMN_NAME, CHARACTER_SET_NAME, COLLATION_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE COLUMN_NAME = 's1' AND TABLE_NAME = 't'; +-------------+--------------------+-----------------+ | COLUMN_NAME | CHARACTER_SET_NAME | COLLATION_NAME  | +-------------+--------------------+-----------------+ | s1          | ucs2               | ucs2_general_ci | +-------------+--------------------+-----------------+</code></pre><p> (Consulte Seção 24.3.5, “A Tabela INFORMATION_SCHEMA COLUMNS”, para mais informações.) </p><p> Você pode ver que o Collation é <code>ucs2_general_ci</code> em vez de <code>ucs2_unicode_ci</code>. A razão pela qual isso acontece pode ser encontrada usando <code>SHOW CHARACTER SET</code>, conforme mostrado aqui: </p><pre class="programlisting copytoclipboard language-sql"><code class="language-sql">mysql&gt; SHOW CHARSET LIKE 'ucs2%'; +---------+---------------+-------------------+--------+ | Charset | Description   | Default collation | Maxlen | +---------+---------------+-------------------+--------+ | ucs2    | UCS-2 Unicode | ucs2_general_ci   |      2 | +---------+---------------+-------------------+--------+</code></pre><p> Para <code>ucs2</code> e <code>utf8</code>, o Collation padrão é <span class="quote">“<span class="quote">general</span>”</span>. Para especificar um Collation UCA Unicode, use <code>COLLATE ucs2_unicode_ci</code>, conforme mostrado no item anterior. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.11.15.</b></p></td><td align="left" valign="top"><p> Por que meus caracteres suplementares são rejeitados pelo MySQL? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> Caracteres suplementares estão fora do Unicode <span><em>Basic Multilingual Plane / Plane 0</em></span>. Caracteres BMP têm valores de Code Point entre <code>U+0000</code> e <code>U+FFFF</code>. Caracteres suplementares têm valores de Code Point entre <code>U+10000</code> e <code>U+10FFFF</code>. </p><p> Para armazenar caracteres suplementares, você deve usar um conjunto de caracteres que os permita: </p> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p> Os conjuntos de caracteres <code>utf8</code> e <code>ucs2</code> suportam apenas caracteres BMP. </p><p> O conjunto de caracteres <code>utf8</code> permite apenas caracteres <code>UTF-8</code> que ocupam até três bytes. Isso levou a relatórios como o encontrado no Bug #12600, que rejeitamos como <span class="quote">“<span class="quote">não é um bug</span>”</span>. Com <code>utf8</code>, o MySQL deve truncar uma string de entrada quando encontra bytes que não entende. Caso contrário, não se sabe quanto tempo o caractere multibyte ruim tem. </p><p> Uma possível solução alternativa é usar <code>ucs2</code> em vez de <code>utf8</code>, caso em que os caracteres <span class="quote">“<span class="quote">ruins</span>”</span> são alterados para pontos de interrogação. No entanto, nenhum truncamento ocorre. Você também pode alterar o tipo de dados para <code>BLOB</code> ou <code>BINARY</code>, que não realizam verificação de validade. </p></li><li class="listitem"><p> Os conjuntos de caracteres <code>utf8mb4</code>, <code>utf16</code>, <code>utf16le</code> e <code>utf32</code> suportam caracteres BMP, bem como caracteres suplementares fora do BMP. </p></li></ul> </div> </td></tr><tr class="question"><td align="left" valign="top"><p><b>A.11.16.</b></p></td><td align="left" valign="top"><p> O termo <span class="quote">“<span class="quote">CJK</span>”</span> deveria ser <span class="quote">“<span class="quote">CJKV</span>”</span>? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> Não. O termo <span class="quote">“<span class="quote">CJKV</span>”</span> (<span class="firstterm">Chinês Japonês Coreano Vietnamita</span>) refere-se a conjuntos de caracteres vietnamitas que contêm caracteres Han (originalmente chineses). O MySQL suporta o script vietnamita moderno com caracteres ocidentais, mas não suporta o script vietnamita antigo usando caracteres Han. </p><p> A partir do MySQL 5.6, existem Collation vietnamitas para conjuntos de caracteres Unicode, conforme descrito na Seção 10.10.1, “Conjuntos de Caracteres Unicode”. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.11.17.</b></p></td><td align="left" valign="top"><p> O MySQL permite que caracteres CJK sejam usados em nomes de Database e Table? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> Sim. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.11.18.</b></p></td><td align="left" valign="top"><p> Onde posso encontrar traduções do Manual do MySQL para Chinês, Japonês e Coreano? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> A tradução para o japonês do manual do MySQL 5.6 pode ser baixada em https://dev.mysql.com/doc/. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.11.19.</b></p></td><td align="left" valign="top"><p> Onde posso obter ajuda com questões CJK e relacionadas no MySQL? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> Os seguintes recursos estão disponíveis: </p> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p> Uma lista de grupos de usuários do MySQL pode ser encontrada em https://wikis.oracle.com/display/mysql/List+of+MySQL+User+Groups. </p></li><li class="listitem"><p> Visualize as solicitações de recursos relacionadas a problemas de conjunto de caracteres em http://tinyurl.com/y6xcuf. </p></li><li class="listitem"><p> Visite o Fórum de Conjuntos de Caracteres, Collation e Unicode do MySQL. http://forums.mysql.com/ também oferece fóruns em idiomas estrangeiros. </p></li></ul> </div> <p> </p></td></tr></tbody></table>