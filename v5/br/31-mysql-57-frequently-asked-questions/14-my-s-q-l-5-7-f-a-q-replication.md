## A.14 FAQ do MySQL 5.7: Replication

Na seção a seguir, fornecemos respostas para as perguntas mais frequentes sobre MySQL Replication.

A.14.1. [A replica deve estar conectada ao source o tempo todo?](faqs-replication.html#faq-replication-have-connected-replica)

A.14.2. [Preciso habilitar o networking no meu source e replica para habilitar o replication?](faqs-replication-html#faq-replication-have-enable-networking)

A.14.3. [Como sei o quão atrasada uma replica está em comparação com o source? Em outras palavras, como sei a data do último statement replicado pela replica?](faqs-replication.html#faq-replication-how-compare-replica-date)

A.14.4. [Como forço o source a bloquear updates até que a replica se atualize?](faqs-replication.html#faq-replication-how-block-updates)

A.14.5. [Quais problemas devo estar ciente ao configurar o Two-Way Replication?](faqs-replication.html#faq-replication-how-two-way-problems)

A.14.6. [Como posso usar o replication para melhorar a performance do meu sistema?](faqs-replication.html#faq-replication-how-improves-performance)

A.14.7. [O que devo fazer para preparar o código client nas minhas próprias aplicações para usar o replication que melhora a performance?](faqs-replication.html#faq-replication-how-prepare-for-replication)

A.14.8. [Quando e o quanto o MySQL Replication pode melhorar a performance do meu sistema?](faqs-replication.html#faq-replication-how-benefits-me)

A.14.9. [Como posso usar o replication para fornecer redundancy ou High Availability?](faqs-replication.html#faq-replication-how-high-availability)

A.14.10. [Como sei se um replication source server está usando o formato de Binary Logging baseado em statement ou baseado em row?](faqs-replication.html#faq-replication-how-know-log-format)

A.14.11. [Como digo a uma replica para usar o Row-Based Replication?](faqs-replication.html#faq-replication-how-use-row-based)

A.14.12. [Como impeço que statements `GRANT` e `REVOKE` sejam replicados para máquinas replica?](faqs-replication.html#faq-replication-how-prevent-grant-revoke)

A.14.13. [O replication funciona em sistemas operacionais mistos (por exemplo, o source executa no Linux enquanto as replicas executam no macOS e Windows)?](faqs-replication.html#faq-replication-can-mix-os)

A.14.14. [O replication funciona em arquiteturas de hardware mistas (por exemplo, o source executa em uma máquina de 64 bits enquanto as replicas executam em máquinas de 32 bits)?](faqs-replication.html#faq-replication-can-mix-arch)

<table border="0" style="width: 100%;"><colgroup><col align="left" width="1%"/><col/></colgroup><tbody><tr class="question"><td align="left" valign="top"><p><b>A.14.1.</b></p></td><td align="left" valign="top"><p> A replica deve estar conectada ao source o tempo todo? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> Não, não é necessário. A replica pode cair ou ficar desconectada por horas ou até dias, e então se reconectar e se atualizar nos updates. Por exemplo, você pode configurar um relacionamento source/replica sobre um link dial-up onde o link só fica ativo esporadicamente e por curtos períodos de tempo. A implicação disso é que, a qualquer momento, não há garantia de que a replica esteja em sincronia com o source, a menos que você tome algumas medidas especiais. </p><p> Para garantir que a atualização possa ocorrer para uma replica que foi desconectada, você não deve remover os arquivos de Binary Log do source que contenham informações que ainda não foram replicadas para as replicas. O Asynchronous Replication só pode funcionar se a replica for capaz de continuar lendo o Binary Log a partir do ponto onde ela leu os eventos pela última vez. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.14.2.</b></p></td><td align="left" valign="top"><p> Preciso habilitar o networking no meu source e replica para habilitar o replication? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> Sim, o networking deve estar habilitado no source e na replica. Se o networking não estiver habilitado, a replica não pode se conectar ao source e transferir o Binary Log. Verifique se a variável de sistema <code>skip_networking</code> não foi habilitada no arquivo de configuração de nenhum dos servers. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.14.3.</b></p></td><td align="left" valign="top"><p> Como sei o quão atrasada uma replica está em comparação com o source? Em outras palavras, como sei a data do último statement replicado pela replica? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> Verifique a coluna <code>Seconds_Behind_Master</code> na saída de <code>SHOW REPLICA | SLAVE STATUS</code>. Veja Seção 16.1.7.1, “Checking Replication Status”. </p><p> Quando a Replication SQL Thread executa um evento lido do source, ela modifica seu próprio tempo para o timestamp do evento. (É por isso que <code>TIMESTAMP</code> é bem replicado.) Na coluna <code>Time</code> na saída de <code>SHOW PROCESSLIST</code>, o número de segundos exibido para a Replication SQL Thread é o número de segundos entre o timestamp do último evento replicado e o tempo real da máquina replica. Você pode usar isso para determinar a data do último evento replicado. Note que se sua replica foi desconectada do source por uma hora, e então se reconecta, você pode ver imediatamente grandes valores <code>Time</code> como 3600 para a Replication SQL Thread em <code>SHOW PROCESSLIST</code>. Isso ocorre porque a replica está executando statements que têm uma hora de idade. Veja Seção 16.2.3, “Replication Threads”. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.14.4.</b></p></td><td align="left" valign="top"><p> Como forço o source a bloquear updates até que a replica se atualize? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> Use o seguinte procedimento: </p> <div class="orderedlist"> <ol class="orderedlist" type="1"><li class="listitem"><p> No source, execute estes statements: </p><pre class="programlisting copytoclipboard language-sql"><code class="language-sql">mysql&gt; FLUSH TABLES WITH READ LOCK; mysql&gt; SHOW MASTER STATUS;</code></pre><p> Registre as Replication Coordinates (o nome e a posição atual do Binary Log) da saída do statement <code>SHOW</code>. </p></li><li class="listitem"><p> Na replica, execute o seguinte statement, onde os argumentos para a função <code>SOURCE_POS_WAIT()</code> ou <code>MASTER_POS_WAIT()</code> são os valores de Replication Coordinate obtidos na etapa anterior: </p><pre class="programlisting copytoclipboard language-sql"><code class="language-sql">mysql&gt; SELECT MASTER_POS_WAIT('<em>log_name</em>', <em>log_pos</em>);

Ou a partir do MySQL 8.0.26: mysql&gt; SELECT SOURCE_POS_WAIT('<em>log_name</em>', <em>log_pos</em>);</code></pre><p> O statement <code>SELECT</code> bloqueia até que a replica atinja o arquivo de log e a posição especificados. Nesse ponto, a replica está em sincronia com o source e o statement retorna. </p></li><li class="listitem"><p> No source, execute o seguinte statement para permitir que o source comece a processar updates novamente: </p><pre class="programlisting copytoclipboard language-sql one-line"><code class="language-sql">mysql&gt; UNLOCK TABLES;</code></pre></li></ol> </div> </td></tr><tr class="question"><td align="left" valign="top"><p><b>A.14.5.</b></p></td><td align="left" valign="top"><p> Quais problemas devo estar ciente ao configurar o Two-Way Replication? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> O MySQL Replication atualmente não suporta nenhum Locking Protocol entre source e replica para garantir a atomicity de um Distributed Update (entre servers). Em outras palavras, é possível que o client A faça um update no co-source 1 e, nesse meio tempo, antes que ele se propague para o co-source 2, o client B possa fazer um update no co-source 2 que faça com que o update do client A funcione de maneira diferente do que funcionou no co-source 1. Assim, quando o update do client A chega ao co-source 2, ele produz tables que são diferentes do que você tem no co-source 1, mesmo depois que todos os updates do co-source 2 também se propagaram. Isso significa que você não deve encadear dois servers em um relacionamento de Two-Way Replication, a menos que tenha certeza de que seus updates podem ocorrer com segurança em qualquer ordem, ou a menos que você cuide dos updates fora de ordem de alguma forma no código client. </p><p> Você também deve perceber que o Two-Way Replication, na verdade, não melhora muito (se é que melhora) a performance no que diz respeito aos updates. Cada server deve fazer o mesmo número de updates, assim como faria se tivesse um único server. A única diferença é que há um pouco menos de Lock Contention porque os updates originados em outro server são serializados em uma Replication Thread. Mesmo esse benefício pode ser compensado por Network Delays. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.14.6.</b></p></td><td align="left" valign="top"><p> Como posso usar o replication para melhorar a performance do meu sistema? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> Configure um server como source e direcione todos os writes para ele. Em seguida, configure tantas replicas quanto seu orçamento e espaço em rack permitirem, e distribua os reads entre o source e as replicas. Você também pode iniciar as replicas com a opção <code>--skip-innodb</code>, habilitar a variável de sistema <code>low_priority_updates</code> e definir a variável de sistema <code>delay_key_write</code> como <code>ALL</code> para obter melhorias de velocidade na replica. Neste caso, a replica usa MyISAM tables não transacionais em vez de InnoDB tables para obter mais velocidade, eliminando o Transactional Overhead. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.14.7.</b></p></td><td align="left" valign="top"><p> O que devo fazer para preparar o código client nas minhas próprias aplicações para usar o replication que melhora a performance? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> Consulte o guia para usar o replication como uma solução de scale-out, Seção 16.3.4, “Using Replication for Scale-Out”. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.14.8.</b></p></td><td align="left" valign="top"><p> Quando e o quanto o MySQL Replication pode melhorar a performance do meu sistema? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> O MySQL Replication é mais benéfico para um sistema que processa reads frequentes e writes infrequentes. Em teoria, usando uma configuração de Single-Source/Multiple-Replica, você pode escalar o sistema adicionando mais replicas até que você fique sem Network Bandwidth, ou sua carga de update aumente a ponto de o source não conseguir lidar com ela. </p><p> Para determinar quantas replicas você pode usar antes que os benefícios adicionais comecem a se estabilizar, e o quanto você pode melhorar a performance do seu site, você deve conhecer seus padrões de Query e determinar empiricamente, por meio de benchmarking, a relação entre o Throughput de reads e writes em um source típico e uma replica típica. O exemplo aqui mostra um cálculo bastante simplificado do que você pode obter com o replication para um sistema hipotético. Seja <code>reads</code> e <code>writes</code> o número de reads e writes por segundo, respectivamente. </p><p> Digamos que a carga do sistema consista em 10% de writes e 90% de reads, e determinamos por benchmarking que <code>reads</code> é 1200 - 2 * <code>writes</code>. Em outras palavras, o sistema pode fazer 1.200 reads por segundo sem writes, o write médio é duas vezes mais lento que o read médio, e a relação é linear. Suponha que o source e cada replica tenham a mesma capacidade, e que tenhamos um source e <em><code>N</code></em> replicas. Então temos para cada server (source ou replica): </p><p> <code>reads</code> = 1200 - 2 * <code>writes</code> </p><p> <code>reads</code> = 9 * <code>writes</code> / (<em><code>N</code></em> + 1) (reads são divididos, mas writes são replicados para todas as replicas) </p><p> 9 * <code>writes</code> / (<em><code>N</code></em> + 1) + 2 * <code>writes</code> = 1200 </p><p> <code>writes</code> = 1200 / (2 + 9/(<em><code>N</code></em> + 1)) </p><p> A última equação indica o número máximo de writes para <em><code>N</code></em> replicas, dada uma taxa máxima possível de read de 1.200 por segundo e uma proporção de nove reads por write. </p><p> Esta análise produz as seguintes conclusões: </p> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p> Se <em><code>N</code></em> = 0 (o que significa que não temos replication), nosso sistema pode lidar com cerca de 1200/11 = 109 writes por segundo. </p></li><li class="listitem"><p> Se <em><code>N</code></em> = 1, chegamos a 184 writes por segundo. </p></li><li class="listitem"><p> Se <em><code>N</code></em> = 8, chegamos a 400 writes por segundo. </p></li><li class="listitem"><p> Se <em><code>N</code></em> = 17, chegamos a 480 writes por segundo. </p></li><li class="listitem"><p> Eventualmente, à medida que <em><code>N</code></em> se aproxima do infinito (e nosso orçamento do infinito negativo), podemos nos aproximar muito de 600 writes por segundo, aumentando o Throughput do sistema em cerca de 5,5 vezes. No entanto, com apenas oito servers, aumentamos em quase quatro vezes. </p></li></ul> </div> <p> Esses cálculos assumem Network Bandwidth infinito e negligenciam vários outros fatores que podem ser significativos em seu sistema. Em muitos casos, você pode não ser capaz de realizar um cálculo semelhante ao que acabou de ser mostrado que preveja com precisão o que acontece em seu sistema se você adicionar <em><code>N</code></em> replicas. No entanto, responder às seguintes perguntas deve ajudá-lo a decidir se e o quanto o replication pode melhorar a performance do seu sistema: </p> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p> Qual é a proporção read/write em seu sistema? </p></li><li class="listitem"><p> Quanta mais carga de write um server pode suportar se você reduzir os reads? </p></li><li class="listitem"><p> Para quantas replicas você tem Bandwidth disponível em sua rede? </p></li></ul> </div> </td></tr><tr class="question"><td align="left" valign="top"><p><b>A.14.9.</b></p></td><td align="left" valign="top"><p> Como posso usar o replication para fornecer redundancy ou High Availability? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> A forma como você implementa a redundancy é inteiramente dependente de sua aplicação e circunstâncias. Soluções de High Availability (com Automatic Failover) requerem monitoramento ativo e scripts customizados ou ferramentas de terceiros para fornecer o suporte de failover do MySQL Server original para a replica. </p><p> Para lidar com o processo manualmente, você deve ser capaz de alternar de um source com falha para uma replica pré-configurada, alterando sua aplicação para se comunicar com o novo server ou ajustando o DNS para o MySQL Server do server com falha para o novo server. </p><p> Para mais informações e alguns exemplos de soluções, veja Seção 16.3.7, “Switching Sources During Failover”. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.14.10.</b></p></td><td align="left" valign="top"><p> Como sei se um replication source server está usando o formato de Binary Logging baseado em statement ou baseado em row? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> Verifique o valor da variável de sistema <code>binlog_format</code>: </p><pre class="programlisting copytoclipboard language-sql one-line"><code class="language-sql">mysql&gt; SHOW VARIABLES LIKE 'binlog_format';</code></pre><p> O valor exibido é sempre um de <code>STATEMENT</code>, <code>ROW</code> ou <code>MIXED</code>. Para o modo <code>MIXED</code>, o logging baseado em statement é usado por padrão, mas o replication muda automaticamente para o logging baseado em row sob certas condições, como statements não seguros (unsafe statements). Para informações sobre quando isso pode ocorrer, veja Seção 5.4.4.3, “Mixed Binary Logging Format”. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.14.11.</b></p></td><td align="left" valign="top"><p> Como digo a uma replica para usar o Row-Based Replication? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> Replicas sabem automaticamente qual formato usar. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.14.12.</b></p></td><td align="left" valign="top"><p> Como impeço que statements <code>GRANT</code> e <code>REVOKE</code> sejam replicados para máquinas replica? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> Inicie o server com a opção <code>--replicate-wild-ignore-table=mysql.%</code> para ignorar o replication para tables no database <code>mysql</code>. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.14.13.</b></p></td><td align="left" valign="top"><p> O replication funciona em sistemas operacionais mistos (por exemplo, o source executa no Linux enquanto as replicas executam no macOS e Windows)? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> Sim. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.14.14.</b></p></td><td align="left" valign="top"><p> O replication funciona em arquiteturas de hardware mistas (por exemplo, o source executa em uma máquina de 64 bits enquanto as replicas executam em máquinas de 32 bits)? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> Sim. </p></td></tr></tbody></table>