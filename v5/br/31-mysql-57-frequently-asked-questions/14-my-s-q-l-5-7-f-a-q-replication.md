## A.14 Perguntas frequentes sobre o MySQL 5.7: Replicação

Na seção a seguir, fornecemos respostas às perguntas mais frequentes sobre a replicação do MySQL.

A.14.1. [A réplica precisa estar conectada à fonte o tempo todo?](faqs-replication.html#faq-replication-have-connected-replica)

A.14.2. [Devo habilitar a rede em minha fonte e réplica para ativar a replicação?](faqs-replication.html#faq-replication-have-enable-networking)

A.14.3. [Como saber o quanto uma réplica está atrasada em relação à fonte? Em outras palavras, como saber a data da última declaração replicada pela réplica?](faqs-replication.html#faq-replication-how-compare-replica-date)

A.14.4. [Como forçar a fonte a bloquear atualizações até que a replica os alcance?](faqs-replication.html#faq-replication-como-bloquear-atualizações)

A.14.5. [Quais problemas devo ter em mente ao configurar a replicação bidirecional?](faqs-replication.html#faq-replication-como-problemas-bidirecionais)

A.14.6. [Como posso usar a replicação para melhorar o desempenho do meu sistema?](faqs-replication.html#faq-replication-how-improves-performance)

A.14.7. [O que devo fazer para preparar o código do cliente em minhas próprias aplicações para usar a replicação que melhora o desempenho?](faqs-replication.html#faq-replication-como-preparar-para-replicação)

A.14.8. [Quando e quanto a replicação do MySQL pode melhorar o desempenho do meu sistema?](faqs-replication.html#faq-replication-como-me-beneficia)

A.14.9. [Como posso usar a replicação para fornecer redundância ou alta disponibilidade?](faqs-replication.html#faq-replication-how-high-availability)

A.14.10. [Como saber se um servidor de origem de replicação está usando o formato de registro binário baseado em declarações ou baseado em linhas?](faqs-replication.html#faq-replication-how-know-log-format)

A.14.11. [Como faço para dizer a uma replica que use a replicação baseada em linhas?](faqs-replication.html#faq-replication-how-use-row-based)

A.14.12. [Como impedir que as instruções GRANT e REVOKE sejam replicadas para as máquinas replicadas?](faqs-replication.html#faq-replication-como-prevenir-grant-revoke)

A.14.13. [A replicação funciona em sistemas operacionais mistos (por exemplo, a fonte é executada no Linux, enquanto as réplicas são executadas no macOS e no Windows)?](faqs-replication.html#faq-replication-can-mix-os)

A.14.14. [A replicação funciona em arquiteturas de hardware mistas (por exemplo, a fonte é executada em uma máquina de 64 bits, enquanto as réplicas são executadas em máquinas de 32 bits)?](faqs-replication.html#faq-replication-can-mix-arch)

<table border="0" style="width: 100%;"><colgroup><col align="left" width="1%"/><col/></colgroup><tbody><tr class="question"><td align="left" valign="top"><p><b>A.14.1.</b></p></td><td align="left" valign="top"><p>A réplica precisa estar conectada à fonte o tempo todo?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Não, não é assim. A réplica pode ficar inativa ou desconectada por horas ou até dias, e depois se reconectar e recuperar as atualizações. Por exemplo, você pode configurar uma relação de fonte/réplica por meio de uma conexão dial-up, onde o link está disponível apenas de forma esporádica e por curtos períodos de tempo. Isso implica que, em qualquer momento, não é garantido que a réplica esteja sincronizada com a fonte, a menos que você tome algumas medidas especiais.</p><p>Para garantir que o catchup ocorra em uma replica que foi desconectada, você não deve remover arquivos de log binário da fonte que contenham informações que ainda não foram replicadas para as réplicas. A replicação assíncrona só pode funcionar se a replica puder continuar lendo o log binário a partir do ponto em que leu os eventos pela última vez.</p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.14.2.</b></p></td><td align="left" valign="top"><p>Devo habilitar a rede em minha fonte e réplica para habilitar a replicação?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Sim, a rede deve estar habilitada na fonte e na replica. Se a rede não estiver habilitada, a replica não poderá se conectar à fonte e transferir o log binário. Verifique se[[PH_HTML_CODE_<code>SOURCE_POS_WAIT()</code>]A variável do sistema não foi habilitada no arquivo de configuração de nenhum dos servidores.</p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.14.3.</b></p></td><td align="left" valign="top"><p>Como sei o quanto uma réplica está atrasada em relação à fonte? Em outras palavras, como sei a data da última declaração replicada pela réplica?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Verifique a coluna [[PH_HTML_CODE_<code>SOURCE_POS_WAIT()</code>] na saída de[[<code>SHOW REPLICA | SLAVE STATUS</code>]]VejaSeção 16.1.7.1, “Verificar o status da replicação”.</p><p>Quando o fio de replicação SQL executa um evento lido da fonte, ele modifica seu próprio tempo para o timestamp do evento. (É por isso que[[<code>TIMESTAMP</code>]]é bem replicada.) Na coluna [[<code>Time</code>]] no resultado[[<code>SHOW PROCESSLIST</code>]]O número de segundos exibido para o fio de replicação SQL é o número de segundos entre o timestamp do último evento replicado e o horário real da máquina replica. Você pode usar isso para determinar a data do último evento replicado. Observe que, se sua replica tiver sido desconectada da fonte por uma hora e, em seguida, se reconectar, você pode ver imediatamente grandes valores [[<code>Time</code>]] como 3600 para o fio de replicação SQL em[[<code>SHOW PROCESSLIST</code>]]Isso ocorre porque a réplica está executando instruções que têm uma idade de uma hora. VejaSeção 16.2.3, “Fios de replicação”.</p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.14.4.</b></p></td><td align="left" valign="top"><p>Como forçar a fonte a bloquear as atualizações até que a replica se atualize?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Utilize o procedimento a seguir:</p> <div class="orderedlist"> <ol class="orderedlist" type="1"><li class="listitem"><p>Na fonte, execute as seguintes declarações:</p><pre class="programlisting copytoclipboard language-sql">[[<code class="language-sql">mysql&gt; FLUSH TABLES WITH READ LOCK; mysql&gt; SHOW MASTER STATUS;</code>]]</pre><p>Registre as coordenadas de replicação (o nome e a posição do arquivo de log binário atual) na saída do[[<code>SHOW</code>]]declaração.</p></li><li class="listitem"><p>Na réplica, emita a seguinte declaração, onde os argumentos para[[<code>SOURCE_POS_WAIT()</code>]]ou[[<code>Seconds_Behind_Master</code><code>SOURCE_POS_WAIT()</code>]As funções são os valores das coordenadas de replicação obtidos na etapa anterior:</p><pre class="programlisting copytoclipboard language-sql"><code class="language-sql">mysql> SELECT MASTER_POS_WAIT('<em>log_name</em>",<em>log_pos</em>);

Or from MySQL 8.0.26: mysql> SELECT SOURCE_POS_WAIT('<em>log_name</em>', <em>log_pos</em>);</code></pre><p> The <code>SELECT</code> statement blocks until the replica reaches the specified log file and position. At that point, the replica is in synchrony with the source and the statement returns. </p></li><li class="listitem"><p> On the source, issue the following statement to enable the source to begin processing updates again: </p><pre class="programlisting copytoclipboard language-sql one-line"><code class="language-sql">mysql> UNLOCK TABLES;</code></pre></li></ol> </div> </td></tr><tr class="question"><td align="left" valign="top"><p><b>A.14.5.</b></p></td><td align="left" valign="top"><p> What issues should I be aware of when setting up two-way replication? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> MySQL replication currently does not support any locking protocol between source and replica to guarantee the atomicity of a distributed (cross-server) update. In other words, it is possible for client A to make an update to co-source 1, and in the meantime, before it propagates to co-source 2, client B could make an update to co-source 2 that makes the update of client A work differently than it did on co-source 1. Thus, when the update of client A makes it to co-source 2, it produces tables that are different from what you have on co-source 1, even after all the updates from co-source 2 have also propagated. This means that you should not chain two servers together in a two-way replication relationship unless you are sure that your updates can safely happen in any order, or unless you take care of mis-ordered updates somehow in the client code. </p><p> You should also realize that two-way replication actually does not improve performance very much (if at all) as far as updates are concerned. Each server must do the same number of updates, just as you would have a single server do. The only difference is that there is a little less lock contention because the updates originating on another server are serialized in one replication thread. Even this benefit might be offset by network delays. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.14.6.</b></p></td><td align="left" valign="top"><p> How can I use replication to improve performance of my system? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> Set up one server as the source and direct all writes to it. Then configure as many replicas as you have the budget and rackspace for, and distribute the reads among the source and the replicas. You can also start the replicas with the <code>--skip-innodb</code> option, enable the <code>low_priority_updates</code> system variable, and set the <code>delay_key_write</code> system variable to <code>ALL</code> to get speed improvements on the replica end. In this case, the replica uses nontransactional <code>MyISAM</code> tables instead of <code>InnoDB</code> tables to get more speed by eliminating transactional overhead. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.14.7.</b></p></td><td align="left" valign="top"><p> What should I do to prepare client code in my own applications to use performance-enhancing replication? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> See the guide to using replication as a scale-out solution, Section 16.3.4, “Using Replication for Scale-Out”. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.14.8.</b></p></td><td align="left" valign="top"><p> When and how much can MySQL replication improve the performance of my system? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> MySQL replication is most beneficial for a system that processes frequent reads and infrequent writes. In theory, by using a single-source/multiple-replica setup, you can scale the system by adding more replicas until you either run out of network bandwidth, or your update load grows to the point that the source cannot handle it. </p><p> To determine how many replicas you can use before the added benefits begin to level out, and how much you can improve performance of your site, you must know your query patterns, and determine empirically by benchmarking the relationship between the throughput for reads and writes on a typical source and a typical replica. The example here shows a rather simplified calculation of what you can get with replication for a hypothetical system. Let <code>reads</code> and <code>writes</code> denote the number of reads and writes per second, respectively. </p><p> Let's say that system load consists of 10% writes and 90% reads, and we have determined by benchmarking that <code>reads</code> is 1200 - 2 \* <code>writes</code>. In other words, the system can do 1,200 reads per second with no writes, the average write is twice as slow as the average read, and the relationship is linear. Suppose that the source and each replica have the same capacity, and that we have one source and <em><code>N</code></em> replicas. Then we have for each server (source or replica): </p><p> <code>reads</code> = 1200 - 2 \* <code>writes</code> </p><p> <code>reads</code> = 9 \* <code>writes</code> / (<em><code>N</code></em> + 1) (reads are split, but writes replicated to all replicas) </p><p> 9 \* <code>writes</code> / (<em><code>N</code></em> + 1) + 2 \* <code>writes</code> = 1200 </p><p> <code>writes</code> = 1200 / (2 + 9/(<em><code>N</code></em> + 1)) </p><p> The last equation indicates the maximum number of writes for <em><code>N</code></em> replicas, given a maximum possible read rate of 1,200 per second and a ratio of nine reads per write. </p><p> This analysis yields the following conclusions: </p> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p> If <em><code>N</code></em> = 0 (which means we have no replication), our system can handle about 1200/11 = 109 writes per second. </p></li><li class="listitem"><p> If <em><code>N</code></em> = 1, we get up to 184 writes per second. </p></li><li class="listitem"><p> If <em><code>N</code></em> = 8, we get up to 400 writes per second. </p></li><li class="listitem"><p> If <em><code>N</code></em> = 17, we get up to 480 writes per second. </p></li><li class="listitem"><p> Eventually, as <em><code>N</code></em> approaches infinity (and our budget negative infinity), we can get very close to 600 writes per second, increasing system throughput about 5.5 times. However, with only eight servers, we increase it nearly four times. </p></li></ul> </div> <p> These computations assume infinite network bandwidth and neglect several other factors that could be significant on your system. In many cases, you may not be able to perform a computation similar to the one just shown that accurately predicts what happens on your system if you add <em><code>N</code></em> replicas. However, answering the following questions should help you decide whether and by how much replication may improve the performance of your system: </p> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p> What is the read/write ratio on your system? </p></li><li class="listitem"><p> How much more write load can one server handle if you reduce the reads? </p></li><li class="listitem"><p> For how many replicas do you have bandwidth available on your network? </p></li></ul> </div> </td></tr><tr class="question"><td align="left" valign="top"><p><b>A.14.9.</b></p></td><td align="left" valign="top"><p> How can I use replication to provide redundancy or high availability? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> How you implement redundancy is entirely dependent on your application and circumstances. High-availability solutions (with automatic failover) require active monitoring and either custom scripts or third party tools to provide the failover support from the original MySQL server to the replica. </p><p> To handle the process manually, you should be able to switch from a failed source to a pre-configured replica by altering your application to talk to the new server or by adjusting the DNS for the MySQL server from the failed server to the new server. </p><p> For more information and some example solutions, see Section 16.3.7, “Switching Sources During Failover”. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.14.10.</b></p></td><td align="left" valign="top"><p> How do I tell whether a replication source server is using statement-based or row-based binary logging format? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> Check the value of the <code>binlog_format</code> system variable: </p><pre class="programlisting copytoclipboard language-sql one-line"><code class="language-sql">mysql> SHOW VARIABLES LIKE 'binlog_format';</code></pre><p> The value shown is always one of <code>STATEMENT</code>, <code>ROW</code>, or <code>MIXED</code>. For <code>MIXED</code> mode, statement-based logging is used by default but replication switches automatically to row-based logging under certain conditions, such as unsafe statements. For information about when this may occur, see Section 5.4.4.3, “Mixed Binary Logging Format”. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.14.11.</b></p></td><td align="left" valign="top"><p> How do I tell a replica to use row-based replication? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> Replicas automatically know which format to use. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.14.12.</b></p></td><td align="left" valign="top"><p> How do I prevent <code>GRANT</code> and <code>REVOKE</code> statements from replicating to replica machines? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> Start the server with the <code>--replicate-wild-ignore-table=mysql.%</code> option to ignore replication for tables in the <code>mysql</code> database. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.14.13.</b></p></td><td align="left" valign="top"><p> Does replication work on mixed operating systems (for example, the source runs on Linux while replicas run on macOS and Windows)? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> Yes. </p></td></tr><tr class="question"><td align="left" valign="top"><p><b>A.14.14.</b></p></td><td align="left" valign="top"><p> Does replication work on mixed hardware architectures (for example, the source runs on a 64-bit machine while replicas run on 32-bit machines)? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> Yes. </p></td></tr></tbody></table>
