#### 17.1.1.2 Group Replication

Group Replication é uma técnica que pode ser usada para implementar sistemas tolerantes a falhas. O grupo de *replication* é um conjunto de *Servers* que possuem cada um a sua própria cópia completa dos dados (um esquema de *replication* *shared-nothing*), e interagem uns com os outros através de troca de mensagens. A camada de comunicação oferece um conjunto de garantias, como entrega atômica de mensagens e entrega de mensagens em ordem total. Estas são propriedades muito poderosas que se traduzem em abstrações muito úteis que podem ser usadas para construir soluções mais avançadas de *database replication*.

O MySQL Group Replication se baseia nessas propriedades e abstrações e implementa um protocolo de *replication* *multi-source update everywhere*. Um grupo de *replication* é formado por múltiplos *Servers*, e cada *Server* no grupo pode executar *transactions* independentemente a qualquer momento. No entanto, todas as *transactions* de leitura e escrita (*read-write transactions*) fazem *commit* somente após serem aprovadas pelo grupo. Em outras palavras, para qualquer *read-write transaction*, o grupo precisa decidir se ela faz *commit* ou não, de modo que a operação de *commit* não é uma decisão unilateral do *Server* de origem. *Transactions* somente de leitura (*read-only transactions*) não necessitam de coordenação dentro do grupo e fazem *commit* imediatamente.

Quando uma *read-write transaction* está pronta para fazer *commit* no *Server* de origem, o *Server* transmite atomicamente os valores de escrita (*write values*) (as linhas que foram alteradas) e o *write set* correspondente (os identificadores exclusivos das linhas que foram atualizadas). Como a *transaction* é enviada por meio de uma transmissão atômica, ou todos os *Servers* no grupo recebem a *transaction*, ou nenhum a recebe. Se a receberem, todos a recebem na mesma ordem em relação a outras *transactions* que foram enviadas anteriormente. Portanto, todos os *Servers* recebem o mesmo conjunto de *transactions* na mesma ordem, e uma ordem total global é estabelecida para as *transactions*.

No entanto, pode haver conflitos entre *transactions* que são executadas concorrentemente em *Servers* diferentes. Tais conflitos são detectados inspecionando e comparando os *write sets* de duas *transactions* diferentes e concorrentes, em um processo chamado *certification*. Durante a *certification*, a detecção de conflitos é realizada no nível da linha (*row level*): se duas *transactions* concorrentes, que foram executadas em *Servers* diferentes, atualizam a mesma linha, há um conflito. O procedimento de resolução de conflitos estabelece que a *transaction* que foi ordenada primeiro faz *commit* em todos os *Servers*, e a *transaction* ordenada em segundo lugar é abortada, sendo, portanto, *rolled back* no *Server* de origem e descartada pelos outros *Servers* no grupo. Por exemplo, se t1 e t2 executam concorrentemente em sites diferentes, ambas alterando a mesma linha, e t2 é ordenada antes de t1, t2 vence o conflito e t1 é *rolled back*. Esta é, de fato, uma regra distribuída de "o primeiro *commit* vence". Note que se duas *transactions* tendem a conflitar com frequência, é uma boa prática iniciá-las no mesmo *Server*, onde elas têm a chance de sincronizar no gerenciador de *lock* local em vez de serem *rolled back* como resultado da *certification*.

Para aplicar e externalizar as *transactions* certificadas, o Group Replication permite que os *Servers* se desviem da ordem acordada das *transactions* se isso não quebrar a consistência e a validade. O Group Replication é um sistema de consistência eventual (*eventual consistency system*), o que significa que assim que o tráfego de entrada diminui ou para, todos os membros do grupo têm o mesmo conteúdo de dados. Enquanto o tráfego está fluindo, as *transactions* podem ser externalizadas em uma ordem ligeiramente diferente, ou externalizadas em alguns membros antes dos outros. Por exemplo, no modo *multi-primary*, uma *transaction* local pode ser externalizada imediatamente após a *certification*, embora uma *transaction* remota que esteja mais cedo na ordem global ainda não tenha sido aplicada. Isso é permitido quando o processo de *certification* estabeleceu que não há conflito entre as *transactions*. No modo *single-primary*, no *primary server*, há uma pequena chance de que *transactions* locais concorrentes e não conflitantes possam ser submetidas a *commit* e externalizadas em uma ordem diferente da ordem global acordada pelo Group Replication. Nos *secondaries*, que não aceitam escritas de clientes, as *transactions* são sempre submetidas a *commit* e externalizadas na ordem acordada.

A figura a seguir descreve o protocolo MySQL Group Replication e, ao compará-lo com o MySQL Replication (ou mesmo o MySQL *semisynchronous replication*), você pode notar algumas diferenças. Note que algumas mensagens subjacentes relacionadas a *consensus* e *Paxos* estão ausentes nesta imagem em prol da clareza.

**Figura 17.3 Protocolo MySQL Group Replication**

![Uma transaction recebida pela Fonte 1 é executada. A Fonte 1 envia, então, uma mensagem para o grupo de replication, consistindo em si mesma, Fonte 2 e Fonte 3. Quando todos os três membros alcançam o consensus, eles certificam a transaction. A Fonte 1 então escreve a transaction em seu binary log, faz commit e envia uma resposta para a aplicação cliente. As Fontes 2 e 3 escrevem a transaction em seus relay logs, depois a aplicam, a escrevem no binary log e fazem commit.](images/gr-replication-diagram.png)