#### 17.5.1.1 Modo Single-Primary

Neste modo, o grupo possui um Server *single-primary* que está configurado para o modo *read-write*. Todos os outros membros do grupo são configurados para o modo *read-only* (com [`super-read-only=ON`] ). Isso acontece automaticamente. O *Primary* é tipicamente o primeiro Server a realizar o *bootstrap* do grupo; todos os outros Servers que se juntam automaticamente aprendem sobre o Server *Primary* e são configurados para *read only*.

**Figura 17.5 Eleição de Novo Primary**

![Cinco instâncias de Server, S1, S2, S3, S4 e S5, são implantadas como um grupo interconectado. O Server S1 é o Primary. Clients de write estão se comunicando com o Server S1, e um Client de read está se comunicando com o Server S4. O Server S1 falha, interrompendo a comunicação com os Clients de write. O Server S2 assume como o novo Primary, e os Clients de write agora se comunicam com o Server S2.](images/single-primary-election.png)

Quando no modo *single-primary*, algumas das verificações implementadas no modo *multi-primary* são desabilitadas, pois o sistema impõe que apenas um único Server escreva no grupo. Por exemplo, alterações em tabelas que possuem *foreign keys* em cascata são permitidas, ao passo que no modo *multi-primary* elas não são. Após a falha do membro *Primary*, um mecanismo automático de *primary election* escolhe o novo membro *Primary*. O processo de *Election* é realizado examinando a nova *View* e ordenando os potenciais novos *Primaries* com base no valor de [`group_replication_member_weight`]. Assumindo que o grupo esteja operando com todos os membros executando a mesma versão do MySQL, o membro com o valor mais alto para [`group_replication_member_weight`] é eleito como o novo *Primary*. No caso de múltiplos Servers terem o mesmo [`group_replication_member_weight`], os Servers são então priorizados com base em seu [`server_uuid`] em ordem lexicográfica, e o primeiro é escolhido. Uma vez que um novo *Primary* é eleito, ele é automaticamente configurado para *read-write* e os outros *Secondaries* permanecem como *Secondaries* e, como tal, *read-only*.

Quando um novo *Primary* é eleito, ele se torna gravável (*writable*) apenas depois de ter processado todas as *Transactions* provenientes do *Primary* antigo. Isso evita possíveis problemas de concorrência entre *Transactions* antigas do *Primary* antigo e as novas que estão sendo executadas neste membro. É uma boa prática esperar que o novo *Primary* aplique seu *relay-log* relacionado à *Replication* antes de redirecionar as aplicações *Client* para ele.

Se o grupo estiver operando com membros que executam diferentes versões do MySQL, o processo de *Election* pode ser afetado. Por exemplo, se algum membro não suportar [`group_replication_member_weight`], o *Primary* é escolhido com base na ordem do [`server_uuid`] entre os membros da versão principal mais baixa. Alternativamente, se todos os membros executando diferentes versões do MySQL suportarem [`group_replication_member_weight`], o *Primary* é escolhido com base em [`group_replication_member_weight`] entre os membros da versão principal mais baixa.