#### 14.21.5.2 Adaptando uma Aplicação memcached para o Plugin memcached do InnoDB

Considere estes aspectos das tabelas MySQL e `InnoDB` ao adaptar aplicações **memcached** existentes para usar o plugin `daemon_memcached`:

* Se houver valores de chave com mais de alguns bytes, pode ser mais eficiente usar uma coluna numérica auto-increment como a Primary Key da tabela `InnoDB`, e criar um Unique Secondary Index na coluna que contém os valores de chave **memcached**. Isso ocorre porque o `InnoDB` tem o melhor desempenho para inserções em grande escala se os valores da Primary Key forem adicionados em ordem classificada (como acontece com valores auto-increment). Os valores da Primary Key são incluídos nos Secondary Indexes, o que ocupa espaço desnecessário se a Primary Key for um valor de string longo.

* Se você armazena várias classes diferentes de informação usando **memcached**, considere configurar uma tabela `InnoDB` separada para cada tipo de dado. Defina identificadores de tabela adicionais na tabela `innodb_memcache.containers` e use a notação `@@table_id.key` para armazenar e recuperar itens de diferentes tabelas. Dividir fisicamente diferentes tipos de informação permite ajustar as características de cada tabela para otimizar a utilização do espaço, o performance e a confiabilidade. Por exemplo, você pode habilitar a compression para uma tabela que armazena posts de blog, mas não para uma tabela que armazena imagens em miniatura. Você pode fazer backup de uma tabela com mais frequência do que de outra porque ela contém dados críticos. Você pode criar Secondary Indexes adicionais em tabelas que são frequentemente usadas para gerar relatórios usando SQL.

* Preferencialmente, configure um conjunto estável de definições de tabela para uso com o plugin `daemon_memcached`, e mantenha as tabelas permanentemente no lugar. As alterações na tabela `innodb_memcache.containers` entram em vigor na próxima vez que a tabela `innodb_memcache.containers` for consultada (queried). As entradas na tabela containers são processadas durante o startup e são consultadas sempre que um identificador de tabela não reconhecido (conforme definido por `containers.name`) é solicitado usando a notação `@@`. Assim, novas entradas ficam visíveis assim que você usa o identificador de tabela associado, mas as alterações em entradas existentes exigem um server restart antes que entrem em vigor.

* Ao usar a caching policy padrão `innodb_only`, as chamadas para `add()`, `set()`, `incr()` e assim por diante podem ser bem-sucedidas, mas ainda assim acionar debugging messages (mensagens de depuração) como `while expecting 'STORED', got unexpected response 'NOT_STORED`. As Debug messages ocorrem porque os valores novos e atualizados são enviados diretamente para a tabela `InnoDB` sem serem salvos no memory cache, devido à caching policy `innodb_only`.