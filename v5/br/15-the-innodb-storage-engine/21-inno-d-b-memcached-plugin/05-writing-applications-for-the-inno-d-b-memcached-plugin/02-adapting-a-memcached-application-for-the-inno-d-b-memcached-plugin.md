#### 14.21.5.2 Adaptando uma aplicação memcached para o plugin memcached do InnoDB

Considere esses aspectos das tabelas MySQL e `InnoDB` ao adaptar aplicações existentes do **memcached** para usar o plugin `daemon_memcached`:

- Se houver valores-chave mais longos que alguns bytes, pode ser mais eficiente usar uma coluna de autoincremento numérico como chave primária da tabela `InnoDB` e criar um índice secundário único na coluna que contém os valores das chaves do **memcached**. Isso ocorre porque o `InnoDB` tem o melhor desempenho para inserções em larga escala se os valores da chave primária forem adicionados em ordem ordenada (como são os valores de autoincremento). Os valores da chave primária são incluídos em índices secundários, o que ocupa espaço desnecessário se a chave primária for um valor de string longo.

- Se você armazenar várias classes diferentes de informações usando **memcached**, considere configurar uma tabela separada `InnoDB` para cada tipo de dado. Defina identificadores de tabela adicionais na tabela `innodb_memcache.containers` e use a notação `@@table_id.key` para armazenar e recuperar itens de diferentes tabelas. Dividir fisicamente diferentes tipos de informações permite que você ajuste as características de cada tabela para uma utilização de espaço, desempenho e confiabilidade ótimos. Por exemplo, você pode habilitar a compressão para uma tabela que contém postagens de blog, mas não para uma tabela que contém imagens de miniaturas. Você pode fazer backup de uma tabela com mais frequência do que outra porque ela contém dados críticos. Você pode criar índices secundários adicionais em tabelas que são frequentemente usadas para gerar relatórios usando SQL.

- De preferência, configure um conjunto estável de definições de tabelas para uso com o plugin **daemon\_memcached** e deixe as tabelas no lugar permanentemente. Alterações na tabela `innodb_memcache.containers` entram em vigor na próxima vez que a tabela `innodb_memcache.containers` for consultada. As entradas na tabela de contêineres são processadas no início e consultadas sempre que um identificador de tabela não reconhecido (definido por `containers.name`) for solicitado usando a notação `@@`. Assim, novas entradas são visíveis assim que você usar o identificador de tabela associado, mas alterações em entradas existentes requerem um reinício do servidor antes que elas entrem em vigor.

- Quando você usa a política de cache padrão `innodb_only`, as chamadas a `add()`, `set()`, `incr()` e assim por diante podem ser bem-sucedidas, mas ainda assim podem desencadear mensagens de depuração, como `while expecting 'STORED', got unexpected response 'NOT_STORED`. As mensagens de depuração ocorrem porque novos e valores atualizados são enviados diretamente para a tabela `InnoDB` sem serem salvos no cache de memória, devido à política de cache `innodb_only`.
