#### 14.9.1.1 Visão Geral da Compressão de Tabela

Como os processadores e as memórias cache aumentaram de velocidade mais do que os dispositivos de armazenamento em disco, muitas cargas de trabalho são limitadas pelo disco (*disk-bound*). A compressão de dados permite um tamanho menor de Database, I/O reduzido e throughput aprimorado, ao pequeno custo de aumento da utilização da CPU. A compressão é especialmente valiosa para aplicações intensivas em leitura (*read-intensive*), em sistemas com RAM suficiente para manter dados frequentemente usados na memória.

Uma tabela `InnoDB` criada com `ROW_FORMAT=COMPRESSED` pode usar um menor `page size` em disco do que o valor configurado de `innodb_page_size`. `pages` menores requerem menos I/O para ler e gravar no disco, o que é especialmente valioso para dispositivos SSD.

O `page size` comprimido é especificado através do parâmetro `KEY_BLOCK_SIZE` do `CREATE TABLE` ou `ALTER TABLE`. O diferente `page size` exige que a tabela seja colocada em um `tablespace` por arquivo (`file-per-table tablespace`) ou `general tablespace`, em vez de no `system tablespace`, pois o `system tablespace` não pode armazenar tabelas comprimidas. Para mais informações, consulte a Seção 14.6.3.2, “File-Per-Table Tablespaces”, e a Seção 14.6.3.3, “General Tablespaces”.

O nível de compressão é o mesmo, independentemente do valor de `KEY_BLOCK_SIZE`. Ao especificar valores menores para `KEY_BLOCK_SIZE`, você obtém os benefícios de I/O de `pages` progressivamente menores. Mas se você especificar um valor muito pequeno, haverá um *overhead* adicional para reorganizar as `pages` quando os valores dos dados não puderem ser comprimidos o suficiente para caber múltiplas *rows* em cada `page`. Há um limite rígido para o quão pequeno `KEY_BLOCK_SIZE` pode ser para uma tabela, baseado nos comprimentos das colunas *key* para cada um dos seus Indexes. Se você especificar um valor muito pequeno, a instrução `CREATE TABLE` ou `ALTER TABLE` falhará.

No Buffer Pool, os dados comprimidos são mantidos em `pages` pequenas, com um `page size` baseado no valor de `KEY_BLOCK_SIZE`. Para extrair ou atualizar os valores das colunas, o MySQL também cria uma `page` descompactada no Buffer Pool com os dados não comprimidos. Dentro do Buffer Pool, quaisquer atualizações para a `page` descompactada também são reescritas de volta para a `page` comprimida equivalente. Você pode precisar dimensionar seu Buffer Pool para acomodar os dados adicionais de `pages` comprimidas e não comprimidas, embora as `pages` não comprimidas sejam desalojadas (*evicted*) do Buffer Pool quando o espaço é necessário e, em seguida, descompactadas novamente no próximo acesso.