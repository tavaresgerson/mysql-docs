#### 14.9.1.5 Como a compressão funciona para tabelas InnoDB

Esta seção descreve alguns detalhes de implementação interna sobre a compressão para tabelas do InnoDB. As informações apresentadas aqui podem ser úteis para o ajuste de desempenho, mas não são necessárias para o uso básico da compressão.

##### Algoritmos de compressão

Alguns sistemas operacionais implementam a compressão ao nível do sistema de arquivos. Os arquivos são tipicamente divididos em blocos de tamanho fixo que são compactados em blocos de tamanho variável, o que facilmente leva à fragmentação. Toda vez que algo dentro de um bloco é modificado, todo o bloco é recompactado antes de ser escrito no disco. Essas propriedades tornam essa técnica de compressão inadequada para uso em um sistema de banco de dados intensivo em atualizações.

O MySQL implementa a compressão com a ajuda da conhecida biblioteca zlib, que implementa o algoritmo de compressão LZ77. Esse algoritmo de compressão é maduro, robusto e eficiente tanto na utilização da CPU quanto na redução do tamanho dos dados. O algoritmo é "sem perda", de modo que os dados originais não comprimidos sempre podem ser reconstruídos a partir da forma comprimida. A compressão LZ77 funciona encontrando sequências de dados que são repetidas dentro dos dados a serem comprimidos. Os padrões de valores nos seus dados determinam o quão bem ele comprime, mas os dados típicos dos usuários geralmente comprimem em 50% ou mais.

Nota

Antes do MySQL 5.7.24, o `InnoDB` suporta a biblioteca `zlib` até a versão 1.2.3. No MySQL 5.7.24 e versões posteriores, o `InnoDB` suporta a biblioteca `zlib` até a versão 1.2.11.

Ao contrário da compressão realizada por uma aplicação ou das características de compressão de alguns outros sistemas de gerenciamento de banco de dados, a compressão do InnoDB aplica-se tanto aos dados do usuário quanto aos índices. Em muitos casos, os índices podem constituir de 40% a 50% ou mais do tamanho total do banco de dados, então essa diferença é significativa. Quando a compressão está funcionando bem para um conjunto de dados, o tamanho dos arquivos de dados do InnoDB (os arquivos `.ibd` do espaço de tabela por arquivo ou espaço de tabela geral) é de 25% a 50% do tamanho não comprimido ou possivelmente menor. Dependendo da carga de trabalho, esse banco de dados menor pode, por sua vez, levar a uma redução no I/O e a um aumento no desempenho, com um custo modesto em termos de aumento da utilização da CPU. Você pode ajustar o equilíbrio entre o nível de compressão e o overhead da CPU modificando a opção de configuração `innodb_compression_level`.

##### Armazenamento e compressão de dados do InnoDB

Todos os dados do usuário nas tabelas do InnoDB são armazenados em páginas que compõem um índice em forma de árvore B (o índice agrupado). Em alguns outros sistemas de banco de dados, esse tipo de índice é chamado de "tabela organizada por índice". Cada linha no nó do índice contém os valores da chave primária (especificada pelo usuário ou gerada pelo sistema) e todas as outras colunas da tabela.

Os índices secundários nas tabelas InnoDB também são árvores B, contendo pares de valores: a chave do índice e um ponteiro para uma linha no índice agrupado. O ponteiro é, na verdade, o valor da chave primária da tabela, que é usado para acessar o índice agrupado se forem necessárias colunas além da chave primária e da chave do índice. Os registros dos índices secundários devem caber sempre em uma única página da árvore B.

A compressão dos nós de árvore B (tanto de índices agrupados quanto de índices secundários) é tratada de maneira diferente da compressão das páginas de excedente usadas para armazenar colunas longas de `VARCHAR`, `BLOB` ou `TEXT`, conforme explicado nas seções a seguir.

##### Compressão de Páginas B-Tree

Como elas são frequentemente atualizadas, as páginas de árvore B exigem um tratamento especial. É importante minimizar o número de vezes que os nós da árvore B são divididos, além de minimizar a necessidade de descomprimir e recomprimi-los.

Uma técnica que o MySQL utiliza é manter algumas informações do sistema no nó da árvore B em formato não comprimido, facilitando assim certas atualizações in-place. Por exemplo, isso permite que as linhas sejam marcadas para exclusão e excluídas sem nenhuma operação de compressão.

Além disso, o MySQL tenta evitar a descompactação e a recompactação desnecessárias das páginas de índice quando elas são alteradas. Dentro de cada página B-tree, o sistema mantém um "registro de modificação" não compactado para registrar as alterações feitas na página. Atualizações e inserções de registros pequenos podem ser escritas neste registro de modificação sem que seja necessário reconstruir toda a página completamente.

Quando o espaço do log de modificação esgota, o InnoDB descomprime a página, aplica as alterações e descomprime a página novamente. Se a recompressão falhar (uma situação conhecida como falha de compressão), os nós da árvore B são divididos e o processo é repetido até que a atualização ou inserção seja bem-sucedida.

Para evitar falhas frequentes de compressão em cargas de trabalho intensivas em escrita, como em aplicações OLTP, o MySQL às vezes reserva um espaço vazio (tampão) na página, para que o log de modificações seja preenchido mais rapidamente e a página seja recompressa enquanto ainda houver espaço suficiente para evitar a divisão. A quantidade de espaço de tampão restante em cada página varia à medida que o sistema mantém um registro da frequência de divisões de páginas. Em um servidor ocupado que realiza escritas frequentes em tabelas compactadas, você pode ajustar as opções de configuração `innodb_compression_failure_threshold_pct` e `innodb_compression_pad_pct_max` para ajustar esse mecanismo.

Geralmente, o MySQL exige que cada página B-tree em uma tabela InnoDB possa acomodar pelo menos dois registros. Para tabelas compactadas, essa exigência foi relaxada. As páginas de folha dos nós B-tree (seja da chave primária ou dos índices secundários) precisam apenas acomodar um registro, mas esse registro deve caber, em formato não compactado, no log de modificação por página. Se `innodb_strict_mode` estiver ativado, o MySQL verifica o tamanho máximo da linha durante a criação da tabela ou do índice. Se a linha não caber, a seguinte mensagem de erro é emitida: `ERROR HY000: Linha muito grande`.

Se você criar uma tabela quando o `innodb_strict_mode` estiver desativado e uma instrução subsequente `INSERT` ou `UPDATE` tentar criar uma entrada de índice que não cabe no tamanho da página compactada, a operação falhará com `ERROR 42000: Tamanho da linha muito grande`. (Esta mensagem de erro não nomeia o índice para o qual o registro é muito grande, nem menciona o comprimento do registro do índice ou o tamanho máximo do registro naquela página de índice específica.) Para resolver esse problema, reconstrua a tabela com `ALTER TABLE` e selecione um tamanho de página compactada maior (`KEY_BLOCK_SIZE`), reduza qualquer índice de prefixo de coluna ou desative a compressão completamente com `ROW_FORMAT=DYNAMIC` ou `ROW_FORMAT=COMPACT`.

O `innodb_strict_mode` não se aplica a espaços de tabelas gerais, que também suportam tabelas compactadas. As regras de gerenciamento de espaços de tabelas para espaços de tabelas gerais são rigorosamente aplicadas independentemente do `innodb_strict_mode`. Para mais informações, consulte a Seção 13.1.19, “Instrução CREATE TABLESPACE”.

##### Compressão de colunas BLOB, VARCHAR e TEXT

Em uma tabela InnoDB, as colunas `BLOB`, `VARCHAR` e `TEXT` que não fazem parte da chave primária podem ser armazenadas em páginas de sobreposição alocadas separadamente. Esses são chamados de colunas fora da página. Seus valores são armazenados em listas de páginas de sobreposição com ligação simples.

Para tabelas criadas com `ROW_FORMAT=DYNAMIC` ou `ROW_FORMAT=COMPRESSED`, os valores das colunas `BLOB`, `TEXT` ou `VARCHAR` podem ser armazenados completamente fora da página, dependendo de seu comprimento e do comprimento da linha inteira. Para colunas armazenadas fora da página, o registro do índice agrupado contém apenas ponteiros de 20 bytes para as páginas de sobreposição, um por coluna. Se alguma coluna for armazenada fora da página, isso depende do tamanho da página e do tamanho total da linha. Quando a linha é muito longa para caber inteiramente na página do índice agrupado, o MySQL escolhe as colunas mais longas para armazenamento fora da página até que a linha se encaixe na página do índice agrupado. Como mencionado acima, se uma linha não cabe sozinha em uma página comprimida, ocorre um erro.

Nota

Para tabelas criadas com `ROW_FORMAT=DYNAMIC` ou `ROW_FORMAT=COMPRESSED`, as colunas `TEXT` e `BLOB` que têm menos de ou igual a 40 bytes são sempre armazenadas em linha.

As tabelas criadas em versões mais antigas do MySQL usam o formato de arquivo Antelope, que suporta apenas `ROW_FORMAT=REDUNDANT` e `ROW_FORMAT=COMPACT`. Nesses formatos, o MySQL armazena os primeiros 768 bytes das colunas `BLOB`, `VARCHAR` e `TEXT` no registro do índice agrupado, juntamente com a chave primária. O prefixo de 768 bytes é seguido por um ponteiro de 20 bytes para as páginas de sobreposição que contêm o resto do valor da coluna.

Quando uma tabela está no formato `COMPRESSED`, todos os dados escritos nas páginas de excedente são comprimidos "como estão"; ou seja, o MySQL aplica o algoritmo de compressão zlib ao item de dados inteiro. Além dos dados, as páginas de excedente comprimidas contêm um cabeçalho e um trailer não comprimidos que incluem um checksum da página e um link para a próxima página de excedente, entre outras coisas. Portanto, é possível obter economias significativas de armazenamento para colunas `BLOB`, `TEXT` ou `VARCHAR` mais longas se os dados forem altamente compressivos, como é frequentemente o caso com dados de texto. Dados de imagem, como `JPEG`, geralmente já estão comprimidos e, portanto, não se beneficiam muito de serem armazenados em uma tabela comprimida; a compressão dupla pode desperdiçar ciclos de CPU por pouco ou nenhum ganho de espaço.

As páginas de excedente têm o mesmo tamanho que as outras páginas. Uma linha contendo dez colunas armazenadas fora da página ocupa dez páginas de excedente, mesmo que o comprimento total das colunas seja apenas 8K bytes. Em uma tabela não compactada, dez páginas de excedente não compactadas ocupam 160K bytes. Em uma tabela compactada com um tamanho de página de 8K, elas ocupam apenas 80K bytes. Assim, muitas vezes é mais eficiente usar o formato de tabela compactada para tabelas com valores de coluna longos.

Para os espaços de tabela por arquivo, o uso de um tamanho de página compactada de 16K pode reduzir os custos de armazenamento e de I/O para as colunas `BLOB`, `VARCHAR` ou `TEXT`, porque esses dados geralmente se comprimem bem e, portanto, podem exigir menos páginas de sobreposição, mesmo que os nós da árvore B mesmos ocupem tantas páginas quanto na forma não compactada. Os espaços de tabela gerais não suportam um tamanho de página compactada de 16K (`KEY_BLOCK_SIZE`). Para mais informações, consulte a Seção 14.6.3.3, “Espaços de tabela gerais”.

##### Compressão e o Pool de Buffer do InnoDB

Em uma tabela `InnoDB` compactada, cada página compactada (seja de 1K, 2K, 4K ou 8K) corresponde a uma página não compactada de 16K bytes (ou um tamanho menor se `innodb_page_size` estiver definido). Para acessar os dados de uma página, o MySQL lê a página compactada do disco se ela não estiver já no pool de buffer, e depois descompacta a página para sua forma original. Esta seção descreve como o `InnoDB` gerencia o pool de buffer em relação às páginas de tabelas compactadas.

Para minimizar as operações de entrada/saída (I/O) e reduzir a necessidade de descomprimir uma página, às vezes o pool de buffers contém tanto a forma comprimida quanto a não comprimida de uma página do banco de dados. Para dar espaço para outras páginas do banco de dados necessárias, o MySQL pode expulsar de um pool de buffers uma página não comprimida, deixando a página comprimida na memória. Ou, se uma página não foi acessada há algum tempo, a forma comprimida da página pode ser escrita em disco, para liberar espaço para outros dados. Assim, em qualquer momento, o pool de buffers pode conter tanto as formas comprimida quanto não comprimida da página, ou apenas a forma comprimida da página, ou nenhuma das duas.

O MySQL mantém um registro das páginas que devem ser mantidas na memória e quais devem ser removidas usando uma lista de uso menos recentemente (LRU), para que os dados quentes (acessados com frequência) tendem a permanecer na memória. Quando as tabelas compactadas são acessadas, o MySQL utiliza um algoritmo LRU adaptativo para alcançar um equilíbrio apropriado entre páginas compactadas e não compactadas na memória. Esse algoritmo adaptativo é sensível ao fato de que o sistema esteja executando de forma limitada por I/O ou por CPU. O objetivo é evitar gastar muito tempo de processamento descompactando páginas quando a CPU está ocupada e evitar realizar excesso de I/O quando a CPU tem ciclos disponíveis que podem ser usados para descompactar páginas compactadas (que podem já estar na memória). Quando o sistema está limitado por I/O, o algoritmo prefere remover a cópia não compactada de uma página em vez de ambas as cópias, para fazer mais espaço para outras páginas do disco se tornarem residentes na memória. Quando o sistema está limitado por CPU, o MySQL prefere remover tanto a página compactada quanto a não compactada, para que mais memória possa ser usada para páginas "quentes" e reduzir a necessidade de descompactar dados na memória apenas na forma compactada.

##### Compressão e os arquivos de registro de reinicialização do InnoDB

Antes de uma página compactada ser escrita em um arquivo de dados, o MySQL escreve uma cópia da página no log de refazer (se ela tiver sido compactada novamente desde a última vez que foi escrita no banco de dados). Isso é feito para garantir que os logs de refazer sejam úteis para a recuperação em caso de falha, mesmo no improvável caso a biblioteca `zlib` seja atualizada e essa mudança introduza um problema de compatibilidade com os dados compactados. Portanto, pode-se esperar um aumento no tamanho dos arquivos de log ou uma necessidade de verificações mais frequentes ao usar a compactação. A quantidade de aumento no tamanho do arquivo de log ou na frequência de verificações depende do número de vezes que páginas compactadas são modificadas de uma maneira que requer reorganização e recompactação.

As tabelas compactadas exigem o formato de arquivo Barracuda. Para criar uma tabela compactada em um espaço de tabela por arquivo, o `innodb_file_per_table` deve estar habilitado e o `innodb_file_format` deve ser definido como Barracuda. Não há dependência do ajuste `innodb_file_format` ao criar uma tabela compactada em um espaço de tabela geral. Para mais informações, consulte a Seção 14.6.3.3, “Espaços de Tabelas Gerais”. O produto MySQL Enterprise Backup suporta o formato de arquivo Barracuda.
