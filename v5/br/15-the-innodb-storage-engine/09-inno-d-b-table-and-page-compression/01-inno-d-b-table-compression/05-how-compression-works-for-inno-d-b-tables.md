#### 14.9.1.5 Como a Compressão Funciona para Tabelas InnoDB

Esta seção descreve alguns detalhes de implementação interna sobre a compressão para tabelas InnoDB. As informações apresentadas aqui podem ser úteis para otimização de desempenho (*tuning for performance*), mas não são essenciais para o uso básico da compressão.

##### Algoritmos de Compressão

Alguns sistemas operacionais implementam compressão no nível do sistema de arquivos (*file system level*). Os arquivos são tipicamente divididos em blocos de tamanho fixo que são comprimidos em blocos de tamanho variável, o que leva facilmente à fragmentação. Toda vez que algo dentro de um bloco é modificado, o bloco inteiro é recomprimido antes de ser escrito no disco (*disk*). Essas propriedades tornam essa técnica de compressão inadequada para uso em um sistema Database intensivo em atualizações (*update-intensive*).

O MySQL implementa a compressão com a ajuda da conhecida biblioteca `zlib`, que implementa o algoritmo de compressão LZ77. Este algoritmo de compressão é maduro, robusto e eficiente tanto na utilização da CPU quanto na redução do tamanho dos dados. O algoritmo é "sem perdas" (*lossless*), de modo que os dados originais não comprimidos podem sempre ser reconstruídos a partir da forma comprimida. A compressão LZ77 funciona encontrando sequências de dados que se repetem dentro dos dados a serem comprimidos. Os padrões de valores nos seus dados determinam o quão bem eles são comprimidos, mas dados típicos de usuário frequentemente comprimem em 50% ou mais.

Note

Antes do MySQL 5.7.24, o `InnoDB` suportava a biblioteca `zlib` até a versão 1.2.3. No MySQL 5.7.24 e posterior, o `InnoDB` suporta a biblioteca `zlib` até a versão 1.2.11.

Ao contrário da compressão executada por uma aplicação, ou dos recursos de compressão de alguns outros sistemas de gerenciamento Database, a compressão do InnoDB se aplica tanto aos dados do usuário quanto aos Indexes. Em muitos casos, os Indexes podem constituir 40-50% ou mais do tamanho total do Database, tornando esta diferença significativa. Quando a compressão está funcionando bem para um conjunto de dados, o tamanho dos arquivos de dados do InnoDB (os arquivos `.ibd` do tablespace por tabela - *file-per-table tablespace* - ou do general tablespace) é de 25% a 50% do tamanho não comprimido ou possivelmente menor. Dependendo da carga de trabalho (*workload*), este Database menor pode, por sua vez, levar a uma redução de I/O e a um aumento no *throughput*, a um custo modesto em termos de aumento da utilização da CPU. Você pode ajustar o equilíbrio entre o nível de compressão e o *overhead* da CPU modificando a opção de configuração `innodb_compression_level`.

##### Armazenamento de Dados e Compressão no InnoDB

Todos os dados do usuário em tabelas InnoDB são armazenados em *pages* que compreendem um Index B-tree (o *clustered index*). Em alguns outros sistemas Database, este tipo de Index é chamado de "tabela organizada por Index" (*index-organized table*). Cada linha no nó do Index contém os valores da Primary Key (especificada pelo usuário ou gerada pelo sistema) e todas as outras colunas da tabela.

Os *Secondary Indexes* em tabelas InnoDB também são B-trees, contendo pares de valores: a *index key* e um ponteiro para uma linha no *clustered index*. O ponteiro é, na verdade, o valor da Primary Key da tabela, que é usado para acessar o *clustered index* se colunas diferentes da *index key* e da Primary Key forem necessárias. Os registros de *Secondary Index* devem sempre caber em uma única *page* B-tree.

A compressão dos nós B-tree (tanto de *clustered indexes* quanto de *secondary indexes*) é tratada de forma diferente da compressão das *overflow pages* usadas para armazenar colunas longas `VARCHAR`, `BLOB` ou `TEXT`, conforme explicado nas seções seguintes.

##### Compressão de Pages B-Tree

Por serem frequentemente atualizadas, as *pages* B-tree requerem tratamento especial. É importante minimizar o número de vezes que os nós B-tree são divididos, bem como minimizar a necessidade de descompactar e recomprimir seu conteúdo.

Uma técnica que o MySQL utiliza é manter algumas informações do sistema no nó B-tree em formato não comprimido, facilitando assim certas atualizações *in-place*. Por exemplo, isso permite que as linhas sejam marcadas para exclusão (*delete-marked*) e excluídas sem qualquer operação de compressão.

Além disso, o MySQL tenta evitar a descompressão e recompressão desnecessárias de *index pages* quando elas são alteradas. Dentro de cada *page* B-tree, o sistema mantém um "log de modificação" não comprimido para registrar as alterações feitas na *page*. Atualizações e inserções de registros pequenos podem ser gravadas neste *modification log* sem exigir que a *page* inteira seja completamente reconstruída.

Quando o espaço para o *modification log* se esgota, o InnoDB descomprime a *page*, aplica as alterações e a recompime. Se a recompressão falhar (uma situação conhecida como *compression failure*), os nós B-tree são divididos e o processo é repetido até que a atualização ou inserção seja bem-sucedida.

Para evitar *compression failures* frequentes em cargas de trabalho intensivas em escrita (*write-intensive workloads*), como em aplicações OLTP, o MySQL às vezes reserva algum espaço vazio (*padding*) na *page*, para que o *modification log* se preencha mais cedo e a *page* seja recomprimida enquanto ainda houver espaço suficiente para evitar a divisão. Em um servidor ocupado que realiza escritas frequentes em tabelas comprimidas, você pode ajustar as opções de configuração `innodb_compression_failure_threshold_pct` e `innodb_compression_pad_pct_max` para otimizar (*fine-tune*) este mecanismo.

Geralmente, o MySQL exige que cada *page* B-tree em uma tabela InnoDB possa acomodar pelo menos dois registros. Para tabelas comprimidas, este requisito foi flexibilizado. As *leaf pages* dos nós B-tree (seja da Primary Key ou de *Secondary Indexes*) precisam acomodar apenas um registro, mas esse registro deve caber, em formato não comprimido, no *modification log* por *page*. Se `innodb_strict_mode` estiver `ON`, o MySQL verifica o tamanho máximo da linha durante `CREATE TABLE` ou `CREATE INDEX`. Se a linha não couber, a seguinte mensagem de erro é emitida: `ERROR HY000: Too big row`.

Se você criar uma tabela quando `innodb_strict_mode` estiver `OFF`, e uma instrução `INSERT` ou `UPDATE` subsequente tentar criar uma entrada de Index que não caiba no tamanho da *page* comprimida, a operação falhará com `ERROR 42000: Row size too large`. (Esta mensagem de erro não nomeia o Index para o qual o registro é muito grande, nem menciona o comprimento do registro do Index ou o tamanho máximo do registro naquela *index page* específica.) Para resolver este problema, reconstrua a tabela com `ALTER TABLE` e selecione um tamanho de *page* comprimida maior (`KEY_BLOCK_SIZE`), encurte quaisquer *column prefix indexes*, ou desative a compressão inteiramente com `ROW_FORMAT=DYNAMIC` ou `ROW_FORMAT=COMPACT`.

`innodb_strict_mode` não é aplicável a *general tablespaces*, que também suportam tabelas comprimidas. As regras de gerenciamento de Tablespace para *general tablespaces* são estritamente impostas independentemente de `innodb_strict_mode`. Para mais informações, consulte a Seção 13.1.19, “CREATE TABLESPACE Statement”.

##### Comprimindo Colunas BLOB, VARCHAR e TEXT

Em uma tabela InnoDB, colunas `BLOB`, `VARCHAR` e `TEXT` que não fazem parte da Primary Key podem ser armazenadas em *overflow pages* alocadas separadamente. Referimo-nos a essas colunas como colunas *off-page*. Seus valores são armazenados em listas ligadas (*singly-linked lists*) de *overflow pages*.

Para tabelas criadas em `ROW_FORMAT=DYNAMIC` ou `ROW_FORMAT=COMPRESSED`, os valores das colunas `BLOB`, `TEXT` ou `VARCHAR` podem ser armazenados totalmente *off-page*, dependendo do seu comprimento e do comprimento da linha inteira. Para colunas que são armazenadas *off-page*, o registro do *clustered index* contém apenas ponteiros de 20 bytes para as *overflow pages*, um por coluna. Se alguma coluna será armazenada *off-page* depende do tamanho da *page* e do tamanho total da linha. Quando a linha é muito longa para caber inteiramente dentro da *page* do *clustered index*, o MySQL escolhe as colunas mais longas para armazenamento *off-page* até que a linha caiba na *clustered index page*. Conforme observado acima, se uma linha não couber sozinha em uma *page* comprimida, ocorrerá um erro.

Note

Para tabelas criadas em `ROW_FORMAT=DYNAMIC` ou `ROW_FORMAT=COMPRESSED`, colunas `TEXT` e `BLOB` que são menores ou iguais a 40 bytes são sempre armazenadas *in-line*.

Tabelas criadas em versões mais antigas do MySQL usam o formato de arquivo Antelope, que suporta apenas `ROW_FORMAT=REDUNDANT` e `ROW_FORMAT=COMPACT`. Nesses formatos, o MySQL armazena os primeiros 768 bytes das colunas `BLOB`, `VARCHAR` e `TEXT` no registro do *clustered index* juntamente com a Primary Key. O prefixo de 768 bytes é seguido por um ponteiro de 20 bytes para as *overflow pages* que contêm o restante do valor da coluna.

Quando uma tabela está no formato `COMPRESSED`, todos os dados gravados nas *overflow pages* são comprimidos "como estão" (*as is*); ou seja, o MySQL aplica o algoritmo de compressão zlib a todo o item de dados. Além dos dados, as *overflow pages* comprimidas contêm um cabeçalho e um rodapé não comprimidos, compreendendo um *checksum* da *page* e um link para a próxima *overflow page*, entre outras coisas. Portanto, economias de armazenamento muito significativas podem ser obtidas para colunas `BLOB`, `TEXT` ou `VARCHAR` mais longas, se os dados forem altamente compressíveis, como costuma ser o caso de dados de texto. Dados de imagem, como `JPEG`, geralmente já estão comprimidos e, portanto, não se beneficiam muito de serem armazenados em uma tabela comprimida; a compressão dupla pode desperdiçar ciclos de CPU por pouca ou nenhuma economia de espaço.

As *overflow pages* têm o mesmo tamanho que outras *pages*. Uma linha contendo dez colunas armazenadas *off-page* ocupa dez *overflow pages*, mesmo que o comprimento total das colunas seja de apenas 8K bytes. Em uma tabela não comprimida, dez *overflow pages* não comprimidas ocupam 160K bytes. Em uma tabela comprimida com um tamanho de *page* de 8K, elas ocupam apenas 80K bytes. Assim, muitas vezes é mais eficiente usar o formato de tabela comprimida para tabelas com valores de coluna longos.

Para *file-per-table tablespaces*, usar um tamanho de *page* comprimida de 16K pode reduzir os custos de armazenamento e I/O para colunas `BLOB`, `VARCHAR` ou `TEXT`, porque tais dados geralmente comprimem bem e, portanto, podem exigir menos *overflow pages*, mesmo que os próprios nós B-tree ocupem tantas *pages* quanto na forma não comprimida. Os *General tablespaces* não suportam um tamanho de *page* comprimida de 16K (`KEY_BLOCK_SIZE`). Para mais informações, consulte a Seção 14.6.3.3, “General Tablespaces”.

##### Compressão e o Buffer Pool do InnoDB

Em uma tabela `InnoDB` comprimida, cada *page* comprimida (seja 1K, 2K, 4K ou 8K) corresponde a uma *page* não comprimida de 16K bytes (ou um tamanho menor se `innodb_page_size` estiver configurado). Para acessar os dados em uma *page*, o MySQL lê a *page* comprimida do disco (*disk*) se ela ainda não estiver no Buffer Pool, e então descomprime a *page* para sua forma original. Esta seção descreve como o `InnoDB` gerencia o Buffer Pool em relação às *pages* de tabelas comprimidas.

Para minimizar o I/O e reduzir a necessidade de descomprimir uma *page*, às vezes o Buffer Pool contém as formas comprimida e não comprimida de uma *database page*. Para abrir espaço para outras *database pages* necessárias, o MySQL pode ejetar (*evict*) uma *page* não comprimida do Buffer Pool, mantendo a *page* comprimida na memória. Ou, se uma *page* não tiver sido acessada por um tempo, a forma comprimida da *page* pode ser escrita no disco, para liberar espaço para outros dados. Assim, a qualquer momento, o Buffer Pool pode conter ambas as formas, comprimida e não comprimida da *page*, ou apenas a forma comprimida da *page*, ou nenhuma das duas.

O MySQL rastreia quais *pages* manter na memória e quais ejetar usando uma lista *least-recently-used* (LRU), de modo que dados "quentes" (acessados frequentemente) tendem a permanecer na memória. Quando tabelas comprimidas são acessadas, o MySQL usa um algoritmo LRU adaptativo para alcançar um equilíbrio apropriado de *pages* comprimidas e não comprimidas na memória. Este algoritmo adaptativo é sensível ao fato de o sistema estar rodando de forma *I/O-bound* (limitado por I/O) ou *CPU-bound* (limitado por CPU). O objetivo é evitar gastar muito tempo de processamento descomprimindo *pages* quando a CPU está ocupada, e evitar fazer excesso de I/O quando a CPU tem ciclos sobressalentes que podem ser usados para descomprimir *pages* comprimidas (que já podem estar na memória). Quando o sistema está *I/O-bound*, o algoritmo prefere ejetar a cópia não comprimida de uma *page* em vez de ambas as cópias, para abrir mais espaço para que outras *disk pages* se tornem residentes na memória. Quando o sistema está *CPU-bound*, o MySQL prefere ejetar ambas as *pages*, comprimida e não comprimida, para que mais memória possa ser usada para *pages* "quentes" e reduzindo a necessidade de descomprimir dados na memória que estão apenas em formato comprimido.

##### Compressão e os Redo Log Files do InnoDB

Antes que uma *page* comprimida seja escrita em um arquivo de dados, o MySQL escreve uma cópia da *page* no Redo Log (se ela tiver sido recomprimida desde a última vez que foi escrita no Database). Isso é feito para garantir que os Redo Logs sejam utilizáveis para recuperação de falhas (*crash recovery*), mesmo no caso improvável de a biblioteca `zlib` ser atualizada e essa alteração introduzir um problema de compatibilidade com os dados comprimidos. Portanto, pode-se esperar algum aumento no tamanho dos arquivos de log, ou uma necessidade de Checkpoints mais frequentes, ao usar a compressão. A quantidade de aumento no tamanho do arquivo de log ou na frequência do Checkpoint depende do número de vezes que as *pages* comprimidas são modificadas de uma forma que requer reorganização e recompressão.

Tabelas comprimidas requerem o formato de arquivo Barracuda. Para criar uma tabela comprimida em um *file-per-table tablespace*, `innodb_file_per_table` deve estar habilitado e `innodb_file_format` deve ser definido como Barracuda. Não há dependência da configuração `innodb_file_format` ao criar uma tabela comprimida em um *general tablespace*. Para mais informações, consulte a Seção 14.6.3.3, “General Tablespaces”. O produto MySQL Enterprise Backup suporta o formato de arquivo Barracuda.