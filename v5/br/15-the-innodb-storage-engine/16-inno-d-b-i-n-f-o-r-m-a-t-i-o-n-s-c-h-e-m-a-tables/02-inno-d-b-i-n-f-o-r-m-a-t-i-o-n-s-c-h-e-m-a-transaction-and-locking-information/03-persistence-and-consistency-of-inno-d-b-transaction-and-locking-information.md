#### 14.16.2.3 Persistência e Consistência das Informações de Transação e Locking do InnoDB

Os dados expostos pelas tabelas de transação e *locking* (`INNODB_TRX`, `INNODB_LOCKS` e `INNODB_LOCK_WAITS`) representam um vislumbre de dados em rápida mudança. Isso é diferente das tabelas de usuário, onde os dados mudam apenas quando ocorrem *updates* iniciados pela aplicação. Os dados subjacentes são dados internos gerenciados pelo sistema e podem mudar muito rapidamente.

Por motivos de desempenho, e para minimizar a chance de *joins* enganosos entre as tabelas de transação e *locking*, o `InnoDB` coleta as informações de transação e *locking* necessárias em um *buffer* intermediário sempre que um `SELECT` é emitido em qualquer uma das tabelas. Este *buffer* é atualizado apenas se mais de 0,1 segundos se passaram desde a última leitura do *buffer*. Os dados necessários para preencher as três tabelas são buscados de forma atômica e consistente e são salvos neste *buffer* interno global, formando um "instantâneo" (*snapshot*) de um ponto no tempo. Se ocorrerem múltiplos acessos à tabela dentro de 0,1 segundos (como certamente acontece quando o MySQL processa um *join* entre essas tabelas), o mesmo *snapshot* é usado para satisfazer a *query*.

Um resultado correto é retornado quando você faz um *join* de qualquer uma dessas tabelas em uma única *query*, porque os dados das três tabelas vêm do mesmo *snapshot*. Como o *buffer* não é atualizado a cada *query* em qualquer uma dessas tabelas, se você emitir *queries* separadas contra essas tabelas dentro de um décimo de segundo, os resultados serão os mesmos de *query* para *query*. Por outro lado, duas *queries* separadas das mesmas ou diferentes tabelas emitidas com mais de um décimo de segundo de intervalo podem apresentar resultados diferentes, visto que os dados vêm de *snapshots* diferentes.

Como o `InnoDB` precisa paralisar temporariamente enquanto os dados de transação e *locking* são coletados, *queries* muito frequentes dessas tabelas podem impactar negativamente o desempenho percebido por outros usuários.

Como essas tabelas contêm informações confidenciais (pelo menos `INNODB_LOCKS.LOCK_DATA` e `INNODB_TRX.TRX_QUERY`), por razões de segurança, apenas usuários com o privilégio `PROCESS` têm permissão para fazer `SELECT` nelas.

Conforme descrito anteriormente, os dados que preenchem as tabelas de transação e *locking* (`INNODB_TRX`, `INNODB_LOCKS` e `INNODB_LOCK_WAITS`) são buscados automaticamente e salvos em um *buffer* intermediário que fornece um *snapshot* de "ponto no tempo". Os dados em todas as três tabelas são consistentes quando consultados a partir do mesmo *snapshot*. No entanto, os dados subjacentes mudam tão rapidamente que vislumbres semelhantes em outros dados que mudam igualmente rápido podem não estar em sincronia. Portanto, você deve ter cuidado ao comparar dados nas tabelas de transação e *locking* do `InnoDB` com dados na tabela `PROCESSLIST`. Os dados da tabela `PROCESSLIST` não vêm do mesmo *snapshot* que os dados sobre *locking* e transações. Mesmo que você emita um único `SELECT` (fazendo um *join* de `INNODB_TRX` e `PROCESSLIST`, por exemplo), o conteúdo dessas tabelas geralmente não é consistente. `INNODB_TRX` pode referenciar linhas que não estão presentes em `PROCESSLIST` ou a *SQL query* atualmente em execução de uma transação mostrada em `INNODB_TRX.TRX_QUERY` pode ser diferente daquela em `PROCESSLIST.INFO`.