#### 14.16.2.2 Informações sobre Lock e Lock-Wait do InnoDB

Quando uma transaction atualiza uma row em uma table, ou a bloqueia com `SELECT FOR UPDATE`, o `InnoDB` estabelece uma lista ou queue de locks nessa row. De modo similar, o `InnoDB` mantém uma lista de locks em uma table para locks de nível de table (table-level locks). Se uma segunda transaction deseja atualizar uma row ou dar lock em uma table já bloqueada por uma transaction anterior em um modo incompatível, o `InnoDB` adiciona uma solicitação de lock para a row na queue correspondente. Para que um lock seja adquirido por uma transaction, todas as solicitações de lock incompatíveis previamente inseridas na lock queue para aquela row ou table devem ser removidas (o que ocorre quando as transactions que possuem ou solicitam esses locks fazem commit ou roll back).

Uma transaction pode ter qualquer número de solicitações de lock para diferentes rows ou tables. Em qualquer momento, uma transaction pode solicitar um lock que está sendo mantido por outra transaction, caso em que ela é bloqueada por essa outra transaction. A transaction solicitante deve esperar que a transaction que detém o blocking lock faça commit ou roll back. Se uma transaction não estiver esperando por um lock, ela está no estado `RUNNING`. Se uma transaction estiver esperando por um lock, ela está no estado `LOCK WAIT`. (A table `INNODB_TRX` do `INFORMATION_SCHEMA` indica os valores de estado da transaction.)

A table `INNODB_LOCKS` contém uma ou mais rows para cada transaction em estado `LOCK WAIT`, indicando quaisquer solicitações de lock que impeçam seu progresso. Esta table também contém uma row que descreve cada lock em uma queue de locks pendentes para uma determinada row ou table. A table `INNODB_LOCK_WAITS` mostra quais locks já detidos por uma transaction são blocking locks solicitados por outras transactions.