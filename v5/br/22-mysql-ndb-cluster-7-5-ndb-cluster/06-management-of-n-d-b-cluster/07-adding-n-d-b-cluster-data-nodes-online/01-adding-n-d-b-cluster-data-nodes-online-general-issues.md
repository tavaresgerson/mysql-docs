#### 21.6.7.1 Adicionando NDB Cluster Data Nodes Online: Problemas Gerais

Esta seção fornece informações gerais sobre o comportamento e as limitações atuais ao adicionar NDB Cluster nodes online.

**Redistribuição de Dados.** A capacidade de adicionar novos nodes online inclui um meio de reorganizar dados e Indexes de tabelas [`NDBCLUSTER`](mysql-cluster.html "Chapter 21 MySQL NDB Cluster 7.5 and NDB Cluster 7.6") para que sejam distribuídos por todos os data nodes, incluindo os novos, por meio da instrução [`ALTER TABLE ... REORGANIZE PARTITION`](alter-table-partition-operations.html "13.1.8.1 ALTER TABLE Partition Operations"). A reorganização de tabelas, tanto em memória (in-memory) quanto Disk Data, é suportada. Atualmente, esta redistribuição não inclui unique indexes (apenas ordered indexes são redistribuídos).

A redistribuição para tabelas [`NDBCLUSTER`](mysql-cluster.html "Chapter 21 MySQL NDB Cluster 7.5 and NDB Cluster 7.6") que já existiam antes da adição dos novos data nodes não é automática, mas pode ser realizada usando instruções SQL simples no [**mysql**](mysql.html "4.5.1 mysql — The MySQL Command-Line Client") ou em outra aplicação cliente MySQL. No entanto, todos os dados e Indexes adicionados a tabelas criadas após a adição de um novo node group são distribuídos automaticamente entre todos os data nodes do Cluster, incluindo aqueles adicionados como parte do novo node group.

**Initializações Parciais (Partial starts).** É possível adicionar um novo node group sem que todos os novos data nodes tenham sido iniciados. Também é possível adicionar um novo node group a um Cluster degradado—isto é, um Cluster que está apenas parcialmente iniciado, ou onde um ou mais data nodes não estão em execução. Neste último caso, o Cluster deve ter nodes suficientes em execução para ser viável antes que o novo node group possa ser adicionado.

**Efeitos em operações em andamento.** As operações DML normais que utilizam dados do NDB Cluster não são impedidas pela criação ou adição de um novo node group, nem pela reorganização de tabela. No entanto, não é possível executar DDL concorrentemente com a reorganização de tabela—ou seja, nenhuma outra instrução DDL pode ser emitida enquanto uma instrução [`ALTER TABLE ... REORGANIZE PARTITION`](alter-table.html "13.1.8 ALTER TABLE Statement") estiver em execução. Além disso, durante a execução de `ALTER TABLE ... REORGANIZE PARTITION` (ou a execução de qualquer outra instrução DDL), não é possível reiniciar os data nodes do Cluster.

**Gerenciamento de Falhas (Failure handling).** As falhas de data nodes durante a criação de node group e a reorganização de tabela são tratadas conforme mostrado na tabela a seguir:

**Tabela 21.60 Gerenciamento de falhas de data node durante a criação de node group e reorganização de tabela**

<table><col style="width: 25%"/><col style="width: 25%"/><col style="width: 25%"/><col style="width: 25%"/><thead><tr> <th>Falha durante</th> <th>Falha em data node "Antigo"</th> <th>Falha em data node "Novo"</th> <th>Falha de Sistema</th> </tr></thead><tbody><tr> <th>Criação de Node Group</th> <td> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>Se um node diferente do master falhar: </b> A criação do node group é sempre aplicada (rolled forward). </p></li><li class="listitem"><p><b>Se o master falhar: </b></p> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><b>Se o commit point interno tiver sido atingido: </b> A criação do node group é aplicada (rolled forward). </p></li><li class="listitem"><p><b>Se o commit point interno ainda não tiver sido atingido. </b> A criação do node group é revertida (rolled back). </p></li></ul> </div> </li></ul> </div> </td> <td> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>Se um node diferente do master falhar: </b> A criação do node group é sempre aplicada (rolled forward). </p></li><li class="listitem"><p><b>Se o master falhar: </b></p> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><b>Se o commit point interno tiver sido atingido: </b> A criação do node group é aplicada (rolled forward). </p></li><li class="listitem"><p><b>Se o commit point interno ainda não tiver sido atingido. </b> A criação do node group é revertida (rolled back). </p></li></ul> </div> </li></ul> </div> </td> <td> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>Se a execução de CREATE NODEGROUP tiver atingido o commit point interno: </b> Quando reiniciado, o Cluster inclui o novo node group. Caso contrário, não inclui. </p></li><li class="listitem"><p><b>Se a execução de CREATE NODEGROUP ainda não tiver atingido o commit point interno: </b> Quando reiniciado, o Cluster não inclui o novo node group. </p></li></ul> </div> </td> </tr><tr> <th>Reorganização de Tabela</th> <td> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>Se um node diferente do master falhar: </b> A reorganização de tabela é sempre aplicada (rolled forward). </p></li><li class="listitem"><p><b>Se o master falhar: </b></p> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><b>Se o commit point interno tiver sido atingido: </b> A reorganização de tabela é aplicada (rolled forward). </p></li><li class="listitem"><p><b>Se o commit point interno ainda não tiver sido atingido. </b> A reorganização de tabela é revertida (rolled back). </p></li></ul> </div> </td> <td> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>Se um node diferente do master falhar: </b> A reorganização de tabela é sempre aplicada (rolled forward). </p></li><li class="listitem"><p><b>Se o master falhar: </b></p> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><b>Se o commit point interno tiver sido atingido: </b> A reorganização de tabela é aplicada (rolled forward). </p></li><li class="listitem"><p><b>Se o commit point interno ainda não tiver sido atingido. </b> A reorganização de tabela é revertida (rolled back). </p></li></ul> </div> </td> <td> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>Se a execução de uma instrução ALTER TABLE ... REORGANIZE PARTITION tiver atingido o commit point interno: </b> Quando o Cluster é reiniciado, os dados e Indexes pertencentes a <em><code>table</code></em> são distribuídos usando os data nodes "novos". </p></li><li class="listitem"><p><b>Se a execução de uma instrução ALTER TABLE ... REORGANIZE PARTITION ainda não tiver atingido o commit point interno: </b> Quando o Cluster é reiniciado, os dados e Indexes pertencentes a <em><code>table</code></em> são distribuídos usando apenas os data nodes "antigos". </p></li></ul> </div> </td> </tr></tbody></table>

**Remoção de Node Groups (Dropping node groups).** O cliente [**ndb_mgm**](mysql-cluster-programs-ndb-mgm.html "21.5.5 ndb_mgm — The NDB Cluster Management Client") suporta o comando [`DROP NODEGROUP`](mysql-cluster-mgm-client-commands.html#ndbclient-drop-nodegroup), mas é possível remover um node group somente quando nenhum data node nesse node group contém dados. Como atualmente não há uma maneira de "esvaziar" um data node ou node group específico, este comando funciona apenas nos dois seguintes casos:

1. Após emitir [`CREATE NODEGROUP`](mysql-cluster-mgm-client-commands.html#ndbclient-create-nodegroup) no cliente [**ndb_mgm**](mysql-cluster-programs-ndb-mgm.html "21.5.5 ndb_mgm — The NDB Cluster Management Client"), mas antes de emitir quaisquer instruções [`ALTER TABLE ... REORGANIZE PARTITION`](alter-table.html "13.1.8 ALTER TABLE Statement") no cliente [**mysql**](mysql.html "4.5.1 mysql — The MySQL Command-Line Client").

2. Após remover todas as tabelas [`NDBCLUSTER`](mysql-cluster.html "Chapter 21 MySQL NDB Cluster 7.5 and NDB Cluster 7.6") usando [`DROP TABLE`](drop-table.html "13.1.29 DROP TABLE Statement").

   [`TRUNCATE TABLE`](truncate-table.html "13.1.34 TRUNCATE TABLE Statement") não funciona para este propósito porque os data nodes continuam a armazenar as definições da tabela.