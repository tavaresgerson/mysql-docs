#### 21.6.7.1 Adicionando nós de dados do NDB Cluster Online: Problemas gerais

Esta seção fornece informações gerais sobre o comportamento e as limitações atuais na adição de nós do NDB Cluster online.

**Redistribuição de Dados.** A capacidade de adicionar novos nós online inclui uma maneira de reorganizar os dados e índices da tabela `NDBCLUSTER` para que sejam distribuídos por todos os nós de dados, incluindo os novos, por meio da instrução `ALTER TABLE ... REORGANIZE PARTITION`. A reorganização da tabela, tanto de dados em memória quanto de dados em disco, é suportada. Essa redistribuição atualmente não inclui índices únicos (somente índices ordenados são redistribuídos).

A redistribuição das tabelas `NDBCLUSTER` que já existiam antes da adição dos novos nós de dados não é automática, mas pode ser realizada usando instruções SQL simples no **mysql** ou em outro aplicativo cliente do MySQL. No entanto, todos os dados e índices adicionados às tabelas criadas após a adição de um novo grupo de nós são distribuídos automaticamente entre todos os nós de dados do cluster, incluindo aqueles adicionados como parte do novo grupo de nós.

**Inícios parciais.** É possível adicionar um novo grupo de nós sem que todos os novos nós de dados sejam iniciados. Também é possível adicionar um novo grupo de nós a um clúster degradado — ou seja, um clúster que está apenas parcialmente iniciado ou onde um ou mais nós de dados não estão em execução. Neste último caso, o clúster deve ter no mínimo alguns nós em execução para ser viável antes que o novo grupo de nós possa ser adicionado.

**Efeitos nas operações em andamento.** As operações normais de manipulação de dados (DML) usando os dados do NDB Cluster não são impedidas pela criação ou adição de um novo grupo de nós ou pela reorganização da tabela. No entanto, não é possível realizar DDL simultaneamente com a reorganização da tabela — ou seja, nenhuma outra instrução DDL pode ser emitida enquanto uma instrução `ALTER TABLE ... REORGANIZE PARTITION` estiver sendo executada. Além disso, durante a execução de `ALTER TABLE ... REORGANIZE PARTITION` (ou a execução de qualquer outra instrução DDL), não é possível reiniciar os nós de dados do cluster.

**Tratamento de falhas.** As falhas dos nós de dados durante a criação do grupo de nós e a reorganização da tabela são tratadas conforme mostrado na tabela a seguir:

**Tabela 21.60 Gerenciamento de falhas no nó de dados durante a criação do grupo de nós e reorganização da tabela**

<table><col style="width: 25%"/><col style="width: 25%"/><col style="width: 25%"/><col style="width: 25%"/><thead><tr> <th>Falha durante</th> <th>Falha em<span class="quote">“<span class="quote">Velho</span>”</span>nó de dados</th> <th>Falha em<span class="quote">“<span class="quote">Novo</span>”</span>nó de dados</th> <th>Falha no sistema</th> </tr></thead><tbody><tr> <th>Criação de grupo de nós</th> <td> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>Se um nó, diferente do mestre, falhar:</b>A criação do grupo de nós é sempre avançada.</p></li><li class="listitem"><p><b>Se o capitão falhar:</b></p> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><b>Se o ponto de comprometimento interno tiver sido alcançado:</b>A criação do grupo de nós é adiada.</p></li><li class="listitem"><p><b>Se o ponto de comprometimento interno ainda não tiver sido alcançado.</b>A criação do grupo de nós é revertida</p></li></ul> </div> </li></ul> </div> </td> <td> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>Se um nó, diferente do mestre, falhar:</b>A criação do grupo de nós é sempre avançada.</p></li><li class="listitem"><p><b>Se o capitão falhar:</b></p> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><b>Se o ponto de comprometimento interno tiver sido alcançado:</b>A criação do grupo de nós é adiada.</p></li><li class="listitem"><p><b>Se o ponto de comprometimento interno ainda não tiver sido alcançado.</b>A criação do grupo de nós é revertida</p></li></ul> </div> </li></ul> </div> </td> <td> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>Se a execução da operação CREATE NODEGROUP tiver atingido o ponto de commit interno:</b>Quando reiniciado, o clúster inclui o novo grupo de nós. Caso contrário, ele não inclui.</p></li><li class="listitem"><p><b>Se a execução da operação CREATE NODEGROUP ainda não tiver atingido o ponto de commit interno:</b>Quando reiniciado, o clúster não inclui o novo grupo de nós.</p></li></ul> </div> </td> </tr><tr> <th>Reorganização da tabela</th> <td> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>Se um nó, diferente do mestre, falhar:</b>A reorganização da tabela é sempre avançada.</p></li><li class="listitem"><p><b>Se o capitão falhar:</b></p> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><b>Se o ponto de comprometimento interno tiver sido alcançado:</b>A reorganização da tabela é aplicada para frente.</p></li><li class="listitem"><p><b>Se o ponto de comprometimento interno ainda não tiver sido alcançado.</b>A reorganização da tabela foi desfeita.</p></li></ul> </div> </li></ul> </div> </td> <td> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>Se um nó, diferente do mestre, falhar:</b>A reorganização da tabela é sempre avançada.</p></li><li class="listitem"><p><b>Se o capitão falhar:</b></p> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><b>Se o ponto de comprometimento interno tiver sido alcançado:</b>A reorganização da tabela é aplicada para frente.</p></li><li class="listitem"><p><b>Se o ponto de comprometimento interno ainda não tiver sido alcançado.</b>A reorganização da tabela foi desfeita.</p></li></ul> </div> </li></ul> </div> </td> <td> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>Se a execução de uma instrução ALTER TABLE ... REORGANIZE PARTITION tiver atingido o ponto de commit interno:</b>Quando o cluster for reiniciado, os dados e índices pertencentes a<em class="replaceable">[[<code>table</code>]]</em>são distribuídos por meio de<span class="quote">“<span class="quote">novo</span>”</span>nós de dados.</p></li><li class="listitem"><p><b>Se a execução de uma instrução ALTER TABLE ... REORGANIZE PARTITION ainda não tiver atingido o ponto de commit interno:</b>Quando o cluster for reiniciado, os dados e índices pertencentes a<em class="replaceable">[[<code>table</code>]]</em>são distribuídos apenas com o uso de<span class="quote">“<span class="quote">antigo</span>”</span>nós de dados.</p></li></ul> </div> </td> </tr></tbody></table>

**Remoção de grupos de nós.** O cliente **ndb\_mgm** suporta o comando `DROP NODEGROUP`, mas é possível remover um grupo de nós apenas quando nenhum nó de dados no grupo de nós contiver dados. Como atualmente não há como "esvaziar" um nó de dados ou um grupo de nós específico, este comando funciona apenas nos seguintes dois casos:

1. Após emitir `CREATE NODEGROUP` no cliente **ndb\_mgm**, mas antes de emitir quaisquer instruções `ALTER TABLE ... REORGANIZE PARTITION` no cliente **mysql**.

2. Após descartar todas as tabelas de `NDBCLUSTER` usando `DROP TABLE`.

   A opção `TRUNCATE TABLE` não funciona para esse propósito, pois os nós de dados continuam a armazenar as definições da tabela.
