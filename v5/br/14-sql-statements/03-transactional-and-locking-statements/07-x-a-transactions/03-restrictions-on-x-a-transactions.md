#### 13.3.7.3 Restrições às Transações XA

O suporte para transações XA está limitado ao motor de armazenamento `InnoDB`.

Para o "XA externo", um servidor MySQL atua como Gerenciador de Recursos e os programas clientes atuam como Gerenciadores de Transações. Para o "XA interno", os mecanismos de armazenamento dentro de um servidor MySQL atuam como RM, e o próprio servidor atua como TM. O suporte ao XA interno é limitado pelas capacidades dos mecanismos de armazenamento individuais. O XA interno é necessário para lidar com transações XA que envolvem mais de um mecanismo de armazenamento. A implementação do XA interno exige que um mecanismo de armazenamento suporte o compromisso de duas fases no nível do manipulador de tabela, e atualmente isso é verdadeiro apenas para o `InnoDB`.

Para `XA START`, as cláusulas `JOIN` e `RESUME` são reconhecidas, mas não têm efeito.

Para `XA END`, a cláusula `SUSPEND [FOR MIGRATE]` é reconhecida, mas não tem efeito.

A exigência de que a parte *`bqual`* do valor *`xid`* seja diferente para cada transação XA dentro de uma transação global é uma limitação da implementação atual do MySQL XA. Não faz parte da especificação XA.

Antes do MySQL 5.7.7, as transações XA não eram compatíveis com a replicação. Isso acontecia porque uma transação XA que estivesse no estado `PREPARED` seria revertida ao desligar o servidor limpo ou ao desconectar o cliente. Da mesma forma, uma transação XA que estivesse no estado `PREPARED` ainda existiria nesse estado caso o servidor fosse desligado de forma anormal e, em seguida, reiniciado, mas o conteúdo da transação não poderia ser escrito no log binário. Em ambas as situações, a transação XA não poderia ser replicada corretamente.

No MySQL 5.7.7 e versões posteriores, há uma mudança no comportamento e uma transação XA é escrita no log binário em duas partes. Quando o `XA PREPARE` é emitido, a primeira parte da transação até o `XA PREPARE` é escrita usando um GTID inicial. Um `XA_prepare_log_event` é usado para identificar tais transações no log binário. Quando o `XA COMMIT` ou `XA ROLLBACK` é emitido, uma segunda parte da transação, contendo apenas a declaração `XA COMMIT` ou `XA ROLLBACK`, é escrita usando um segundo GTID. Note que a parte inicial da transação, identificada pelo `XA_prepare_log_event`, não é necessariamente seguida por sua declaração `XA COMMIT` ou `XA ROLLBACK`, o que pode causar o registro binário entrelaçado de qualquer duas transações XA. As duas partes da transação XA podem até aparecer em diferentes arquivos de log binário. Isso significa que uma transação XA em estado `PREPARED` agora é persistente até que uma declaração explícita `XA COMMIT` ou `XA ROLLBACK` seja emitida, garantindo que as transações XA sejam compatíveis com a replicação.

Em uma replica, imediatamente após a transação XA ser preparada, ela é desvinculada do thread de aplicação da replica e pode ser confirmada ou revertida por qualquer thread na replica. Isso significa que a mesma transação XA pode aparecer na tabela `events_transactions_current` com diferentes estados em diferentes fios. A tabela `events_transactions_current` exibe o status atual do evento de transação monitorado mais recente no thread, e não atualiza esse status quando o thread está parado. Portanto, a transação XA ainda pode ser exibida no estado `PREPARED` para o thread de aplicação original, após ter sido processada por outro thread. Para identificar positivamente as transações XA que ainda estão no estado `PREPARED` e precisam ser recuperadas, use a instrução `XA RECOVER` em vez das tabelas de transações do Schema de Desempenho.

As seguintes restrições existem para o uso de transações XA no MySQL 5.7.7 e versões posteriores:

- As transações XA não são totalmente resistentes a uma interrupção inesperada em relação ao log binário. Se houver uma interrupção inesperada enquanto o servidor estiver em meio a uma execução de uma instrução `XA PREPARE`, `XA COMMIT`, `XA ROLLBACK` ou `XA COMMIT ... UMA FASE`, o servidor pode não ser capaz de se recuperar a um estado correto, deixando o servidor e o log binário em um estado inconsistente. Nessa situação, o log binário pode conter transações XA extras que não foram aplicadas ou pode faltar transações XA que foram aplicadas. Além disso, se os GTIDs estiverem habilitados, após a recuperação, `@@GLOBAL.GTID_EXECUTED` pode não descrever corretamente as transações que foram aplicadas. Note que, se uma interrupção inesperada ocorrer antes de `XA PREPARE`, entre `XA PREPARE` e `XA COMMIT` (ou `XA ROLLBACK`) ou após `XA COMMIT` (ou `XA ROLLBACK`), o servidor e o log binário são recuperados corretamente e levados a um estado consistente.

- O uso de filtros de replicação ou filtros de log binário em combinação com transações XA não é suportado. O filtro de tabelas pode fazer com que uma transação XA esteja vazia em uma replica, e transações XA vazias não são suportadas. Além disso, com as configurações `master_info_repository=TABLE` e `relay_log_info_repository=TABLE` em uma replica, que se tornaram padrões no MySQL 8.0, o estado interno da transação do mecanismo de dados é alterado após uma transação XA filtrada, e pode se tornar inconsistente com o estado do contexto da transação de replicação.

  O erro `ER_XA_REPLICATION_FILTERS` é registrado sempre que uma transação XA é afetada por um filtro de replicação, independentemente de a transação estar vazia como resultado. Se a transação não estiver vazia, a replica pode continuar funcionando, mas você deve tomar medidas para descontinuar o uso de filtros de replicação com transações XA para evitar possíveis problemas. Se a transação estiver vazia, a replica para. Nesse caso, a replica pode estar em um estado indeterminado em que a consistência do processo de replicação pode ser comprometida. Em particular, o conjunto `gtid_executed` em uma replica da replica pode ser inconsistente com o da fonte. Para resolver essa situação, isole a fonte e pare toda a replicação, depois verifique a consistência do GTID em toda a topologia de replicação. Desfaça a transação XA que gerou a mensagem de erro e, em seguida, reinicie a replicação.

- Antes do MySQL 5.7.19, `FLUSH TABLES WITH READ LOCK` não é compatível com transações XA.

- As transações XA são consideradas inseguras para a replicação baseada em declarações. Se duas transações XA confirmadas em paralelo na fonte estiverem sendo preparadas na replica na ordem inversa, podem ocorrer dependências de bloqueio que não podem ser resolvidas com segurança, e é possível que a replicação falhe com um impasse na replica. Esta situação pode ocorrer em uma replica de um único ou múltiplos threads. Quando `binlog_format=STATEMENT` é definido, um aviso é emitido para declarações DML dentro das transações XA. Quando `binlog_format=MIXED` ou `binlog_format=ROW` é definido, as declarações DML dentro das transações XA são registradas usando a replicação baseada em linhas, e o problema potencial não está presente.
