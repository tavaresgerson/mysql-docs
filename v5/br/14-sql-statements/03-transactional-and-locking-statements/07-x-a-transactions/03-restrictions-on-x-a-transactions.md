#### 13.3.7.3 Restrições em Transações XA

O suporte a transações XA é limitado ao storage engine `InnoDB`.

Para "XA externo" (*external XA*), um servidor MySQL atua como um Gerenciador de Recursos (Resource Manager) e programas cliente atuam como Gerenciadores de Transações (Transaction Managers). Para "XA Interno" (*Internal XA*), os storage engines dentro de um servidor MySQL atuam como RMs, e o próprio servidor atua como um TM. O suporte a XA Interno é limitado pelas capacidades dos storage engines individuais. O XA Interno é necessário para lidar com transações XA que envolvem mais de um storage engine. A implementação do XA Interno exige que um storage engine suporte commit de duas fases (two-phase commit) no nível do table handler, e atualmente isso só é verdadeiro para `InnoDB`.

Para [`XA START`](xa-statements.html "13.3.7.1 XA Transaction SQL Statements"), as cláusulas `JOIN` e `RESUME` são reconhecidas, mas não têm efeito.

Para [`XA END`](xa-statements.html "13.3.7.1 XA Transaction SQL Statements"), a cláusula `SUSPEND [FOR MIGRATE]` é reconhecida, mas não tem efeito.

A exigência de que a parte *`bqual`* do valor *`xid`* seja diferente para cada transação XA dentro de uma transação global é uma limitação da implementação XA atual do MySQL. Não faz parte da especificação XA.

Antes do MySQL 5.7.7, as transações XA não eram compatíveis com Replication. Isso ocorria porque uma transação XA que estivesse no estado `PREPARED` seria submetida a Rollback em caso de desligamento limpo do servidor ou desconexão do cliente. Da mesma forma, uma transação XA que estivesse no estado `PREPARED` ainda existiria nesse estado caso o servidor fosse desligado de forma anormal e reiniciado, mas o conteúdo da transação não poderia ser escrito no Binary Log. Em ambas as situações, a transação XA não podia ser replicada corretamente.

No MySQL 5.7.7 e posterior, há uma mudança no comportamento, e uma transação XA é escrita no Binary Log em duas partes. Quando `XA PREPARE` é emitido, a primeira parte da transação até `XA PREPARE` é escrita usando um GTID inicial. Um `XA_prepare_log_event` é usado para identificar tais transações no Binary Log. Quando `XA COMMIT` ou `XA ROLLBACK` é emitido, uma segunda parte da transação contendo apenas o statement `XA COMMIT` ou `XA ROLLBACK` é escrita usando um segundo GTID. Observe que a parte inicial da transação, identificada por `XA_prepare_log_event`, não é necessariamente seguida pelo seu `XA COMMIT` ou `XA ROLLBACK`, o que pode causar o log intercalado (interleaved binary logging) de quaisquer duas transações XA. As duas partes da transação XA podem até aparecer em diferentes arquivos de Binary Log. Isso significa que uma transação XA no estado `PREPARED` agora é persistente até que um statement `XA COMMIT` ou `XA ROLLBACK` explícito seja emitido, garantindo que as transações XA sejam compatíveis com Replication.

Em uma Replica, imediatamente após a transação XA ser preparada, ela é desvinculada do applier thread da Replica e pode ser submetida a Commit ou Rollback por qualquer Thread na Replica. Isso significa que a mesma transação XA pode aparecer na tabela [`events_transactions_current`](performance-schema-events-transactions-current-table.html "25.12.7.1 The events_transactions_current Table") com estados diferentes em diferentes Threads. A tabela [`events_transactions_current`](performance-schema-events-transactions-current-table.html "25.12.7.1 The events_transactions_current Table") exibe o status atual do evento de transação monitorado mais recente no Thread e não atualiza esse status quando o Thread está ocioso. Assim, a transação XA ainda pode ser exibida no estado `PREPARED` para o applier thread original, mesmo depois de ter sido processada por outro Thread. Para identificar positivamente as transações XA que ainda estão no estado `PREPARED` e precisam ser recuperadas, use o statement [`XA RECOVER`](xa-statements.html "13.3.7.1 XA Transaction SQL Statements") em vez das tabelas de transação do Performance Schema.

As seguintes restrições existem para o uso de transações XA no MySQL 5.7.7 e posterior:

* As transações XA não são totalmente resilientes a uma interrupção inesperada no que diz respeito ao Binary Log. Se houver uma interrupção inesperada enquanto o servidor estiver no meio da execução de um statement `XA PREPARE`, `XA COMMIT`, `XA ROLLBACK` ou `XA COMMIT ... ONE PHASE`, o servidor pode não ser capaz de se recuperar para um estado correto, deixando o servidor e o Binary Log em um estado inconsistente. Nesta situação, o Binary Log pode conter transações XA extras que não são aplicadas, ou perder transações XA que são aplicadas. Além disso, se GTIDs estiverem habilitados, após a recuperação `@@GLOBAL.GTID_EXECUTED` pode não descrever corretamente as transações que foram aplicadas. Observe que se ocorrer uma interrupção inesperada antes de `XA PREPARE`, entre `XA PREPARE` e `XA COMMIT` (ou `XA ROLLBACK`), ou após `XA COMMIT` (ou `XA ROLLBACK`), o servidor e o Binary Log são recuperados corretamente e levados a um estado consistente.

* O uso de replication filters ou binary log filters em combinação com transações XA não é suportado. A filtragem de tabelas pode fazer com que uma transação XA fique vazia em uma Replica, e transações XA vazias não são suportadas. Além disso, com as configurações [`master_info_repository=TABLE`](replication-options-replica.html#sysvar_master_info_repository) e [`relay_log_info_repository=TABLE`](replication-options-replica.html#sysvar_relay_log_info_repository) em uma Replica, que se tornaram os defaults no MySQL 8.0, o estado interno da transação do data engine é alterado após uma transação XA filtrada, podendo se tornar inconsistente com o estado do contexto da transação de Replication.

  O erro [`ER_XA_REPLICATION_FILTERS`](/doc/mysql-errors/5.7/en/server-error-reference.html#error_er_xa_replication_filters) é registrado sempre que uma transação XA é afetada por um replication filter, independentemente de a transação ter ficado vazia ou não. Se a transação não estiver vazia, a Replica é capaz de continuar em execução, mas você deve tomar medidas para descontinuar o uso de replication filters com transações XA a fim de evitar problemas potenciais. Se a transação estiver vazia, a Replica para. Nesse caso, a Replica pode estar em um estado indeterminado no qual a consistência do processo de Replication pode ser comprometida. Em particular, o conjunto `gtid_executed` em uma Replica da Replica pode ser inconsistente com o da Source. Para resolver esta situação, isole a Source e pare todo o Replication, então verifique a consistência do GTID em toda a topologia de Replication. Desfaça a transação XA que gerou a mensagem de erro e, em seguida, reinicie o Replication.

* Antes do MySQL 5.7.19, [`FLUSH TABLES WITH READ LOCK`](flush.html#flush-tables-with-read-lock) não é compatível com transações XA.

* As transações XA são consideradas inseguras para statement-based replication. Se duas transações XA commited em paralelo na Source estiverem sendo preparadas na Replica na ordem inversa, podem ocorrer dependências de Lock que não podem ser resolvidas com segurança, e é possível que o Replication falhe com Deadlock na Replica. Esta situação pode ocorrer para uma Replica single-threaded ou multithreaded. Quando [`binlog_format=STATEMENT`](replication-options-binary-log.html#sysvar_binlog_format) é configurado, um aviso é emitido para statements DML dentro de transações XA. Quando [`binlog_format=MIXED`](replication-options-binary-log.html#sysvar_binlog_format) ou [`binlog_format=ROW`](replication-options-binary-log.html#sysvar_binlog_format) é configurado, statements DML dentro de transações XA são logados usando row-based replication, e o problema potencial não está presente.