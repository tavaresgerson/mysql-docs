## 12.1 Referência de Funções e Operadores Integrados

A tabela a seguir lista cada função e operador integrado (nativo) e fornece uma breve descrição de cada um. Para uma tabela listando funções que podem ser carregadas em tempo de execução, consulte a Seção 12.2, “Referência de Funções Carregáveis”.

**Tabela 12.1 Funções e Operadores Integrados**

<table frame="box" rules="all" summary="Uma referência que lista todas as funções e operadores integrados."><col style="width: 22%"/><col style="width: 55%"/><col style="width: 11%"/><col style="width: 11%"/><thead><tr><th>Nome</th> <th>Descrição</th> <th>Introduzido</th> <th>Descontinuado</th> </tr></thead><tbody><tr><th><code>&amp;</code></th> <td> AND Bitwise </td> <td></td> <td></td> </tr><tr><th><code>&gt;</code></th> <td> Operador maior que </td> <td></td> <td></td> </tr><tr><th><code>&gt;&gt;</code></th> <td> Deslocamento para a direita </td> <td></td> <td></td> </tr><tr><th><code>&gt;=</code></th> <td> Operador maior ou igual a </td> <td></td> <td></td> </tr><tr><th><code>&lt;</code></th> <td> Operador menor que </td> <td></td> <td></td> </tr><tr><th><code>&lt;&gt;</code>, <code>!=</code></th> <td> Operador de desigualdade </td> <td></td> <td></td> </tr><tr><th><code>&lt;&lt;</code></th> <td> Deslocamento para a esquerda </td> <td></td> <td></td> </tr><tr><th><code>&lt;=</code></th> <td> Operador menor ou igual a </td> <td></td> <td></td> </tr><tr><th><code>&lt;=&gt;</code></th> <td> Operador de igualdade seguro contra NULL </td> <td></td> <td></td> </tr><tr><th><code>%</code>, <code>MOD</code></th> <td> Operador Módulo </td> <td></td> <td></td> </tr><tr><th><code>*</code></th> <td> Operador de multiplicação </td> <td></td> <td></td> </tr><tr><th><code>+</code></th> <td> Operador de adição </td> <td></td> <td></td> </tr><tr><th><code>-</code></th> <td> Operador de subtração </td> <td></td> <td></td> </tr><tr><th><code>-</code></th> <td> Inverte o sinal do argumento </td> <td></td> <td></td> </tr><tr><th><code>-&gt;</code></th> <td> Retorna o valor da coluna JSON após avaliar o path; equivalente a JSON_EXTRACT(). </td> <td></td> <td></td> </tr><tr><th><code>-&gt;&gt;</code></th> <td> Retorna o valor da coluna JSON após avaliar o path e remover as aspas do resultado; equivalente a JSON_UNQUOTE(JSON_EXTRACT()). </td> <td>5.7.13</td> <td></td> </tr><tr><th><code>/</code></th> <td> Operador de divisão </td> <td></td> <td></td> </tr><tr><th><code>:=</code></th> <td> Atribui um valor </td> <td></td> <td></td> </tr><tr><th><code>=</code></th> <td> Atribui um valor (como parte de uma instrução <code>SET</code>, ou como parte da cláusula <code>SET</code> em uma instrução <code>UPDATE</code>) </td> <td></td> <td></td> </tr><tr><th><code>=</code></th> <td> Operador de igualdade </td> <td></td> <td></td> </tr><tr><th><code>^</code></th> <td> XOR Bitwise </td> <td></td> <td></td> </tr><tr><th><code>ABS()</code></th> <td> Retorna o valor absoluto </td> <td></td> <td></td> </tr><tr><th><code>ACOS()</code></th> <td> Retorna o arco cosseno </td> <td></td> <td></td> </tr><tr><th><code>ADDDATE()</code></th> <td> Adiciona valores de tempo (intervalos) a um valor de data </td> <td></td> <td></td> </tr><tr><th><code>ADDTIME()</code></th> <td> Adiciona tempo </td> <td></td> <td></td> </tr><tr><th><code>AES_DECRYPT()</code></th> <td> Descriptografa usando AES </td> <td></td> <td></td> </tr><tr><th><code>AES_ENCRYPT()</code></th> <td> Criptografa usando AES </td> <td></td> <td></td> </tr><tr><th><code>AND</code>, <code>&amp;&amp;</code></th> <td> AND Lógico </td> <td></td> <td></td> </tr><tr><th><code>ANY_VALUE()</code></th> <td> Suprime a rejeição de valor ONLY_FULL_GROUP_BY </td> <td></td> <td></td> </tr><tr><th><code>Area()</code></th> <td> Retorna a área de Polygon ou MultiPolygon </td> <td></td> <td>Sim</td> </tr><tr><th><code>AsBinary()</code>, <code>AsWKB()</code></th> <td> Converte de formato de geometria interno para WKB </td> <td></td> <td>Sim</td> </tr><tr><th><code>ASCII()</code></th> <td> Retorna o valor numérico do caractere mais à esquerda </td> <td></td> <td></td> </tr><tr><th><code>ASIN()</code></th> <td> Retorna o arco seno </td> <td></td> <td></td> </tr><tr><th><code>AsText()</code>, <code>AsWKT()</code></th> <td> Converte de formato de geometria interno para WKT </td> <td></td> <td>Sim</td> </tr><tr><th><code>ATAN()</code></th> <td> Retorna o arco tangente </td> <td></td> <td></td> </tr><tr><th><code>ATAN2()</code>, <code>ATAN()</code></th> <td> Retorna o arco tangente dos dois argumentos </td> <td></td> <td></td> </tr><tr><th><code>AVG()</code></th> <td> Retorna o valor médio do argumento </td> <td></td> <td></td> </tr><tr><th><code>BENCHMARK()</code></th> <td> Executa uma expressão repetidamente </td> <td></td> <td></td> </tr><tr><th><code>BETWEEN ... AND ...</code></th> <td> Verifica se um valor está dentro de um intervalo de valores </td> <td></td> <td></td> </tr><tr><th><code>BIN()</code></th> <td> Retorna uma string contendo a representação binária de um número </td> <td></td> <td></td> </tr><tr><th><code>BINARY</code></th> <td> Converte uma string para uma string binária </td> <td></td> <td></td> </tr><tr><th><code>BIT_AND()</code></th> <td> Retorna AND Bitwise </td> <td></td> <td></td> </tr><tr><th><code>BIT_COUNT()</code></th> <td> Retorna o número de bits definidos </td> <td></td> <td></td> </tr><tr><th><code>BIT_LENGTH()</code></th> <td> Retorna o comprimento do argumento em bits </td> <td></td> <td></td> </tr><tr><th><code>BIT_OR()</code></th> <td> Retorna OR Bitwise </td> <td></td> <td></td> </tr><tr><th><code>BIT_XOR()</code></th> <td> Retorna XOR Bitwise </td> <td></td> <td></td> </tr><tr><th><code>Buffer()</code></th> <td> Retorna a geometria de pontos dentro de uma distância específica da geometria </td> <td></td> <td>Sim</td> </tr><tr><th><code>CASE</code></th> <td> Operador Case </td> <td></td> <td></td> </tr><tr><th><code>CAST()</code></th> <td> Converte um valor para um tipo específico </td> <td></td> <td></td> </tr><tr><th><code>CEIL()</code></th> <td> Retorna o menor valor inteiro não inferior ao argumento </td> <td></td> <td></td> </tr><tr><th><code>CEILING()</code></th> <td> Retorna o menor valor inteiro não inferior ao argumento </td> <td></td> <td></td> </tr><tr><th><code>Centroid()</code></th> <td> Retorna o centroide como um Point </td> <td></td> <td>Sim</td> </tr><tr><th><code>CHAR()</code></th> <td> Retorna o caractere para cada inteiro passado </td> <td></td> <td></td> </tr><tr><th><code>CHAR_LENGTH()</code></th> <td> Retorna o número de caracteres no argumento </td> <td></td> <td></td> </tr><tr><th><code>CHARACTER_LENGTH()</code></th> <td> Sinônimo para CHAR_LENGTH() </td> <td></td> <td></td> </tr><tr><th><code>CHARSET()</code></th> <td> Retorna o conjunto de caracteres do argumento </td> <td></td> <td></td> </tr><tr><th><code>COALESCE()</code></th> <td> Retorna o primeiro argumento não-NULL </td> <td></td> <td></td> </tr><tr><th><code>COERCIBILITY()</code></th> <td> Retorna o valor de coercibilidade da collation do argumento string </td> <td></td> <td></td> </tr><tr><th><code>COLLATION()</code></th> <td> Retorna a collation do argumento string </td> <td></td> <td></td> </tr><tr><th><code>COMPRESS()</code></th> <td> Retorna o resultado como uma string binária </td> <td></td> <td></td> </tr><tr><th><code>CONCAT()</code></th> <td> Retorna string concatenada </td> <td></td> <td></td> </tr><tr><th><code>CONCAT_WS()</code></th> <td> Retorna concatenação com separador </td> <td></td> <td></td> </tr><tr><th><code>CONNECTION_ID()</code></th> <td> Retorna o ID da conexão (Thread ID) para a conexão </td> <td></td> <td></td> </tr><tr><th><code>Contains()</code></th> <td> Verifica se o MBR de uma geometria contém o MBR de outra </td> <td></td> <td>Sim</td> </tr><tr><th><code>CONV()</code></th> <td> Converte números entre diferentes bases numéricas </td> <td></td> <td></td> </tr><tr><th><code>CONVERT()</code></th> <td> Converte um valor para um tipo específico </td> <td></td> <td></td> </tr><tr><th><code>CONVERT_TZ()</code></th> <td> Converte de um Time Zone para outro </td> <td></td> <td></td> </tr><tr><th><code>ConvexHull()</code></th> <td> Retorna o convex hull da geometria </td> <td></td> <td>Sim</td> </tr><tr><th><code>COS()</code></th> <td> Retorna o cosseno </td> <td></td> <td></td> </tr><tr><th><code>COT()</code></th> <td> Retorna a cotangente </td> <td></td> <td></td> </tr><tr><th><code>COUNT()</code></th> <td> Retorna uma contagem do número de linhas retornadas </td> <td></td> <td></td> </tr><tr><th><code>COUNT(DISTINCT)</code></th> <td> Retorna a contagem de um número de valores distintos </td> <td></td> <td></td> </tr><tr><th><code>CRC32()</code></th> <td> Calcula um valor de Cyclic Redundancy Check </td> <td></td> <td></td> </tr><tr><th><code>Crosses()</code></th> <td> Verifica se uma geometria cruza outra </td> <td></td> <td>Sim</td> </tr><tr><th><code>CURDATE()</code></th> <td> Retorna a data atual </td> <td></td> <td></td> </tr><tr><th><code>CURRENT_DATE()</code>, <code>CURRENT_DATE</code></th> <td> Sinônimos para CURDATE() </td> <td></td> <td></td> </tr><tr><th><code>CURRENT_TIME()</code>, <code>CURRENT_TIME</code></th> <td> Sinônimos para CURTIME() </td> <td></td> <td></td> </tr><tr><th><code>CURRENT_TIMESTAMP()</code>, <code>CURRENT_TIMESTAMP</code></th> <td> Sinônimos para NOW() </td> <td></td> <td></td> </tr><tr><th><code>CURRENT_USER()</code>, <code>CURRENT_USER</code></th> <td> O nome de usuário autenticado e o Host Name </td> <td></td> <td></td> </tr><tr><th><code>CURTIME()</code></th> <td> Retorna a hora atual </td> <td></td> <td></td> </tr><tr><th><code>DATABASE()</code></th> <td> Retorna o nome do Database padrão (atual) </td> <td></td> <td></td> </tr><tr><th><code>DATE()</code></th> <td> Extrai a parte da data de uma expressão de data ou datetime </td> <td></td> <td></td> </tr><tr><th><code>DATE_ADD()</code></th> <td> Adiciona valores de tempo (intervalos) a um valor de data </td> <td></td> <td></td> </tr><tr><th><code>DATE_FORMAT()</code></th> <td> Formata a data conforme especificado </td> <td></td> <td></td> </tr><tr><th><code>DATE_SUB()</code></th> <td> Subtrai um valor de tempo (intervalo) de uma data </td> <td></td> <td></td> </tr><tr><th><code>DATEDIFF()</code></th> <td> Subtrai duas datas </td> <td></td> <td></td> </tr><tr><th><code>DAY()</code></th> <td> Sinônimo para DAYOFMONTH() </td> <td></td> <td></td> </tr><tr><th><code>DAYNAME()</code></th> <td> Retorna o nome do dia da semana </td> <td></td> <td></td> </tr><tr><th><code>DAYOFMONTH()</code></th> <td> Retorna o dia do mês (0-31) </td> <td></td> <td></td> </tr><tr><th><code>DAYOFWEEK()</code></th> <td> Retorna o índice do dia da semana do argumento </td> <td></td> <td></td> </tr><tr><th><code>DAYOFYEAR()</code></th> <td> Retorna o dia do ano (1-366) </td> <td></td> <td></td> </tr><tr><th><code>DECODE()</code></th> <td> Decodifica uma string criptografada usando ENCODE() </td> <td></td> <td>Sim</td> </tr><tr><th><code>DEFAULT()</code></th> <td> Retorna o valor DEFAULT para uma coluna da tabela </td> <td></td> <td></td> </tr><tr><th><code>DEGREES()</code></th> <td> Converte radianos para graus </td> <td></td> <td></td> </tr><tr><th><code>DES_DECRYPT()</code></th> <td> Descriptografa uma string </td> <td></td> <td>Sim</td> </tr><tr><th><code>DES_ENCRYPT()</code></th> <td> Criptografa uma string </td> <td></td> <td>Sim</td> </tr><tr><th><code>Dimension()</code></th> <td> Dimensão da geometria </td> <td></td> <td>Sim</td> </tr><tr><th><code>Disjoint()</code></th> <td> Verifica se os MBRs de duas geometrias são disjuntos </td> <td></td> <td>Sim</td> </tr><tr><th><code>DIV</code></th> <td> Divisão de inteiro </td> <td></td> <td></td> </tr><tr><th><code>ELT()</code></th> <td> Retorna a string no número de índice </td> <td></td> <td></td> </tr><tr><th><code>ENCODE()</code></th> <td> Codifica uma string </td> <td></td> <td>Sim</td> </tr><tr><th><code>ENCRYPT()</code></th> <td> Criptografa uma string </td> <td></td> <td>Sim</td> </tr><tr><th><code>EndPoint()</code></th> <td> Ponto final (End Point) de uma LineString </td> <td></td> <td>Sim</td> </tr><tr><th><code>Envelope()</code></th> <td> Retorna o MBR da geometria </td> <td></td> <td>Sim</td> </tr><tr><th><code>Equals()</code></th> <td> Verifica se os MBRs de duas geometrias são iguais </td> <td></td> <td>Sim</td> </tr><tr><th><code>EXISTS()</code></th> <td> Verifica se o resultado de uma Query contém alguma linha </td> <td></td> <td></td> </tr><tr><th><code>EXP()</code></th> <td> Eleva à potência de </td> <td></td> <td></td> </tr><tr><th><code>EXPORT_SET()</code></th> <td> Retorna uma string tal que, para cada bit definido nos bits de valor, você obtém uma string 'on' e para cada bit não definido, você obtém uma string 'off' </td> <td></td> <td></td> </tr><tr><th><code>ExteriorRing()</code></th> <td> Retorna o anel exterior (Exterior Ring) de um Polygon </td> <td></td> <td>Sim</td> </tr><tr><th><code>EXTRACT()</code></th> <td> Extrai parte de uma data </td> <td></td> <td></td> </tr><tr><th><code>ExtractValue()</code></th> <td> Extrai um valor de uma string XML usando notação XPath </td> <td></td> <td></td> </tr><tr><th><code>FIELD()</code></th> <td> Índice (posição) do primeiro argumento nos argumentos subsequentes </td> <td></td> <td></td> </tr><tr><th><code>FIND_IN_SET()</code></th> <td> Índice (posição) do primeiro argumento dentro do segundo argumento </td> <td></td> <td></td> </tr><tr><th><code>FLOOR()</code></th> <td> Retorna o maior valor inteiro não maior que o argumento </td> <td></td> <td></td> </tr><tr><th><code>FORMAT()</code></th> <td> Retorna um número formatado para o número especificado de casas decimais </td> <td></td> <td></td> </tr><tr><th><code>FOUND_ROWS()</code></th> <td> Para um SELECT com uma cláusula LIMIT, o número de linhas que seriam retornadas se não houvesse a cláusula LIMIT </td> <td></td> <td></td> </tr><tr><th><code>FROM_BASE64()</code></th> <td> Decodifica string codificada em base64 e retorna o resultado </td> <td></td> <td></td> </tr><tr><th><code>FROM_DAYS()</code></th> <td> Converte um número de dia para uma data </td> <td></td> <td></td> </tr><tr><th><code>FROM_UNIXTIME()</code></th> <td> Formata o Unix timestamp como uma data </td> <td></td> <td></td> </tr><tr><th><code>GeomCollFromText()</code>, <code>GeometryCollectionFromText()</code></th> <td> Retorna a coleção de geometria de WKT </td> <td></td> <td>Sim</td> </tr><tr><th><code>GeomCollFromWKB()</code>, <code>GeometryCollectionFromWKB()</code></th> <td> Retorna a coleção de geometria de WKB </td> <td></td> <td>Sim</td> </tr><tr><th><code>GeometryCollection()</code></th> <td> Constrói coleção de geometria a partir de geometrias </td> <td></td> <td></td> </tr><tr><th><code>GeometryN()</code></th> <td> Retorna a N-ésima geometria da coleção de geometria </td> <td></td> <td>Sim</td> </tr><tr><th><code>GeometryType()</code></th> <td> Retorna o nome do tipo de geometria </td> <td></td> <td>Sim</td> </tr><tr><th><code>GeomFromText()</code>, <code>GeometryFromText()</code></th> <td> Retorna a geometria de WKT </td> <td></td> <td>Sim</td> </tr><tr><th><code>GeomFromWKB()</code>, <code>GeometryFromWKB()</code></th> <td> Retorna a geometria de WKB </td> <td></td> <td>Sim</td> </tr><tr><th><code>GET_FORMAT()</code></th> <td> Retorna uma string de formato de data </td> <td></td> <td></td> </tr><tr><th><code>GET_LOCK()</code></th> <td> Obtém um Lock nomeado </td> <td></td> <td></td> </tr><tr><th><code>GLength()</code></th> <td> Retorna o comprimento da LineString </td> <td></td> <td>Sim</td> </tr><tr><th><code>GREATEST()</code></th> <td> Retorna o maior argumento </td> <td></td> <td></td> </tr><tr><th><code>GROUP_CONCAT()</code></th> <td> Retorna uma string concatenada </td> <td></td> <td></td> </tr><tr><th><code>GTID_SUBSET()</code></th> <td> Retorna true se todos os GTIDs no subconjunto também estiverem no conjunto; caso contrário, false. </td> <td></td> <td></td> </tr><tr><th><code>GTID_SUBTRACT()</code></th> <td> Retorna todos os GTIDs no conjunto que não estão no subconjunto. </td> <td></td> <td></td> </tr><tr><th><code>HEX()</code></th> <td> Representação hexadecimal de valor decimal ou string </td> <td></td> <td></td> </tr><tr><th><code>HOUR()</code></th> <td> Extrai a hora </td> <td></td> <td></td> </tr><tr><th><code>IF()</code></th> <td> Construção If/else </td> <td></td> <td></td> </tr><tr><th><code>IFNULL()</code></th> <td> Construção If/else de NULL </td> <td></td> <td></td> </tr><tr><th><code>IN()</code></th> <td> Verifica se um valor está dentro de um conjunto de valores </td> <td></td> <td></td> </tr><tr><th><code>INET_ATON()</code></th> <td> Retorna o valor numérico de um endereço IP </td> <td></td> <td></td> </tr><tr><th><code>INET_NTOA()</code></th> <td> Retorna o endereço IP a partir de um valor numérico </td> <td></td> <td></td> </tr><tr><th><code>INET6_ATON()</code></th> <td> Retorna o valor numérico de um endereço IPv6 </td> <td></td> <td></td> </tr><tr><th><code>INET6_NTOA()</code></th> <td> Retorna o endereço IPv6 a partir de um valor numérico </td> <td></td> <td></td> </tr><tr><th><code>INSERT()</code></th> <td> Insere substring na posição especificada até o número de caracteres especificado </td> <td></td> <td></td> </tr><tr><th><code>INSTR()</code></th> <td> Retorna o índice da primeira ocorrência da substring </td> <td></td> <td></td> </tr><tr><th><code>InteriorRingN()</code></th> <td> Retorna o N-ésimo anel interior de um Polygon </td> <td></td> <td>Sim</td> </tr><tr><th><code>Intersects()</code></th> <td> Verifica se os MBRs de duas geometrias se interceptam </td> <td></td> <td>Sim</td> </tr><tr><th><code>INTERVAL()</code></th> <td> Retorna o índice do argumento que é menor que o primeiro argumento </td> <td></td> <td></td> </tr><tr><th><code>IS</code></th> <td> Testa um valor contra um booleano </td> <td></td> <td></td> </tr><tr><th><code>IS_FREE_LOCK()</code></th> <td> Verifica se o Lock nomeado está livre </td> <td></td> <td></td> </tr><tr><th><code>IS_IPV4()</code></th> <td> Verifica se o argumento é um endereço IPv4 </td> <td></td> <td></td> </tr><tr><th><code>IS_IPV4_COMPAT()</code></th> <td> Verifica se o argumento é um endereço compatível com IPv4 </td> <td></td> <td></td> </tr><tr><th><code>IS_IPV4_MAPPED()</code></th> <td> Verifica se o argumento é um endereço mapeado para IPv4 </td> <td></td> <td></td> </tr><tr><th><code>IS_IPV6()</code></th> <td> Verifica se o argumento é um endereço IPv6 </td> <td></td> <td></td> </tr><tr><th><code>IS NOT</code></th> <td> Testa um valor contra um booleano </td> <td></td> <td></td> </tr><tr><th><code>IS NOT NULL</code></th> <td> Teste de valor NOT NULL </td> <td></td> <td></td> </tr><tr><th><code>IS NULL</code></th> <td> Teste de valor NULL </td> <td></td> <td></td> </tr><tr><th><code>IS_USED_LOCK()</code></th> <td> Verifica se o Lock nomeado está em uso; retorna o identificador de conexão se for true </td> <td></td> <td></td> </tr><tr><th><code>IsClosed()</code></th> <td> Verifica se uma geometria é fechada e simples </td> <td></td> <td>Sim</td> </tr><tr><th><code>IsEmpty()</code></th> <td> Verifica se uma geometria está vazia </td> <td></td> <td>Sim</td> </tr><tr><th><code>ISNULL()</code></th> <td> Testa se o argumento é NULL </td> <td></td> <td></td> </tr><tr><th><code>IsSimple()</code></th> <td> Verifica se uma geometria é simples </td> <td></td> <td>Sim</td> </tr><tr><th><code>JSON_APPEND()</code></th> <td> Anexa dados a um documento JSON </td> <td></td> <td>Sim</td> </tr><tr><th><code>JSON_ARRAY()</code></th> <td> Cria um Array JSON </td> <td></td> <td></td> </tr><tr><th><code>JSON_ARRAY_APPEND()</code></th> <td> Anexa dados a um documento JSON </td> <td></td> <td></td> </tr><tr><th><code>JSON_ARRAY_INSERT()</code></th> <td> Insere em um Array JSON </td> <td></td> <td></td> </tr><tr><th><code>JSON_ARRAYAGG()</code></th> <td> Retorna o conjunto de resultados como um único Array JSON </td> <td>5.7.22</td> <td></td> </tr><tr><th><code>JSON_CONTAINS()</code></th> <td> Verifica se o documento JSON contém um objeto específico no path </td> <td></td> <td></td> </tr><tr><th><code>JSON_CONTAINS_PATH()</code></th> <td> Verifica se o documento JSON contém algum dado no path </td> <td></td> <td></td> </tr><tr><th><code>JSON_DEPTH()</code></th> <td> Profundidade máxima do documento JSON </td> <td></td> <td></td> </tr><tr><th><code>JSON_EXTRACT()</code></th> <td> Retorna dados do documento JSON </td> <td></td> <td></td> </tr><tr><th><code>JSON_INSERT()</code></th> <td> Insere dados no documento JSON </td> <td></td> <td></td> </tr><tr><th><code>JSON_KEYS()</code></th> <td> Array de Keys de um documento JSON </td> <td></td> <td></td> </tr><tr><th><code>JSON_LENGTH()</code></th> <td> Número de elementos no documento JSON </td> <td></td> <td></td> </tr><tr><th><code>JSON_MERGE()</code></th> <td> Mescla documentos JSON, preservando Keys duplicadas. Sinônimo descontinuado para JSON_MERGE_PRESERVE() </td> <td></td> <td>5.7.22</td> </tr><tr><th><code>JSON_MERGE_PATCH()</code></th> <td> Mescla documentos JSON, substituindo valores de Keys duplicadas </td> <td>5.7.22</td> <td></td> </tr><tr><th><code>JSON_MERGE_PRESERVE()</code></th> <td> Mescla documentos JSON, preservando Keys duplicadas </td> <td>5.7.22</td> <td></td> </tr><tr><th><code>JSON_OBJECT()</code></th> <td> Cria um Objeto JSON </td> <td></td> <td></td> </tr><tr><th><code>JSON_OBJECTAGG()</code></th> <td> Retorna o conjunto de resultados como um único Objeto JSON </td> <td>5.7.22</td> <td></td> </tr><tr><th><code>JSON_PRETTY()</code></th> <td> Imprime um documento JSON em formato legível por humanos </td> <td>5.7.22</td> <td></td> </tr><tr><th><code>JSON_QUOTE()</code></th> <td> Adiciona aspas ao documento JSON </td> <td></td> <td></td> </tr><tr><th><code>JSON_REMOVE()</code></th> <td> Remove dados de um documento JSON </td> <td></td> <td></td> </tr><tr><th><code>JSON_REPLACE()</code></th> <td> Substitui valores em um documento JSON </td> <td></td> <td></td> </tr><tr><th><code>JSON_SEARCH()</code></th> <td> Path para o valor dentro do documento JSON </td> <td></td> <td></td> </tr><tr><th><code>JSON_SET()</code></th> <td> Insere dados no documento JSON </td> <td></td> <td></td> </tr><tr><th><code>JSON_STORAGE_SIZE()</code></th> <td> Espaço usado para armazenamento da representação binária de um documento JSON </td> <td>5.7.22</td> <td></td> </tr><tr><th><code>JSON_TYPE()</code></th> <td> Tipo de valor JSON </td> <td></td> <td></td> </tr><tr><th><code>JSON_UNQUOTE()</code></th> <td> Remove aspas do valor JSON </td> <td></td> <td></td> </tr><tr><th><code>JSON_VALID()</code></th> <td> Verifica se o valor JSON é válido </td> <td></td> <td></td> </tr><tr><th><code>LAST_DAY</code></th> <td> Retorna o último dia do mês para o argumento </td> <td></td> <td></td> </tr><tr><th><code>LAST_INSERT_ID()</code></th> <td> Valor da coluna AUTOINCREMENT para o último INSERT </td> <td></td> <td></td> </tr><tr><th><code>LCASE()</code></th> <td> Sinônimo para LOWER() </td> <td></td> <td></td> </tr><tr><th><code>LEAST()</code></th> <td> Retorna o menor argumento </td> <td></td> <td></td> </tr><tr><th><code>LEFT()</code></th> <td> Retorna o número de caracteres mais à esquerda conforme especificado </td> <td></td> <td></td> </tr><tr><th><code>LENGTH()</code></th> <td> Retorna o comprimento de uma string em bytes </td> <td></td> <td></td> </tr><tr><th><code>LIKE</code></th> <td> Correspondência de padrão simples (pattern matching) </td> <td></td> <td></td> </tr><tr><th><code>LineFromText()</code>, <code>LineStringFromText()</code></th> <td> Constrói LineString a partir de WKT </td> <td></td> <td>Sim</td> </tr><tr><th><code>LineFromWKB()</code>, <code>LineStringFromWKB()</code></th> <td> Constrói LineString a partir de WKB </td> <td></td> <td>Sim</td> </tr><tr><th><code>LineString()</code></th> <td> Constrói LineString a partir de valores Point </td> <td></td> <td></td> </tr><tr><th><code>LN()</code></th> <td> Retorna o logaritmo natural do argumento </td> <td></td> <td></td> </tr><tr><th><code>LOAD_FILE()</code></th> <td> Carrega o arquivo nomeado </td> <td></td> <td></td> </tr><tr><th><code>LOCALTIME()</code>, <code>LOCALTIME</code></th> <td> Sinônimo para NOW() </td> <td></td> <td></td> </tr><tr><th><code>LOCALTIMESTAMP</code>, <code>LOCALTIMESTAMP()</code></th> <td> Sinônimo para NOW() </td> <td></td> <td></td> </tr><tr><th><code>LOCATE()</code></th> <td> Retorna a posição da primeira ocorrência da substring </td> <td></td> <td></td> </tr><tr><th><code>LOG()</code></th> <td> Retorna o logaritmo natural do primeiro argumento </td> <td></td> <td></td> </tr><tr><th><code>LOG10()</code></th> <td> Retorna o logaritmo de base 10 do argumento </td> <td></td> <td></td> </tr><tr><th><code>LOG2()</code></th> <td> Retorna o logaritmo de base 2 do argumento </td> <td></td> <td></td> </tr><tr><th><code>LOWER()</code></th> <td> Retorna o argumento em letras minúsculas </td> <td></td> <td></td> </tr><tr><th><code>LPAD()</code></th> <td> Retorna o argumento string, preenchido à esquerda com a string especificada </td> <td></td> <td></td> </tr><tr><th><code>LTRIM()</code></th> <td> Remove espaços à esquerda </td> <td></td> <td></td> </tr><tr><th><code>MAKE_SET()</code></th> <td> Retorna um set de strings separadas por vírgulas que têm o bit correspondente definido em bits </td> <td></td> <td></td> </tr><tr><th><code>MAKEDATE()</code></th> <td> Cria uma data a partir do ano e do dia do ano </td> <td></td> <td></td> </tr><tr><th><code>MAKETIME()</code></th> <td> Cria hora a partir de hora, minuto, segundo </td> <td></td> <td></td> </tr><tr><th><code>MASTER_POS_WAIT()</code></th> <td> Bloqueia até que a réplica tenha lido e aplicado todas as atualizações até a posição especificada </td> <td></td> <td></td> </tr><tr><th><code>MATCH()</code></th> <td> Executa busca Full-Text </td> <td></td> <td></td> </tr><tr><th><code>MAX()</code></th> <td> Retorna o valor máximo </td> <td></td> <td></td> </tr><tr><th><code>MBRContains()</code></th> <td> Verifica se o MBR de uma geometria contém o MBR de outra </td> <td></td> <td></td> </tr><tr><th><code>MBRCoveredBy()</code></th> <td> Verifica se um MBR é coberto por outro </td> <td></td> <td></td> </tr><tr><th><code>MBRCovers()</code></th> <td> Verifica se um MBR cobre outro </td> <td></td> <td></td> </tr><tr><th><code>MBRDisjoint()</code></th> <td> Verifica se os MBRs de duas geometrias são disjuntos </td> <td></td> <td></td> </tr><tr><th><code>MBREqual()</code></th> <td> Verifica se os MBRs de duas geometrias são iguais </td> <td></td> <td>Sim</td> </tr><tr><th><code>MBREquals()</code></th> <td> Verifica se os MBRs de duas geometrias são iguais </td> <td></td> <td></td> </tr><tr><th><code>MBRIntersects()</code></th> <td> Verifica se os MBRs de duas geometrias se interceptam </td> <td></td> <td></td> </tr><tr><th><code>MBROverlaps()</code></th> <td> Verifica se os MBRs de duas geometrias se sobrepõem </td> <td></td> <td></td> </tr><tr><th><code>MBRTouches()</code></th> <td> Verifica se os MBRs de duas geometrias se tocam </td> <td></td> <td></td> </tr><tr><th><code>MBRWithin()</code></th> <td> Verifica se o MBR de uma geometria está dentro do MBR de outra </td> <td></td> <td></td> </tr><tr><th><code>MD5()</code></th> <td> Calcula o Checksum MD5 </td> <td></td> <td></td> </tr><tr><th><code>MICROSECOND()</code></th> <td> Retorna os microssegundos do argumento </td> <td></td> <td></td> </tr><tr><th><code>MID()</code></th> <td> Retorna uma substring começando da posição especificada </td> <td></td> <td></td> </tr><tr><th><code>MIN()</code></th> <td> Retorna o valor mínimo </td> <td></td> <td></td> </tr><tr><th><code>MINUTE()</code></th> <td> Retorna o minuto do argumento </td> <td></td> <td></td> </tr><tr><th><code>MLineFromText()</code>, <code>MultiLineStringFromText()</code></th> <td> Constrói MultiLineString a partir de WKT </td> <td></td> <td>Sim</td> </tr><tr><th><code>MLineFromWKB()</code>, <code>MultiLineStringFromWKB()</code></th> <td> Constrói MultiLineString a partir de WKB </td> <td></td> <td>Sim</td> </tr><tr><th><code>MOD()</code></th> <td> Retorna o resto </td> <td></td> <td></td> </tr><tr><th><code>MONTH()</code></th> <td> Retorna o mês da data passada </td> <td></td> <td></td> </tr><tr><th><code>MONTHNAME()</code></th> <td> Retorna o nome do mês </td> <td></td> <td></td> </tr><tr><th><code>MPointFromText()</code>, <code>MultiPointFromText()</code></th> <td> Constrói MultiPoint a partir de WKT </td> <td></td> <td>Sim</td> </tr><tr><th><code>MPointFromWKB()</code>, <code>MultiPointFromWKB()</code></th> <td> Constrói MultiPoint a partir de WKB </td> <td></td> <td>Sim</td> </tr><tr><th><code>MPolyFromText()</code>, <code>MultiPolygonFromText()</code></th> <td> Constrói MultiPolygon a partir de WKT </td> <td></td> <td>Sim</td> </tr><tr><th><code>MPolyFromWKB()</code>, <code>MultiPolygonFromWKB()</code></th> <td> Constrói MultiPolygon a partir de WKB </td> <td></td> <td>Sim</td> </tr><tr><th><code>MultiLineString()</code></th> <td> Constrói MultiLineString a partir de valores LineString </td> <td></td> <td></td> </tr><tr><th><code>MultiPoint()</code></th> <td> Constrói MultiPoint a partir de valores Point </td> <td></td> <td></td> </tr><tr><th><code>MultiPolygon()</code></th> <td> Constrói MultiPolygon a partir de valores Polygon </td> <td></td> <td></td> </tr><tr><th><code>NAME_CONST()</code></th> <td> Faz com que a coluna tenha o nome fornecido </td> <td></td> <td></td> </tr><tr><th><code>NOT</code>, <code>!</code></th> <td> Nega o valor </td> <td></td> <td></td> </tr><tr><th><code>NOT BETWEEN ... AND ...</code></th> <td> Verifica se um valor não está dentro de um intervalo de valores </td> <td></td> <td></td> </tr><tr><th><code>NOT EXISTS()</code></th> <td> Verifica se o resultado de uma Query não contém linhas </td> <td></td> <td></td> </tr><tr><th><code>NOT IN()</code></th> <td> Verifica se um valor não está dentro de um conjunto de valores </td> <td></td> <td></td> </tr><tr><th><code>NOT LIKE</code></th> <td> Negação da correspondência de padrão simples </td> <td></td> <td></td> </tr><tr><th><code>NOT REGEXP</code></th> <td> Negação de REGEXP </td> <td></td> <td></td> </tr><tr><th><code>NOW()</code></th> <td> Retorna a data e hora atuais </td> <td></td> <td></td> </tr><tr><th><code>NULLIF()</code></th> <td> Retorna NULL se expr1 = expr2 </td> <td></td> <td></td> </tr><tr><th><code>NumGeometries()</code></th> <td> Retorna o número de geometrias na coleção de geometria </td> <td></td> <td>Sim</td> </tr><tr><th><code>NumInteriorRings()</code></th> <td> Retorna o número de anéis interiores em um Polygon </td> <td></td> <td>Sim</td> </tr><tr><th><code>NumPoints()</code></th> <td> Retorna o número de Points em uma LineString </td> <td></td> <td>Sim</td> </tr><tr><th><code>OCT()</code></th> <td> Retorna uma string contendo a representação octal de um número </td> <td></td> <td></td> </tr><tr><th><code>OCTET_LENGTH()</code></th> <td> Sinônimo para LENGTH() </td> <td></td> <td></td> </tr><tr><th><code>OR</code>, <code>||</code></th> <td> OR Lógico </td> <td></td> <td></td> </tr><tr><th><code>ORD()</code></th> <td> Retorna o código do caractere para o caractere mais à esquerda do argumento </td> <td></td> <td></td> </tr><tr><th><code>Overlaps()</code></th> <td> Verifica se os MBRs de duas geometrias se sobrepõem </td> <td></td> <td>Sim</td> </tr><tr><th><code>PASSWORD()</code></th> <td> Calcula e retorna uma string de Password </td> <td></td> <td>Sim</td> </tr><tr><th><code>PERIOD_ADD()</code></th> <td> Adiciona um período a um ano-mês </td> <td></td> <td></td> </tr><tr><th><code>PERIOD_DIFF()</code></th> <td> Retorna o número de meses entre períodos </td> <td></td> <td></td> </tr><tr><th><code>PI()</code></th> <td> Retorna o valor de pi </td> <td></td> <td></td> </tr><tr><th><code>Point()</code></th> <td> Constrói Point a partir de coordenadas </td> <td></td> <td></td> </tr><tr><th><code>PointFromText()</code></th> <td> Constrói Point a partir de WKT </td> <td></td> <td>Sim</td> </tr><tr><th><code>PointFromWKB()</code></th> <td> Constrói Point a partir de WKB </td> <td></td> <td>Sim</td> </tr><tr><th><code>PointN()</code></th> <td> Retorna o N-ésimo Point de uma LineString </td> <td></td> <td>Sim</td> </tr><tr><th><code>PolyFromText()</code>, <code>PolygonFromText()</code></th> <td> Constrói Polygon a partir de WKT </td> <td></td> <td>Sim</td> </tr><tr><th><code>PolyFromWKB()</code>, <code>PolygonFromWKB()</code></th> <td> Constrói Polygon a partir de WKB </td> <td></td> <td>Sim</td> </tr><tr><th><code>Polygon()</code></th> <td> Constrói Polygon a partir de argumentos LineString </td> <td></td> <td></td> </tr><tr><th><code>POSITION()</code></th> <td> Sinônimo para LOCATE() </td> <td></td> <td></td> </tr><tr><th><code>POW()</code></th> <td> Retorna o argumento elevado à potência especificada </td> <td></td> <td></td> </tr><tr><th><code>POWER()</code></th> <td> Retorna o argumento elevado à potência especificada </td> <td></td> <td></td> </tr><tr><th><code>PROCEDURE ANALYSE()</code></th> <td> Analisa os resultados de uma Query </td> <td></td> <td>5.7.18</td> </tr><tr><th><code>QUARTER()</code></th> <td> Retorna o Quarter de um argumento de data </td> <td></td> <td></td> </tr><tr><th><code>QUOTE()</code></th> <td> Escapa o argumento para uso em uma instrução SQL </td> <td></td> <td></td> </tr><tr><th><code>RADIANS()</code></th> <td> Retorna o argumento convertido em radianos </td> <td></td> <td></td> </tr><tr><th><code>RAND()</code></th> <td> Retorna um valor de ponto flutuante aleatório </td> <td></td> <td></td> </tr><tr><th><code>RANDOM_BYTES()</code></th> <td> Retorna um vetor de bytes aleatório </td> <td></td> <td></td> </tr><tr><th><code>REGEXP</code></th> <td> Verifica se a string corresponde à expressão regular </td> <td></td> <td></td> </tr><tr><th><code>RELEASE_ALL_LOCKS()</code></th> <td> Libera todos os Locks nomeados atuais </td> <td></td> <td></td> </tr><tr><th><code>RELEASE_LOCK()</code></th> <td> Libera o Lock nomeado </td> <td></td> <td></td> </tr><tr><th><code>REPEAT()</code></th> <td> Repete uma string o número de vezes especificado </td> <td></td> <td></td> </tr><tr><th><code>REPLACE()</code></th> <td> Substitui ocorrências de uma string especificada </td> <td></td> <td></td> </tr><tr><th><code>REVERSE()</code></th> <td> Inverte os caracteres em uma string </td> <td></td> <td></td> </tr><tr><th><code>RIGHT()</code></th> <td> Retorna o número especificado de caracteres mais à direita </td> <td></td> <td></td> </tr><tr><th><code>RLIKE</code></th> <td> Verifica se a string corresponde à expressão regular </td> <td></td> <td></td> </tr><tr><th><code>ROUND()</code></th> <td> Arredonda o argumento </td> <td></td> <td></td> </tr><tr><th><code>ROW_COUNT()</code></th> <td> O número de linhas atualizadas </td> <td></td> <td></td> </tr><tr><th><code>RPAD()</code></th> <td> Anexa a string o número de vezes especificado </td> <td></td> <td></td> </tr><tr><th><code>RTRIM()</code></th> <td> Remove espaços à direita </td> <td></td> <td></td> </tr><tr><th><code>SCHEMA()</code></th> <td> Sinônimo para DATABASE() </td> <td></td> <td></td> </tr><tr><th><code>SEC_TO_TIME()</code></th> <td> Converte segundos para o formato 'hh:mm:ss' </td> <td></td> <td></td> </tr><tr><th><code>SECOND()</code></th> <td> Retorna o segundo (0-59) </td> <td></td> <td></td> </tr><tr><th><code>SESSION_USER()</code></th> <td> Sinônimo para USER() </td> <td></td> <td></td> </tr><tr><th><code>SHA1()</code>, <code>SHA()</code></th> <td> Calcula um Checksum SHA-1 de 160 bits </td> <td></td> <td></td> </tr><tr><th><code>SHA2()</code></th> <td> Calcula um Checksum SHA-2 </td> <td></td> <td></td> </tr><tr><th><code>SIGN()</code></th> <td> Retorna o sinal do argumento </td> <td></td> <td></td> </tr><tr><th><code>SIN()</code></th> <td> Retorna o seno do argumento </td> <td></td> <td></td> </tr><tr><th><code>SLEEP()</code></th> <td> Dorme por um número de segundos </td> <td></td> <td></td> </tr><tr><th><code>SOUNDEX()</code></th> <td> Retorna uma string Soundex </td> <td></td> <td></td> </tr><tr><th><code>SOUNDS LIKE</code></th> <td> Compara sons </td> <td></td> <td></td> </tr><tr><th><code>SPACE()</code></th> <td> Retorna uma string com o número especificado de espaços </td> <td></td> <td></td> </tr><tr><th><code>Distance()</code></th> <td> A distância de uma geometria para outra </td> <td></td> <td>Sim</td> </tr><tr><th><code>SQRT()</code></th> <td> Retorna a raiz quadrada do argumento </td> <td></td> <td></td> </tr><tr><th><code>SRID()</code></th> <td> Retorna o ID do sistema de referência espacial (SRID) para geometria </td> <td></td> <td>Sim</td> </tr><tr><th><code>ST_Area()</code></th> <td> Retorna a área de Polygon ou MultiPolygon </td> <td></td> <td></td> </tr><tr><th><code>ST_AsBinary()</code>, <code>ST_AsWKB()</code></th> <td> Converte de formato de geometria interno para WKB </td> <td></td> <td></td> </tr><tr><th><code>ST_AsGeoJSON()</code></th> <td> Gera Objeto GeoJSON a partir de geometria </td> <td></td> <td></td> </tr><tr><th><code>ST_AsText()</code>, <code>ST_AsWKT()</code></th> <td> Converte de formato de geometria interno para WKT </td> <td></td> <td></td> </tr><tr><th><code>ST_Buffer()</code></th> <td> Retorna a geometria de pontos dentro de uma distância específica da geometria </td> <td></td> <td></td> </tr><tr><th><code>ST_Buffer_Strategy()</code></th> <td> Produz a opção de Strategy para ST_Buffer() </td> <td></td> <td></td> </tr><tr><th><code>ST_Centroid()</code></th> <td> Retorna o centroide como um Point </td> <td></td> <td></td> </tr><tr><th><code>ST_Contains()</code></th> <td> Verifica se uma geometria contém outra </td> <td></td> <td></td> </tr><tr><th><code>ST_ConvexHull()</code></th> <td> Retorna o convex hull da geometria </td> <td></td> <td></td> </tr><tr><th><code>ST_Crosses()</code></th> <td> Verifica se uma geometria cruza outra </td> <td></td> <td></td> </tr><tr><th><code>ST_Difference()</code></th> <td> Retorna a diferença do conjunto de Points de duas geometrias </td> <td></td> <td></td> </tr><tr><th><code>ST_Dimension()</code></th> <td> Dimensão da geometria </td> <td></td> <td></td> </tr><tr><th><code>ST_Disjoint()</code></th> <td> Verifica se uma geometria é disjunta de outra </td> <td></td> <td></td> </tr><tr><th><code>ST_Distance()</code></th> <td> A distância de uma geometria para outra </td> <td></td> <td></td> </tr><tr><th><code>ST_Distance_Sphere()</code></th> <td> Distância mínima na Terra entre duas geometrias </td> <td></td> <td></td> </tr><tr><th><code>ST_EndPoint()</code></th> <td> Ponto final (End Point) de uma LineString </td> <td></td> <td></td> </tr><tr><th><code>ST_Envelope()</code></th> <td> Retorna o MBR da geometria </td> <td></td> <td></td> </tr><tr><th><code>ST_Equals()</code></th> <td> Verifica se uma geometria é igual a outra </td> <td></td> <td></td> </tr><tr><th><code>ST_ExteriorRing()</code></th> <td> Retorna o anel exterior (Exterior Ring) de um Polygon </td> <td></td> <td></td> </tr><tr><th><code>ST_GeoHash()</code></th> <td> Produz um valor geohash </td> <td></td> <td></td> </tr><tr><th><code>ST_GeomCollFromText()</code>, <code>ST_GeometryCollectionFromText()</code>, <code>ST_GeomCollFromTxt()</code></th> <td> Retorna a coleção de geometria de WKT </td> <td></td> <td></td> </tr><tr><th><code>ST_GeomCollFromWKB()</code>, <code>ST_GeometryCollectionFromWKB()</code></th> <td> Retorna a coleção de geometria de WKB </td> <td></td> <td></td> </tr><tr><th><code>ST_GeometryN()</code></th> <td> Retorna a N-ésima geometria da coleção de geometria </td> <td></td> <td></td> </tr><tr><th><code>ST_GeometryType()</code></th> <td> Retorna o nome do tipo de geometria </td> <td></td> <td></td> </tr><tr><th><code>ST_GeomFromGeoJSON()</code></th> <td> Gera geometria a partir de um Objeto GeoJSON </td> <td></td> <td></td> </tr><tr><th><code>ST_GeomFromText()</code>, <code>ST_GeometryFromText()</code></th> <td> Retorna a geometria de WKT </td> <td></td> <td></td> </tr><tr><th><code>ST_GeomFromWKB()</code>, <code>ST_GeometryFromWKB()</code></th> <td> Retorna a geometria de WKB </td> <td></td> <td></td> </tr><tr><th><code>ST_InteriorRingN()</code></th> <td> Retorna o N-ésimo anel interior de um Polygon </td> <td></td> <td></td> </tr><tr><th><code>ST_Intersection()</code></th> <td> Retorna a intersecção do conjunto de Points de duas geometrias </td> <td></td> <td></td> </tr><tr><th><code>ST_Intersects()</code></th> <td> Verifica se uma geometria intercepta outra </td> <td></td> <td></td> </tr><tr><th><code>ST_IsClosed()</code></th> <td> Verifica se uma geometria é fechada e simples </td> <td></td> <td></td> </tr><tr><th><code>ST_IsEmpty()</code></th> <td> Verifica se uma geometria está vazia </td> <td></td> <td></td> </tr><tr><th><code>ST_IsSimple()</code></th> <td> Verifica se uma geometria é simples </td> <td></td> <td></td> </tr><tr><th><code>ST_IsValid()</code></th> <td> Verifica se uma geometria é válida </td> <td></td> <td></td> </tr><tr><th><code>ST_LatFromGeoHash()</code></th> <td> Retorna a latitude do valor geohash </td> <td></td> <td></td> </tr><tr><th><code>ST_Length()</code></th> <td> Retorna o comprimento da LineString </td> <td></td> <td></td> </tr><tr><th><code>ST_LineFromText()</code>, <code>ST_LineStringFromText()</code></th> <td> Constrói LineString a partir de WKT </td> <td></td> <td></td> </tr><tr><th><code>ST_LineFromWKB()</code>, <code>ST_LineStringFromWKB()</code></th> <td> Constrói LineString a partir de WKB </td> <td></td> <td></td> </tr><tr><th><code>ST_LongFromGeoHash()</code></th> <td> Retorna a longitude do valor geohash </td> <td></td> <td></td> </tr><tr><th><code>ST_MakeEnvelope()</code></th> <td> Retângulo ao redor de dois Points </td> <td></td> <td></td> </tr><tr><th><code>ST_MLineFromText()</code>, <code>ST_MultiLineStringFromText()</code></th> <td> Constrói MultiLineString a partir de WKT </td> <td></td> <td></td> </tr><tr><th><code>ST_MLineFromWKB()</code>, <code>ST_MultiLineStringFromWKB()</code></th> <td> Constrói MultiLineString a partir de WKB </td> <td></td> <td></td> </tr><tr><th><code>ST_MPointFromText()</code>, <code>ST_MultiPointFromText()</code></th> <td> Constrói MultiPoint a partir de WKT </td> <td></td> <td></td> </tr><tr><th><code>ST_MPointFromWKB()</code>, <code>ST_MultiPointFromWKB()</code></th> <td> Constrói MultiPoint a partir de WKB </td> <td></td> <td></td> </tr><tr><th><code>ST_MPolyFromText()</code>, <code>ST_MultiPolygonFromText()</code></th> <td> Constrói MultiPolygon a partir de WKT </td> <td></td> <td></td> </tr><tr><th><code>ST_MPolyFromWKB()</code>, <code>ST_MultiPolygonFromWKB()</code></th> <td> Constrói MultiPolygon a partir de WKB </td> <td></td> <td></td> </tr><tr><th><code>ST_NumGeometries()</code></th> <td> Retorna o número de geometrias na coleção de geometria </td> <td></td> <td></td> </tr><tr><th><code>ST_NumInteriorRing()</code>, <code>ST_NumInteriorRings()</code></th> <td> Retorna o número de anéis interiores em um Polygon </td> <td></td> <td></td> </tr><tr><th><code>ST_NumPoints()</code></th> <td> Retorna o número de Points em uma LineString </td> <td></td> <td></td> </tr><tr><th><code>ST_Overlaps()</code></th> <td> Verifica se uma geometria se sobrepõe a outra </td> <td></td> <td></td> </tr><tr><th><code>ST_PointFromGeoHash()</code></th> <td> Converte o valor geohash para valor POINT </td> <td></td> <td></td> </tr><tr><th><code>ST_PointFromText()</code></th> <td> Constrói Point a partir de WKT </td> <td></td> <td></td> </tr><tr><th><code>ST_PointFromWKB()</code></th> <td> Constrói Point a partir de WKB </td> <td></td> <td></td> </tr><tr><th><code>ST_PointN()</code></th> <td> Retorna o N-ésimo Point de uma LineString </td> <td></td> <td></td> </tr><tr><th><code>ST_PolyFromText()</code>, <code>ST_PolygonFromText()</code></th> <td> Constrói Polygon a partir de WKT </td> <td></td> <td></td> </tr><tr><th><code>ST_PolyFromWKB()</code>, <code>ST_PolygonFromWKB()</code></th> <td> Constrói Polygon a partir de WKB </td> <td></td> <td></td> </tr><tr><th><code>ST_Simplify()</code></th> <td> Retorna geometria simplificada </td> <td></td> <td></td> </tr><tr><th><code>ST_SRID()</code></th> <td> Retorna o ID do sistema de referência espacial (SRID) para geometria </td> <td></td> <td></td> </tr><tr><th><code>ST_StartPoint()</code></th> <td> Ponto Inicial (Start Point) de uma LineString </td> <td></td> <td></td> </tr><tr><th><code>ST_SymDifference()</code></th> <td> Retorna a diferença simétrica do conjunto de Points de duas geometrias </td> <td></td> <td></td> </tr><tr><th><code>ST_Touches()</code></th> <td> Verifica se uma geometria toca outra </td> <td></td> <td></td> </tr><tr><th><code>ST_Union()</code></th> <td> Retorna a união do conjunto de Points de duas geometrias </td> <td></td> <td></td> </tr><tr><th><code>ST_Validate()</code></th> <td> Retorna geometria validada </td> <td></td> <td></td> </tr><tr><th><code>ST_Within()</code></th> <td> Verifica se uma geometria está dentro de outra </td> <td></td> <td></td> </tr><tr><th><code>ST_X()</code></th> <td> Retorna a coordenada X de um Point </td> <td></td> <td></td> </tr><tr><th><code>ST_Y()</code></th> <td> Retorna a coordenada Y de um Point </td> <td></td> <td></td> </tr><tr><th><code>StartPoint()</code></th> <td> Ponto Inicial (Start Point) de uma LineString </td> <td></td> <td>Sim</td> </tr><tr><th><code>STD()</code></th> <td> Retorna o desvio padrão da população </td> <td></td> <td></td> </tr><tr><th><code>STDDEV()</code></th> <td> Retorna o desvio padrão da população </td> <td></td> <td></td> </tr><tr><th><code>STDDEV_POP()</code></th> <td> Retorna o desvio padrão da população </td> <td></td> <td></td> </tr><tr><th><code>STDDEV_SAMP()</code></th> <td> Retorna o desvio padrão da amostra </td> <td></td> <td></td> </tr><tr><th><code>STR_TO_DATE()</code></th> <td> Converte uma string para uma data </td> <td></td> <td></td> </tr><tr><th><code>STRCMP()</code></th> <td> Compara duas strings </td> <td></td> <td></td> </tr><tr><th><code>SUBDATE()</code></th> <td> Sinônimo para DATE_SUB() quando invocado com três argumentos </td> <td></td> <td></td> </tr><tr><th><code>SUBSTR()</code></th> <td> Retorna a substring conforme especificado </td> <td></td> <td></td> </tr><tr><th><code>SUBSTRING()</code></th> <td> Retorna a substring conforme especificado </td> <td></td> <td></td> </tr><tr><th><code>SUBSTRING_INDEX()</code></th> <td> Retorna uma substring de uma string antes do número especificado de ocorrências do delimitador </td> <td></td> <td></td> </tr><tr><th><code>SUBTIME()</code></th> <td> Subtrai tempos </td> <td></td> <td></td> </tr><tr><th><code>SUM()</code></th> <td> Retorna a soma </td> <td></td> <td></td> </tr><tr><th><code>SYSDATE()</code></th> <td> Retorna a hora em que a função é executada </td> <td></td> <td></td> </tr><tr><th><code>SYSTEM_USER()</code></th> <td> Sinônimo para USER() </td> <td></td> <td></td> </tr><tr><th><code>TAN()</code></th> <td> Retorna a tangente do argumento </td> <td></td> <td></td> </tr><tr><th><code>TIME()</code></th> <td> Extrai a porção de tempo da expressão passada </td> <td></td> <td></td> </tr><tr><th><code>TIME_FORMAT()</code></th> <td> Formata como hora </td> <td></td> <td></td> </tr><tr><th><code>TIME_TO_SEC()</code></th> <td> Retorna o argumento convertido para segundos </td> <td></td> <td></td> </tr><tr><th><code>TIMEDIFF()</code></th> <td> Subtrai tempo </td> <td></td> <td></td> </tr><tr><th><code>TIMESTAMP()</code></th> <td> Com um único argumento, esta função retorna a expressão de data ou datetime; com dois argumentos, a soma dos argumentos </td> <td></td> <td></td> </tr><tr><th><code>TIMESTAMPADD()</code></th> <td> Adiciona um intervalo a uma expressão datetime </td> <td></td> <td></td> </tr><tr><th><code>TIMESTAMPDIFF()</code></th> <td> Retorna a diferença de duas expressões datetime, usando as unidades especificadas </td> <td></td> <td></td> </tr><tr><th><code>TO_BASE64()</code></th> <td> Retorna o argumento convertido para uma string base-64 </td> <td></td> <td></td> </tr><tr><th><code>TO_DAYS()</code></th> <td> Retorna o argumento de data convertido para dias </td> <td></td> <td></td> </tr><tr><th><code>TO_SECONDS()</code></th> <td> Retorna o argumento de data ou datetime convertido em segundos desde o Ano 0 </td> <td></td> <td></td> </tr><tr><th><code>Touches()</code></th> <td> Verifica se uma geometria toca outra </td> <td></td> <td>Sim</td> </tr><tr><th><code>TRIM()</code></th> <td> Remove espaços à esquerda e à direita </td> <td></td> <td></td> </tr><tr><th><code>TRUNCATE()</code></th> <td> Trunca para o número especificado de casas decimais </td> <td></td> <td></td> </tr><tr><th><code>UCASE()</code></th> <td> Sinônimo para UPPER() </td> <td></td> <td></td> </tr><tr><th><code>UNCOMPRESS()</code></th> <td> Descompacta uma string comprimida </td> <td></td> <td></td> </tr><tr><th><code>UNCOMPRESSED_LENGTH()</code></th> <td> Retorna o comprimento de uma string antes da compressão </td> <td></td> <td></td> </tr><tr><th><code>UNHEX()</code></th> <td> Retorna uma string contendo a representação hexadecimal de um número </td> <td></td> <td></td> </tr><tr><th><code>UNIX_TIMESTAMP()</code></th> <td> Retorna um Unix timestamp </td> <td></td> <td></td> </tr><tr><th><code>UpdateXML()</code></th> <td> Retorna o fragmento XML substituído </td> <td></td> <td></td> </tr><tr><th><code>UPPER()</code></th> <td> Converte para maiúsculas </td> <td></td> <td></td> </tr><tr><th><code>USER()</code></th> <td> O nome de usuário e Host Name fornecidos pelo cliente </td> <td></td> <td></td> </tr><tr><th><code>UTC_DATE()</code></th> <td> Retorna a data UTC atual </td> <td></td> <td></td> </tr><tr><th><code>UTC_TIME()</code></th> <td> Retorna a hora UTC atual </td> <td></td> <td></td> </tr><tr><th><code>UTC_TIMESTAMP()</code></th> <td> Retorna a data e hora UTC atuais </td> <td></td> <td></td> </tr><tr><th><code>UUID()</code></th> <td> Retorna um Identificador Universal Único (UUID) </td> <td></td> <td></td> </tr><tr><th><code>UUID_SHORT()</code></th> <td> Retorna um identificador universal com valor inteiro </td> <td></td> <td></td> </tr><tr><th><code>VALIDATE_PASSWORD_STRENGTH()</code></th> <td> Determina a força do Password </td> <td></td> <td></td> </tr><tr><th><code>VALUES()</code></th> <td> Define os valores a serem usados durante um INSERT </td> <td></td> <td></td> </tr><tr><th><code>VAR_POP()</code></th> <td> Retorna a variância padrão da população </td> <td></td> <td></td> </tr><tr><th><code>VAR_SAMP()</code></th> <td> Retorna a variância da amostra </td> <td></td> <td></td> </tr><tr><th><code>VARIANCE()</code></th> <td> Retorna a variância padrão da população </td> <td></td> <td></td> </tr><tr><th><code>VERSION()</code></th> <td> Retorna uma string que indica a versão do MySQL Server </td> <td></td> <td></td> </tr><tr><th><code>WAIT_FOR_EXECUTED_GTID_SET()</code></th> <td> Aguarda até que os GTIDs fornecidos tenham sido executados na réplica. </td> <td></td> <td></td> </tr><tr><th><code>WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS()</code></th> <td> Use <code>WAIT_FOR_EXECUTED_GTID_SET()</code>. </td> <td></td> <td></td> </tr><tr><th><code>WEEK()</code></th> <td> Retorna o número da semana </td> <td></td> <td></td> </tr><tr><th><code>WEEKDAY()</code></th> <td> Retorna o índice do dia da semana </td> <td></td> <td></td> </tr><tr><th><code>WEEKOFYEAR()</code></th> <td> Retorna a semana do calendário da data (1-53) </td> <td></td> <td></td> </tr><tr><th><code>WEIGHT_STRING()</code></th> <td> Retorna a weight string para uma string </td> <td></td> <td></td> </tr><tr><th><code>Within()</code></th> <td> Verifica se o MBR de uma geometria está dentro do MBR de outra </td> <td></td> <td>Sim</td> </tr><tr><th><code>X()</code></th> <td> Retorna a coordenada X de um Point </td> <td></td> <td>Sim</td> </tr><tr><th><code>XOR</code></th> <td> XOR Lógico </td> <td></td> <td></td> </tr><tr><th><code>Y()</code></th> <td> Retorna a coordenada Y de um Point </td> <td></td> <td>Sim</td> </tr><tr><th><code>YEAR()</code></th> <td> Retorna o ano </td> <td></td> <td></td> </tr><tr><th><code>YEARWEEK()</code></th> <td> Retorna o ano e a semana </td> <td></td> <td></td> </tr><tr><th><code>|</code></th> <td> OR Bitwise </td> <td></td> <td></td> </tr><tr><th><code>~</code></th> <td> Inversão Bitwise </td> <td></td> <td></td> </tr></tbody></table>