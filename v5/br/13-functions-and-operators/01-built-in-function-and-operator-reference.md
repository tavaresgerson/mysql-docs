## 12.1 Função integrada e referência ao operador

A tabela a seguir lista cada função e operador integrado (nativo) e fornece uma breve descrição de cada um. Para uma tabela que lista as funções que podem ser carregadas dinamicamente, consulte a Seção 12.2, “Referência de Funções Carregáveis”.

**Tabela 12.1 Funções e Operadores Integrados**

<table frame="box" rules="all" summary="Uma referência que lista todas as funções e operadores embutidos."><col style="width: 22%"/><col style="width: 55%"/><col style="width: 11%"/><col style="width: 11%"/><thead><tr><th>Nome</th> <th>Descrição</th> <th>Introduzido</th> <th>Desatualizado</th> </tr></thead><tbody><tr><th>[[PH_HTML_CODE_<code>DAYNAME()</code>]</th> <td>E AND bit a bit</td> <td></td> <td></td> </tr><tr><th>[[PH_HTML_CODE_<code>DAYNAME()</code>]</th> <td>Operador maior que</td> <td></td> <td></td> </tr><tr><th>[[PH_HTML_CODE_<code>DAYOFWEEK()</code>]</th> <td>Deslocamento para a direita</td> <td></td> <td></td> </tr><tr><th>[[PH_HTML_CODE_<code>DAYOFYEAR()</code>]</th> <td>Operador maior que ou igual a</td> <td></td> <td></td> </tr><tr><th>[[PH_HTML_CODE_<code>DECODE()</code>]</th> <td>Menos que o operador</td> <td></td> <td></td> </tr><tr><th>[[PH_HTML_CODE_<code>DEFAULT()</code>], [[PH_HTML_CODE_<code>DEGREES()</code>]</th> <td>Operador não igual</td> <td></td> <td></td> </tr><tr><th>[[PH_HTML_CODE_<code>DES_DECRYPT()</code>]</th> <td>Deslocamento para a esquerda</td> <td></td> <td></td> </tr><tr><th>[[PH_HTML_CODE_<code>DES_ENCRYPT()</code>]</th> <td>Operador menor ou igual</td> <td></td> <td></td> </tr><tr><th>[[PH_HTML_CODE_<code>Dimension()</code>]</th> <td>Igual a operador seguro para valores nulos</td> <td></td> <td></td> </tr><tr><th>[[<code>&gt;</code><code>DAYNAME()</code>], [[<code>&gt;</code><code>DAYNAME()</code>]</th> <td>Operador módulo</td> <td></td> <td></td> </tr><tr><th>[[<code>&gt;</code><code>DAYOFWEEK()</code>]</th> <td>Operador de multiplicação</td> <td></td> <td></td> </tr><tr><th>[[<code>&gt;</code><code>DAYOFYEAR()</code>]</th> <td>Operador de adição</td> <td></td> <td></td> </tr><tr><th>[[<code>&gt;</code><code>DECODE()</code>]</th> <td>Operador de menos</td> <td></td> <td></td> </tr><tr><th>[[<code>&gt;</code><code>DEFAULT()</code>]</th> <td>Troque o sinal do argumento</td> <td></td> <td></td> </tr><tr><th>[[<code>&gt;</code><code>DEGREES()</code>]</th> <td>Valor de retorno da coluna JSON após a avaliação do caminho; equivalente a JSON_EXTRACT().</td> <td></td> <td></td> </tr><tr><th>[[<code>&gt;</code><code>DES_DECRYPT()</code>]</th> <td>Retorno do valor de uma coluna JSON após a avaliação do caminho e a desunção do resultado; equivalente a JSON_UNQUOTE(JSON_EXTRACT()).</td> <td>5.7.13</td> <td></td> </tr><tr><th>[[<code>&gt;</code><code>DES_ENCRYPT()</code>]</th> <td>Operador de divisão</td> <td></td> <td></td> </tr><tr><th>[[<code>&gt;</code><code>Dimension()</code>]</th> <td>Atribua um valor</td> <td></td> <td></td> </tr><tr><th>[[<code>&gt;&gt;</code><code>DAYNAME()</code>]</th> <td>Atribua um valor (como parte de uma[[<code>&gt;&gt;</code><code>DAYNAME()</code>]declaração, ou como parte da cláusula [[<code>&gt;&gt;</code><code>DAYOFWEEK()</code>] em um[[<code>&gt;&gt;</code><code>DAYOFYEAR()</code>]declaração)</td> <td></td> <td></td> </tr><tr><th>[[<code>&gt;&gt;</code><code>DECODE()</code>]</th> <td>Operador igual</td> <td></td> <td></td> </tr><tr><th>[[<code>&gt;&gt;</code><code>DEFAULT()</code>]</th> <td>XOR bit a bit</td> <td></td> <td></td> </tr><tr><th>[[<code>&gt;&gt;</code><code>DEGREES()</code>]</th> <td>Retorne o valor absoluto</td> <td></td> <td></td> </tr><tr><th>[[<code>&gt;&gt;</code><code>DES_DECRYPT()</code>]</th> <td>Retorne o cosseno do arco</td> <td></td> <td></td> </tr><tr><th>[[<code>&gt;&gt;</code><code>DES_ENCRYPT()</code>]</th> <td>Adicione valores de tempo (intervalos) a um valor de data</td> <td></td> <td></td> </tr><tr><th>[[<code>&gt;&gt;</code><code>Dimension()</code>]</th> <td>Adicione tempo</td> <td></td> <td></td> </tr><tr><th>[[<code>&gt;=</code><code>DAYNAME()</code>]</th> <td>Descifre usando AES</td> <td></td> <td></td> </tr><tr><th>[[<code>&gt;=</code><code>DAYNAME()</code>]</th> <td>Criptografar usando AES</td> <td></td> <td></td> </tr><tr><th>[[<code>&gt;=</code><code>DAYOFWEEK()</code>], [[<code>&gt;=</code><code>DAYOFYEAR()</code>]</th> <td>E lógico AND</td> <td></td> <td></td> </tr><tr><th>[[<code>&gt;=</code><code>DECODE()</code>]</th> <td>Suprima a rejeição do valor ONLY_FULL_GROUP_BY</td> <td></td> <td></td> </tr><tr><th>[[<code>&gt;=</code><code>DEFAULT()</code>]</th> <td>Área de Retângulo ou MultiRetângulo</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>&gt;=</code><code>DEGREES()</code>], [[<code>&gt;=</code><code>DES_DECRYPT()</code>]</th> <td>Converter de formato de geometria interna para WKB</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>&gt;=</code><code>DES_ENCRYPT()</code>]</th> <td>Retorne o valor numérico do caractere mais à esquerda</td> <td></td> <td></td> </tr><tr><th>[[<code>&gt;=</code><code>Dimension()</code>]</th> <td>Retorne o arco seno</td> <td></td> <td></td> </tr><tr><th>[[<code>&lt;</code><code>DAYNAME()</code>], [[<code>&lt;</code><code>DAYNAME()</code>]</th> <td>Converter de formato de geometria interna para WKT</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>&lt;</code><code>DAYOFWEEK()</code>]</th> <td>Retorne a tangente do arco</td> <td></td> <td></td> </tr><tr><th>[[<code>&lt;</code><code>DAYOFYEAR()</code>], [[<code>&lt;</code><code>DECODE()</code>]</th> <td>Retorne o arco tangente dos dois argumentos</td> <td></td> <td></td> </tr><tr><th>[[<code>&lt;</code><code>DEFAULT()</code>]</th> <td>Retorne o valor médio do argumento</td> <td></td> <td></td> </tr><tr><th>[[<code>&lt;</code><code>DEGREES()</code>]</th> <td>Execute repetidamente uma expressão</td> <td></td> <td></td> </tr><tr><th>[[<code>&lt;</code><code>DES_DECRYPT()</code>]</th> <td>Se um valor estiver dentro de uma faixa de valores</td> <td></td> <td></td> </tr><tr><th>[[<code>&lt;</code><code>DES_ENCRYPT()</code>]</th> <td>Retorne uma string contendo a representação binária de um número</td> <td></td> <td></td> </tr><tr><th>[[<code>&lt;</code><code>Dimension()</code>]</th> <td>Converte uma cadeia de caracteres em uma cadeia binária</td> <td></td> <td></td> </tr><tr><th>[[<code>&lt;&gt;</code><code>DAYNAME()</code>]</th> <td>Retorno bit a bit e</td> <td></td> <td></td> </tr><tr><th>[[<code>&lt;&gt;</code><code>DAYNAME()</code>]</th> <td>Retorne o número de bits definidos</td> <td></td> <td></td> </tr><tr><th>[[<code>&lt;&gt;</code><code>DAYOFWEEK()</code>]</th> <td>Comprimento de retorno do argumento em bits</td> <td></td> <td></td> </tr><tr><th>[[<code>&lt;&gt;</code><code>DAYOFYEAR()</code>]</th> <td>Bitwise OR</td> <td></td> <td></td> </tr><tr><th>[[<code>&lt;&gt;</code><code>DECODE()</code>]</th> <td>XOR bit a bit</td> <td></td> <td></td> </tr><tr><th>[[<code>&lt;&gt;</code><code>DEFAULT()</code>]</th> <td>Geometria de retorno de pontos dentro da distância dada da geometria</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>&lt;&gt;</code><code>DEGREES()</code>]</th> <td>Operador de caso</td> <td></td> <td></td> </tr><tr><th>[[<code>&lt;&gt;</code><code>DES_DECRYPT()</code>]</th> <td>Atribua um valor a um determinado tipo</td> <td></td> <td></td> </tr><tr><th>[[<code>&lt;&gt;</code><code>DES_ENCRYPT()</code>]</th> <td>Retorne o menor valor inteiro não menor que o argumento</td> <td></td> <td></td> </tr><tr><th>[[<code>&lt;&gt;</code><code>Dimension()</code>]</th> <td>Retorne o menor valor inteiro não menor que o argumento</td> <td></td> <td></td> </tr><tr><th>[[<code>!=</code><code>DAYNAME()</code>]</th> <td>Retorne o centroide como um ponto</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>!=</code><code>DAYNAME()</code>]</th> <td>Retorne o caractere para cada inteiro passado</td> <td></td> <td></td> </tr><tr><th>[[<code>!=</code><code>DAYOFWEEK()</code>]</th> <td>Número de caracteres de retorno no argumento</td> <td></td> <td></td> </tr><tr><th>[[<code>!=</code><code>DAYOFYEAR()</code>]</th> <td>Sinônimo de CHAR_LENGTH()</td> <td></td> <td></td> </tr><tr><th>[[<code>!=</code><code>DECODE()</code>]</th> <td>Retorne o conjunto de caracteres do argumento</td> <td></td> <td></td> </tr><tr><th>[[<code>!=</code><code>DEFAULT()</code>]</th> <td>Retorne o primeiro argumento que não é NULL</td> <td></td> <td></td> </tr><tr><th>[[<code>!=</code><code>DEGREES()</code>]</th> <td>Retorne o valor de coercibilidade de ordenação do argumento string</td> <td></td> <td></td> </tr><tr><th>[[<code>!=</code><code>DES_DECRYPT()</code>]</th> <td>Retorne a ordenação do argumento de string</td> <td></td> <td></td> </tr><tr><th>[[<code>!=</code><code>DES_ENCRYPT()</code>]</th> <td>Retorne o resultado como uma string binária</td> <td></td> <td></td> </tr><tr><th>[[<code>!=</code><code>Dimension()</code>]</th> <td>Retorne a string concatenada</td> <td></td> <td></td> </tr><tr><th>[[<code>&lt;&lt;</code><code>DAYNAME()</code>]</th> <td>Concatenar e retornar com separador</td> <td></td> <td></td> </tr><tr><th>[[<code>&lt;&lt;</code><code>DAYNAME()</code>]</th> <td>Retorne o ID de conexão (ID de thread) para a conexão</td> <td></td> <td></td> </tr><tr><th>[[<code>&lt;&lt;</code><code>DAYOFWEEK()</code>]</th> <td>Se o MBR de uma geometria contém o MBR de outra</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>&lt;&lt;</code><code>DAYOFYEAR()</code>]</th> <td>Converter números entre diferentes bases numéricas</td> <td></td> <td></td> </tr><tr><th>[[<code>&lt;&lt;</code><code>DECODE()</code>]</th> <td>Atribua um valor a um determinado tipo</td> <td></td> <td></td> </tr><tr><th>[[<code>&lt;&lt;</code><code>DEFAULT()</code>]</th> <td>Converter de um fuso horário para outro</td> <td></td> <td></td> </tr><tr><th>[[<code>&lt;&lt;</code><code>DEGREES()</code>]</th> <td>Hull convexo de geometria</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>&lt;&lt;</code><code>DES_DECRYPT()</code>]</th> <td>Retorne o cosseno</td> <td></td> <td></td> </tr><tr><th>[[<code>&lt;&lt;</code><code>DES_ENCRYPT()</code>]</th> <td>Retorne a co-tangente</td> <td></td> <td></td> </tr><tr><th>[[<code>&lt;&lt;</code><code>Dimension()</code>]</th> <td>Retorne um contagem do número de linhas retornadas</td> <td></td> <td></td> </tr><tr><th>[[<code>&lt;=</code><code>DAYNAME()</code>]</th> <td>Retorne o número de valores diferentes</td> <td></td> <td></td> </tr><tr><th>[[<code>&lt;=</code><code>DAYNAME()</code>]</th> <td>Calcule o valor de verificação de redundância cíclica</td> <td></td> <td></td> </tr><tr><th>[[<code>&lt;=</code><code>DAYOFWEEK()</code>]</th> <td>Se uma geometria cruza outra</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>&lt;=</code><code>DAYOFYEAR()</code>]</th> <td>Retorne a data atual</td> <td></td> <td></td> </tr><tr><th>[[<code>&lt;=</code><code>DECODE()</code>], [[<code>&lt;=</code><code>DEFAULT()</code>]</th> <td>Sinônimos para CURDATE()</td> <td></td> <td></td> </tr><tr><th>[[<code>&lt;=</code><code>DEGREES()</code>], [[<code>&lt;=</code><code>DES_DECRYPT()</code>]</th> <td>Sinônimos para CURTIME()</td> <td></td> <td></td> </tr><tr><th>[[<code>&lt;=</code><code>DES_ENCRYPT()</code>], [[<code>&lt;=</code><code>Dimension()</code>]</th> <td>Sinônimos para NOW()</td> <td></td> <td></td> </tr><tr><th>[[<code>&lt;=&gt;</code><code>DAYNAME()</code>], [[<code>&lt;=&gt;</code><code>DAYNAME()</code>]</th> <td>O nome do usuário autenticado e o nome do host</td> <td></td> <td></td> </tr><tr><th>[[<code>&lt;=&gt;</code><code>DAYOFWEEK()</code>]</th> <td>Retorne a hora atual</td> <td></td> <td></td> </tr><tr><th>[[<code>&lt;=&gt;</code><code>DAYOFYEAR()</code>]</th> <td>Retorne o nome do banco de dados padrão (atual)</td> <td></td> <td></td> </tr><tr><th>[[<code>&lt;=&gt;</code><code>DECODE()</code>]</th> <td>Extrair a parte da data de uma expressão de data ou datetime</td> <td></td> <td></td> </tr><tr><th>[[<code>&lt;=&gt;</code><code>DEFAULT()</code>]</th> <td>Adicione valores de tempo (intervalos) a um valor de data</td> <td></td> <td></td> </tr><tr><th>[[<code>&lt;=&gt;</code><code>DEGREES()</code>]</th> <td>Formatar a data conforme especificado</td> <td></td> <td></td> </tr><tr><th>[[<code>&lt;=&gt;</code><code>DES_DECRYPT()</code>]</th> <td>Subtraia um valor de tempo (intervalo) de uma data</td> <td></td> <td></td> </tr><tr><th>[[<code>&lt;=&gt;</code><code>DES_ENCRYPT()</code>]</th> <td>Subtraia duas datas</td> <td></td> <td></td> </tr><tr><th>[[<code>&lt;=&gt;</code><code>Dimension()</code>]</th> <td>Sinônimo de DAYOFMONTH()</td> <td></td> <td></td> </tr><tr><th>[[<code>DAYNAME()</code>]]</th> <td>Retorne o nome do dia da semana</td> <td></td> <td></td> </tr><tr><th>[[<code>%</code><code>DAYNAME()</code>]</th> <td>Retorne o dia do mês (0-31)</td> <td></td> <td></td> </tr><tr><th>[[<code>DAYOFWEEK()</code>]]</th> <td>Retorne o índice de dia da semana do argumento</td> <td></td> <td></td> </tr><tr><th>[[<code>DAYOFYEAR()</code>]]</th> <td>Retorne o dia do ano (1-366)</td> <td></td> <td></td> </tr><tr><th>[[<code>DECODE()</code>]]</th> <td>Decodificar uma string criptografada usando ENCODE()</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>DEFAULT()</code>]]</th> <td>Retorne o valor padrão para uma coluna de tabela</td> <td></td> <td></td> </tr><tr><th>[[<code>DEGREES()</code>]]</th> <td>Converter radianos em graus</td> <td></td> <td></td> </tr><tr><th>[[<code>DES_DECRYPT()</code>]]</th> <td>Descifrar uma string</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>DES_ENCRYPT()</code>]]</th> <td>Criptografar uma string</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>Dimension()</code>]]</th> <td>Dimensão da geometria</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>MOD</code><code>DAYNAME()</code>]</th> <td>Se os MBRs de duas geometrias são disjuntos</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>MOD</code><code>DAYNAME()</code>]</th> <td>Divisão inteira</td> <td></td> <td></td> </tr><tr><th>[[<code>MOD</code><code>DAYOFWEEK()</code>]</th> <td>Retorne a string no número de índice</td> <td></td> <td></td> </tr><tr><th>[[<code>MOD</code><code>DAYOFYEAR()</code>]</th> <td>Codificar uma string</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>MOD</code><code>DECODE()</code>]</th> <td>Criptografar uma string</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>MOD</code><code>DEFAULT()</code>]</th> <td>Ponto final de LineString</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>MOD</code><code>DEGREES()</code>]</th> <td>Retorno do MBR da geometria</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>MOD</code><code>DES_DECRYPT()</code>]</th> <td>Se os MBRs de duas geometrias são iguais</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>MOD</code><code>DES_ENCRYPT()</code>]</th> <td>Se o resultado de uma consulta contiver alguma linha</td> <td></td> <td></td> </tr><tr><th>[[<code>MOD</code><code>Dimension()</code>]</th> <td>Eleve à potência de</td> <td></td> <td></td> </tr><tr><th>[[<code>*</code><code>DAYNAME()</code>]</th> <td>Retorne uma string onde, para cada bit definido no valor bits, você recebe uma string "on" e, para cada bit não definido, você recebe uma string "off".</td> <td></td> <td></td> </tr><tr><th>[[<code>*</code><code>DAYNAME()</code>]</th> <td>Anel exterior do Polygon</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>*</code><code>DAYOFWEEK()</code>]</th> <td>Extrair parte de uma data</td> <td></td> <td></td> </tr><tr><th>[[<code>*</code><code>DAYOFYEAR()</code>]</th> <td>Extrair um valor de uma string XML usando a notação XPath</td> <td></td> <td></td> </tr><tr><th>[[<code>*</code><code>DECODE()</code>]</th> <td>Índice (posição) do primeiro argumento nos argumentos subsequentes</td> <td></td> <td></td> </tr><tr><th>[[<code>*</code><code>DEFAULT()</code>]</th> <td>Índice (posição) do primeiro argumento dentro do segundo argumento</td> <td></td> <td></td> </tr><tr><th>[[<code>*</code><code>DEGREES()</code>]</th> <td>Retorne o maior valor inteiro que não seja maior que o argumento</td> <td></td> <td></td> </tr><tr><th>[[<code>*</code><code>DES_DECRYPT()</code>]</th> <td>Retorne um número formatado para o número especificado de casas decimais</td> <td></td> <td></td> </tr><tr><th>[[<code>*</code><code>DES_ENCRYPT()</code>]</th> <td>Para uma consulta SELECT com uma cláusula LIMIT, o número de linhas que seriam retornadas se não houvesse a cláusula LIMIT</td> <td></td> <td></td> </tr><tr><th>[[<code>*</code><code>Dimension()</code>]</th> <td>Decodificar a string codificada em base64 e retornar o resultado</td> <td></td> <td></td> </tr><tr><th>[[<code>+</code><code>DAYNAME()</code>]</th> <td>Converter um número de dia em uma data</td> <td></td> <td></td> </tr><tr><th>[[<code>+</code><code>DAYNAME()</code>]</th> <td>Formatar o timestamp Unix como uma data</td> <td></td> <td></td> </tr><tr><th>[[<code>+</code><code>DAYOFWEEK()</code>], [[<code>+</code><code>DAYOFYEAR()</code>]</th> <td>Coleção de geometria de retorno a partir de WKT</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>+</code><code>DECODE()</code>], [[<code>+</code><code>DEFAULT()</code>]</th> <td>Coleção de geometrias de retorno do WKB</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>+</code><code>DEGREES()</code>]</th> <td>Construa a coleção de geometrias a partir de geometrias</td> <td></td> <td></td> </tr><tr><th>[[<code>+</code><code>DES_DECRYPT()</code>]</th> <td>Retorne a N-ésima geometria da coleção de geometrias</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>+</code><code>DES_ENCRYPT()</code>]</th> <td>Retorne o nome do tipo de geometria</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>+</code><code>Dimension()</code>], [[<code>-</code><code>DAYNAME()</code>]</th> <td>Geometria de retorno a partir de WKT</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>-</code><code>DAYNAME()</code>], [[<code>-</code><code>DAYOFWEEK()</code>]</th> <td>Geometria de retorno do WKB</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>-</code><code>DAYOFYEAR()</code>]</th> <td>Retorne uma string de formato de data</td> <td></td> <td></td> </tr><tr><th>[[<code>-</code><code>DECODE()</code>]</th> <td>Obtenha uma trava com nome</td> <td></td> <td></td> </tr><tr><th>[[<code>-</code><code>DEFAULT()</code>]</th> <td>Comprimento de retorno da linha String</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>-</code><code>DEGREES()</code>]</th> <td>Retorne o maior argumento</td> <td></td> <td></td> </tr><tr><th>[[<code>-</code><code>DES_DECRYPT()</code>]</th> <td>Retorne uma string concatenada</td> <td></td> <td></td> </tr><tr><th>[[<code>-</code><code>DES_ENCRYPT()</code>]</th> <td>Retorne verdadeiro se todos os GTIDs no subconjunto também estiverem no conjunto; caso contrário, falso.</td> <td></td> <td></td> </tr><tr><th>[[<code>-</code><code>Dimension()</code>]</th> <td>Retorne todos os GTIDs em um conjunto que não estão em um subconjunto.</td> <td></td> <td></td> </tr><tr><th>[[<code>-</code><code>DAYNAME()</code>]</th> <td>Representação hexadecimal de valor decimal ou de cadeia</td> <td></td> <td></td> </tr><tr><th>[[<code>-</code><code>DAYNAME()</code>]</th> <td>Extraia a hora</td> <td></td> <td></td> </tr><tr><th>[[<code>-</code><code>DAYOFWEEK()</code>]</th> <td>Estrutura if/else</td> <td></td> <td></td> </tr><tr><th>[[<code>-</code><code>DAYOFYEAR()</code>]</th> <td>Estrutura if/else nula</td> <td></td> <td></td> </tr><tr><th>[[<code>-</code><code>DECODE()</code>]</th> <td>Se um valor está dentro de um conjunto de valores</td> <td></td> <td></td> </tr><tr><th>[[<code>-</code><code>DEFAULT()</code>]</th> <td>Retorne o valor numérico de um endereço IP</td> <td></td> <td></td> </tr><tr><th>[[<code>-</code><code>DEGREES()</code>]</th> <td>Retorne o endereço IP a partir de um valor numérico</td> <td></td> <td></td> </tr><tr><th>[[<code>-</code><code>DES_DECRYPT()</code>]</th> <td>Retorne o valor numérico de um endereço IPv6</td> <td></td> <td></td> </tr><tr><th>[[<code>-</code><code>DES_ENCRYPT()</code>]</th> <td>Retorne o endereço IPv6 a partir de um valor numérico</td> <td></td> <td></td> </tr><tr><th>[[<code>-</code><code>Dimension()</code>]</th> <td>Insira a subcadeia na posição especificada até o número especificado de caracteres</td> <td></td> <td></td> </tr><tr><th>[[<code>-&gt;</code><code>DAYNAME()</code>]</th> <td>Retorne o índice da primeira ocorrência da subcadeia</td> <td></td> <td></td> </tr><tr><th>[[<code>-&gt;</code><code>DAYNAME()</code>]</th> <td>Retorno do N-ésimo anel interno do polígono</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>-&gt;</code><code>DAYOFWEEK()</code>]</th> <td>Se os MBRs de duas geometrias se intersectam</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>-&gt;</code><code>DAYOFYEAR()</code>]</th> <td>Retorne o índice do argumento que é menor que o primeiro argumento</td> <td></td> <td></td> </tr><tr><th>[[<code>-&gt;</code><code>DECODE()</code>]</th> <td>Teste um valor contra um booleano</td> <td></td> <td></td> </tr><tr><th>[[<code>-&gt;</code><code>DEFAULT()</code>]</th> <td>Se a trava nomeada está livre</td> <td></td> <td></td> </tr><tr><th>[[<code>-&gt;</code><code>DEGREES()</code>]</th> <td>Se o argumento é um endereço IPv4</td> <td></td> <td></td> </tr><tr><th>[[<code>-&gt;</code><code>DES_DECRYPT()</code>]</th> <td>Se o argumento é um endereço compatível com IPv4</td> <td></td> <td></td> </tr><tr><th>[[<code>-&gt;</code><code>DES_ENCRYPT()</code>]</th> <td>Se o argumento é um endereço mapeado IPv4</td> <td></td> <td></td> </tr><tr><th>[[<code>-&gt;</code><code>Dimension()</code>]</th> <td>Se o argumento é um endereço IPv6</td> <td></td> <td></td> </tr><tr><th>[[<code>-&gt;&gt;</code><code>DAYNAME()</code>]</th> <td>Teste um valor contra um booleano</td> <td></td> <td></td> </tr><tr><th>[[<code>-&gt;&gt;</code><code>DAYNAME()</code>]</th> <td>Teste de valor NOT NULL</td> <td></td> <td></td> </tr><tr><th>[[<code>-&gt;&gt;</code><code>DAYOFWEEK()</code>]</th> <td>Teste de valor nulo</td> <td></td> <td></td> </tr><tr><th>[[<code>-&gt;&gt;</code><code>DAYOFYEAR()</code>]</th> <td>Se o bloqueio nomeado estiver em uso; retorne o identificador de conexão se for verdadeiro</td> <td></td> <td></td> </tr><tr><th>[[<code>-&gt;&gt;</code><code>DECODE()</code>]</th> <td>Se uma geometria é fechada e simples</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>-&gt;&gt;</code><code>DEFAULT()</code>]</th> <td>Se uma geometria está vazia</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>-&gt;&gt;</code><code>DEGREES()</code>]</th> <td>Teste se o argumento é NULL</td> <td></td> <td></td> </tr><tr><th>[[<code>-&gt;&gt;</code><code>DES_DECRYPT()</code>]</th> <td>Se uma geometria é simples</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>-&gt;&gt;</code><code>DES_ENCRYPT()</code>]</th> <td>Adicione dados ao documento JSON</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>-&gt;&gt;</code><code>Dimension()</code>]</th> <td>Crie um array JSON</td> <td></td> <td></td> </tr><tr><th>[[<code>/</code><code>DAYNAME()</code>]</th> <td>Adicione dados ao documento JSON</td> <td></td> <td></td> </tr><tr><th>[[<code>/</code><code>DAYNAME()</code>]</th> <td>Insira no array JSON</td> <td></td> <td></td> </tr><tr><th>[[<code>/</code><code>DAYOFWEEK()</code>]</th> <td>Retorne o conjunto de resultados como um único array JSON</td> <td>5.7.22</td> <td></td> </tr><tr><th>[[<code>/</code><code>DAYOFYEAR()</code>]</th> <td>Se o documento JSON contém um objeto específico no caminho</td> <td></td> <td></td> </tr><tr><th>[[<code>/</code><code>DECODE()</code>]</th> <td>Se o documento JSON contém algum dado no caminho</td> <td></td> <td></td> </tr><tr><th>[[<code>/</code><code>DEFAULT()</code>]</th> <td>Profundidade máxima do documento JSON</td> <td></td> <td></td> </tr><tr><th>[[<code>/</code><code>DEGREES()</code>]</th> <td>Retorno de dados de documento JSON</td> <td></td> <td></td> </tr><tr><th>[[<code>/</code><code>DES_DECRYPT()</code>]</th> <td>Insira dados no documento JSON</td> <td></td> <td></td> </tr><tr><th>[[<code>/</code><code>DES_ENCRYPT()</code>]</th> <td>Array de chaves de um documento JSON</td> <td></td> <td></td> </tr><tr><th>[[<code>/</code><code>Dimension()</code>]</th> <td>Número de elementos no documento JSON</td> <td></td> <td></td> </tr><tr><th>[[<code>:=</code><code>DAYNAME()</code>]</th> <td>Combine documentos JSON, preservando chaves duplicadas. Sinônimo desatualizado para JSON_MERGE_PRESERVE()</td> <td></td> <td>5.7.22</td> </tr><tr><th>[[<code>:=</code><code>DAYNAME()</code>]</th> <td>Combine documentos JSON, substituindo os valores de chaves duplicadas</td> <td>5.7.22</td> <td></td> </tr><tr><th>[[<code>:=</code><code>DAYOFWEEK()</code>]</th> <td>Combine documentos JSON, preservando chaves duplicadas</td> <td>5.7.22</td> <td></td> </tr><tr><th>[[<code>:=</code><code>DAYOFYEAR()</code>]</th> <td>Crie um objeto JSON</td> <td></td> <td></td> </tr><tr><th>[[<code>:=</code><code>DECODE()</code>]</th> <td>Retorne o conjunto de resultados como um único objeto JSON</td> <td>5.7.22</td> <td></td> </tr><tr><th>[[<code>:=</code><code>DEFAULT()</code>]</th> <td>Imprima um documento JSON em formato legível para humanos</td> <td>5.7.22</td> <td></td> </tr><tr><th>[[<code>:=</code><code>DEGREES()</code>]</th> <td>Citação do documento JSON</td> <td></td> <td></td> </tr><tr><th>[[<code>:=</code><code>DES_DECRYPT()</code>]</th> <td>Remover dados do documento JSON</td> <td></td> <td></td> </tr><tr><th>[[<code>:=</code><code>DES_ENCRYPT()</code>]</th> <td>Substitua os valores no documento JSON</td> <td></td> <td></td> </tr><tr><th>[[<code>:=</code><code>Dimension()</code>]</th> <td>Caminho para o valor dentro do documento JSON</td> <td></td> <td></td> </tr><tr><th>[[<code>=</code><code>DAYNAME()</code>]</th> <td>Insira dados no documento JSON</td> <td></td> <td></td> </tr><tr><th>[[<code>=</code><code>DAYNAME()</code>]</th> <td>Espaço utilizado para armazenamento da representação binária de um documento JSON</td> <td>5.7.22</td> <td></td> </tr><tr><th>[[<code>=</code><code>DAYOFWEEK()</code>]</th> <td>Tipo de valor JSON</td> <td></td> <td></td> </tr><tr><th>[[<code>=</code><code>DAYOFYEAR()</code>]</th> <td>Desfazer o valor JSON</td> <td></td> <td></td> </tr><tr><th>[[<code>=</code><code>DECODE()</code>]</th> <td>Se o valor JSON é válido</td> <td></td> <td></td> </tr><tr><th>[[<code>=</code><code>DEFAULT()</code>]</th> <td>Retorne o último dia do mês para o argumento</td> <td></td> <td></td> </tr><tr><th>[[<code>=</code><code>DEGREES()</code>]</th> <td>Valor da coluna AUTOINCREMENT para a última inserção</td> <td></td> <td></td> </tr><tr><th>[[<code>=</code><code>DES_DECRYPT()</code>]</th> <td>Sinônimo de LOWER()</td> <td></td> <td></td> </tr><tr><th>[[<code>=</code><code>DES_ENCRYPT()</code>]</th> <td>Retorne o menor argumento</td> <td></td> <td></td> </tr><tr><th>[[<code>=</code><code>Dimension()</code>]</th> <td>Retorne o número de caracteres mais à esquerda conforme especificado</td> <td></td> <td></td> </tr><tr><th>[[<code>SET</code><code>DAYNAME()</code>]</th> <td>Retorne o comprimento de uma string em bytes</td> <td></td> <td></td> </tr><tr><th>[[<code>SET</code><code>DAYNAME()</code>]</th> <td>Encontre padrões simples</td> <td></td> <td></td> </tr><tr><th>[[<code>SET</code><code>DAYOFWEEK()</code>], [[<code>SET</code><code>DAYOFYEAR()</code>]</th> <td>Construa uma linha String a partir de WKT</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>SET</code><code>DECODE()</code>], [[<code>SET</code><code>DEFAULT()</code>]</th> <td>Construa uma linha String a partir de WKB</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>SET</code><code>DEGREES()</code>]</th> <td>Construa uma linha String a partir de valores de ponto</td> <td></td> <td></td> </tr><tr><th>[[<code>SET</code><code>DES_DECRYPT()</code>]</th> <td>Retorne o logaritmo natural do argumento</td> <td></td> <td></td> </tr><tr><th>[[<code>SET</code><code>DES_ENCRYPT()</code>]</th> <td>Carregue o arquivo nomeado</td> <td></td> <td></td> </tr><tr><th>[[<code>SET</code><code>Dimension()</code>], [[<code>SET</code><code>DAYNAME()</code>]</th> <td>Sinônimo de NOW()</td> <td></td> <td></td> </tr><tr><th>[[<code>SET</code><code>DAYNAME()</code>], [[<code>SET</code><code>DAYOFWEEK()</code>]</th> <td>Sinônimo de NOW()</td> <td></td> <td></td> </tr><tr><th>[[<code>SET</code><code>DAYOFYEAR()</code>]</th> <td>Retorne a posição da primeira ocorrência da subcadeia</td> <td></td> <td></td> </tr><tr><th>[[<code>SET</code><code>DECODE()</code>]</th> <td>Retorne o logaritmo natural do primeiro argumento</td> <td></td> <td></td> </tr><tr><th>[[<code>SET</code><code>DEFAULT()</code>]</th> <td>Retorne o logaritmo decimal do argumento</td> <td></td> <td></td> </tr><tr><th>[[<code>SET</code><code>DEGREES()</code>]</th> <td>Retorne o logaritmo em base 2 do argumento</td> <td></td> <td></td> </tr><tr><th>[[<code>SET</code><code>DES_DECRYPT()</code>]</th> <td>Devolva o argumento em minúsculas</td> <td></td> <td></td> </tr><tr><th>[[<code>SET</code><code>DES_ENCRYPT()</code>]</th> <td>Retorne o argumento de string, preenchido à esquerda com a string especificada</td> <td></td> <td></td> </tr><tr><th>[[<code>SET</code><code>Dimension()</code>]</th> <td>Remova espaços em branco iniciais</td> <td></td> <td></td> </tr><tr><th>[[<code>UPDATE</code><code>DAYNAME()</code>]</th> <td>Retorne um conjunto de strings separadas por vírgula que tenham o bit correspondente definido em bits</td> <td></td> <td></td> </tr><tr><th>[[<code>UPDATE</code><code>DAYNAME()</code>]</th> <td>Crie uma data a partir do ano e do dia do ano</td> <td></td> <td></td> </tr><tr><th>[[<code>UPDATE</code><code>DAYOFWEEK()</code>]</th> <td>Crie tempo a partir de hora, minuto e segundo</td> <td></td> <td></td> </tr><tr><th>[[<code>UPDATE</code><code>DAYOFYEAR()</code>]</th> <td>Bloquear até que a réplica tenha lido e aplicado todas as atualizações até a posição especificada</td> <td></td> <td></td> </tr><tr><th>[[<code>UPDATE</code><code>DECODE()</code>]</th> <td>Realize uma pesquisa de texto completo</td> <td></td> <td></td> </tr><tr><th>[[<code>UPDATE</code><code>DEFAULT()</code>]</th> <td>Retorne o valor máximo</td> <td></td> <td></td> </tr><tr><th>[[<code>UPDATE</code><code>DEGREES()</code>]</th> <td>Se o MBR de uma geometria contém o MBR de outra</td> <td></td> <td></td> </tr><tr><th>[[<code>UPDATE</code><code>DES_DECRYPT()</code>]</th> <td>Se um MBR estiver coberto por outro</td> <td></td> <td></td> </tr><tr><th>[[<code>UPDATE</code><code>DES_ENCRYPT()</code>]</th> <td>Se um MBR cobre outro</td> <td></td> <td></td> </tr><tr><th>[[<code>UPDATE</code><code>Dimension()</code>]</th> <td>Se os MBRs de duas geometrias são disjuntos</td> <td></td> <td></td> </tr><tr><th>[[<code>=</code><code>DAYNAME()</code>]</th> <td>Se os MBRs de duas geometrias são iguais</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>=</code><code>DAYNAME()</code>]</th> <td>Se os MBRs de duas geometrias são iguais</td> <td></td> <td></td> </tr><tr><th>[[<code>=</code><code>DAYOFWEEK()</code>]</th> <td>Se os MBRs de duas geometrias se intersectam</td> <td></td> <td></td> </tr><tr><th>[[<code>=</code><code>DAYOFYEAR()</code>]</th> <td>Se os MBRs de duas geometrias se sobrepõem</td> <td></td> <td></td> </tr><tr><th>[[<code>=</code><code>DECODE()</code>]</th> <td>Se os MBRs de duas geometrias se tocam</td> <td></td> <td></td> </tr><tr><th>[[<code>=</code><code>DEFAULT()</code>]</th> <td>Se o MBR de uma geometria estiver dentro do MBR de outra</td> <td></td> <td></td> </tr><tr><th>[[<code>=</code><code>DEGREES()</code>]</th> <td>Calcular o checksum MD5</td> <td></td> <td></td> </tr><tr><th>[[<code>=</code><code>DES_DECRYPT()</code>]</th> <td>Retorne os microsegundos do argumento</td> <td></td> <td></td> </tr><tr><th>[[<code>=</code><code>DES_ENCRYPT()</code>]</th> <td>Retorne uma subcadeia a partir da posição especificada</td> <td></td> <td></td> </tr><tr><th>[[<code>=</code><code>Dimension()</code>]</th> <td>Retorne o valor mínimo</td> <td></td> <td></td> </tr><tr><th>[[<code>^</code><code>DAYNAME()</code>]</th> <td>Devolva o minuto da discussão</td> <td></td> <td></td> </tr><tr><th>[[<code>^</code><code>DAYNAME()</code>], [[<code>^</code><code>DAYOFWEEK()</code>]</th> <td>Construir MultiLineString a partir de WKT</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>^</code><code>DAYOFYEAR()</code>], [[<code>^</code><code>DECODE()</code>]</th> <td>Construir MultiLineString a partir de WKB</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>^</code><code>DEFAULT()</code>]</th> <td>Devolva o restante</td> <td></td> <td></td> </tr><tr><th>[[<code>^</code><code>DEGREES()</code>]</th> <td>Retorne o mês da data passada</td> <td></td> <td></td> </tr><tr><th>[[<code>^</code><code>DES_DECRYPT()</code>]</th> <td>Retorne o nome do mês</td> <td></td> <td></td> </tr><tr><th>[[<code>^</code><code>DES_ENCRYPT()</code>], [[<code>^</code><code>Dimension()</code>]</th> <td>Construa o MultiPoint a partir do WKT</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>ABS()</code><code>DAYNAME()</code>], [[<code>ABS()</code><code>DAYNAME()</code>]</th> <td>Construa o MultiPoint a partir do WKB</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>ABS()</code><code>DAYOFWEEK()</code>], [[<code>ABS()</code><code>DAYOFYEAR()</code>]</th> <td>Construa MultiPolygon a partir de WKT</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>ABS()</code><code>DECODE()</code>], [[<code>ABS()</code><code>DEFAULT()</code>]</th> <td>Construir MultiPolygon a partir de WKB</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>ABS()</code><code>DEGREES()</code>]</th> <td>Construir MultiLineString a partir de valores de LineString</td> <td></td> <td></td> </tr><tr><th>[[<code>ABS()</code><code>DES_DECRYPT()</code>]</th> <td>Construa o MultiPoint a partir de valores de ponto</td> <td></td> <td></td> </tr><tr><th>[[<code>ABS()</code><code>DES_ENCRYPT()</code>]</th> <td>Construir MultiPolygon a partir de valores Polygon</td> <td></td> <td></td> </tr><tr><th>[[<code>ABS()</code><code>Dimension()</code>]</th> <td>Faça com que a coluna tenha o nome dado</td> <td></td> <td></td> </tr><tr><th>[[<code>ACOS()</code><code>DAYNAME()</code>], [[<code>ACOS()</code><code>DAYNAME()</code>]</th> <td>Nega o valor</td> <td></td> <td></td> </tr><tr><th>[[<code>ACOS()</code><code>DAYOFWEEK()</code>]</th> <td>Se um valor não estiver dentro de uma faixa de valores</td> <td></td> <td></td> </tr><tr><th>[[<code>ACOS()</code><code>DAYOFYEAR()</code>]</th> <td>Se o resultado de uma consulta não contiver nenhuma linha</td> <td></td> <td></td> </tr><tr><th>[[<code>ACOS()</code><code>DECODE()</code>]</th> <td>Se um valor não estiver dentro de um conjunto de valores</td> <td></td> <td></td> </tr><tr><th>[[<code>ACOS()</code><code>DEFAULT()</code>]</th> <td>Negação de correspondência de padrão simples</td> <td></td> <td></td> </tr><tr><th>[[<code>ACOS()</code><code>DEGREES()</code>]</th> <td>Negação de REGEXP</td> <td></td> <td></td> </tr><tr><th>[[<code>ACOS()</code><code>DES_DECRYPT()</code>]</th> <td>Retorne a data e hora atuais</td> <td></td> <td></td> </tr><tr><th>[[<code>ACOS()</code><code>DES_ENCRYPT()</code>]</th> <td>Retorne NULL se expr1 = expr2</td> <td></td> <td></td> </tr><tr><th>[[<code>ACOS()</code><code>Dimension()</code>]</th> <td>Número de geometrias de volta na coleção de geometrias</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>ADDDATE()</code><code>DAYNAME()</code>]</th> <td>Número de anéis internos na Polygon</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>ADDDATE()</code><code>DAYNAME()</code>]</th> <td>Retorne o número de pontos na LineString</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>ADDDATE()</code><code>DAYOFWEEK()</code>]</th> <td>Retorne uma string contendo a representação octal de um número</td> <td></td> <td></td> </tr><tr><th>[[<code>ADDDATE()</code><code>DAYOFYEAR()</code>]</th> <td>Sinônimo de LENGTH()</td> <td></td> <td></td> </tr><tr><th>[[<code>ADDDATE()</code><code>DECODE()</code>], [[<code>ADDDATE()</code><code>DEFAULT()</code>]</th> <td>OU lógico</td> <td></td> <td></td> </tr><tr><th>[[<code>ADDDATE()</code><code>DEGREES()</code>]</th> <td>Código de caractere de retorno para o caractere mais à esquerda do argumento</td> <td></td> <td></td> </tr><tr><th>[[<code>ADDDATE()</code><code>DES_DECRYPT()</code>]</th> <td>Se os MBRs de duas geometrias se sobrepõem</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>ADDDATE()</code><code>DES_ENCRYPT()</code>]</th> <td>Calcule e retorne uma string de senha</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>ADDDATE()</code><code>Dimension()</code>]</th> <td>Adicione um ponto final a um ano-mês</td> <td></td> <td></td> </tr><tr><th>[[<code>ADDTIME()</code><code>DAYNAME()</code>]</th> <td>Retorne o número de meses entre os períodos</td> <td></td> <td></td> </tr><tr><th>[[<code>ADDTIME()</code><code>DAYNAME()</code>]</th> <td>Retorne o valor de pi</td> <td></td> <td></td> </tr><tr><th>[[<code>ADDTIME()</code><code>DAYOFWEEK()</code>]</th> <td>Construir ponto a partir de coordenadas</td> <td></td> <td></td> </tr><tr><th>[[<code>ADDTIME()</code><code>DAYOFYEAR()</code>]</th> <td>Construir ponto a partir de WKT</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>ADDTIME()</code><code>DECODE()</code>]</th> <td>Construa o Ponto de WKB</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>ADDTIME()</code><code>DEFAULT()</code>]</th> <td>Retorne o N-ésimo ponto da LineString</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>ADDTIME()</code><code>DEGREES()</code>], [[<code>ADDTIME()</code><code>DES_DECRYPT()</code>]</th> <td>Construir polígono a partir de WKT</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>ADDTIME()</code><code>DES_ENCRYPT()</code>], [[<code>ADDTIME()</code><code>Dimension()</code>]</th> <td>Construa o polígono a partir do WKB</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>AES_DECRYPT()</code><code>DAYNAME()</code>]</th> <td>Construir polígono a partir de argumentos LineString</td> <td></td> <td></td> </tr><tr><th>[[<code>AES_DECRYPT()</code><code>DAYNAME()</code>]</th> <td>Sinônimo de LOCATE()</td> <td></td> <td></td> </tr><tr><th>[[<code>AES_DECRYPT()</code><code>DAYOFWEEK()</code>]</th> <td>Retorne o argumento elevado à potência especificada</td> <td></td> <td></td> </tr><tr><th>[[<code>AES_DECRYPT()</code><code>DAYOFYEAR()</code>]</th> <td>Retorne o argumento elevado à potência especificada</td> <td></td> <td></td> </tr><tr><th>[[<code>AES_DECRYPT()</code><code>DECODE()</code>]</th> <td>Analisar os resultados de uma consulta</td> <td></td> <td>5.7.18</td> </tr><tr><th>[[<code>AES_DECRYPT()</code><code>DEFAULT()</code>]</th> <td>Retorne o quarto de um argumento de data</td> <td></td> <td></td> </tr><tr><th>[[<code>AES_DECRYPT()</code><code>DEGREES()</code>]</th> <td>Escape o argumento para uso em uma declaração SQL</td> <td></td> <td></td> </tr><tr><th>[[<code>AES_DECRYPT()</code><code>DES_DECRYPT()</code>]</th> <td>Argumento de retorno convertido para radianos</td> <td></td> <td></td> </tr><tr><th>[[<code>AES_DECRYPT()</code><code>DES_ENCRYPT()</code>]</th> <td>Retorne um valor aleatório de ponto flutuante</td> <td></td> <td></td> </tr><tr><th>[[<code>AES_DECRYPT()</code><code>Dimension()</code>]</th> <td>Retorne um vetor de bytes aleatório</td> <td></td> <td></td> </tr><tr><th>[[<code>AES_ENCRYPT()</code><code>DAYNAME()</code>]</th> <td>Se a cadeia corresponde à expressão regular</td> <td></td> <td></td> </tr><tr><th>[[<code>AES_ENCRYPT()</code><code>DAYNAME()</code>]</th> <td>Liberar todas as trancas nomeadas atuais</td> <td></td> <td></td> </tr><tr><th>[[<code>AES_ENCRYPT()</code><code>DAYOFWEEK()</code>]</th> <td>Liberar o bloqueio nomeado</td> <td></td> <td></td> </tr><tr><th>[[<code>AES_ENCRYPT()</code><code>DAYOFYEAR()</code>]</th> <td>Repita uma string o número especificado de vezes</td> <td></td> <td></td> </tr><tr><th>[[<code>AES_ENCRYPT()</code><code>DECODE()</code>]</th> <td>Substitua as ocorrências de uma string especificada</td> <td></td> <td></td> </tr><tr><th>[[<code>AES_ENCRYPT()</code><code>DEFAULT()</code>]</th> <td>Inverter os caracteres de uma string</td> <td></td> <td></td> </tr><tr><th>[[<code>AES_ENCRYPT()</code><code>DEGREES()</code>]</th> <td>Retorne o número especificado de caracteres à direita</td> <td></td> <td></td> </tr><tr><th>[[<code>AES_ENCRYPT()</code><code>DES_DECRYPT()</code>]</th> <td>Se a cadeia corresponde à expressão regular</td> <td></td> <td></td> </tr><tr><th>[[<code>AES_ENCRYPT()</code><code>DES_ENCRYPT()</code>]</th> <td>Em torno do argumento</td> <td></td> <td></td> </tr><tr><th>[[<code>AES_ENCRYPT()</code><code>Dimension()</code>]</th> <td>O número de linhas atualizadas</td> <td></td> <td></td> </tr><tr><th>[[<code>AND</code><code>DAYNAME()</code>]</th> <td>Adicione a string o número especificado de vezes</td> <td></td> <td></td> </tr><tr><th>[[<code>AND</code><code>DAYNAME()</code>]</th> <td>Remova espaços em branco finais</td> <td></td> <td></td> </tr><tr><th>[[<code>AND</code><code>DAYOFWEEK()</code>]</th> <td>Sinônimo de DATABASE()</td> <td></td> <td></td> </tr><tr><th>[[<code>AND</code><code>DAYOFYEAR()</code>]</th> <td>Converte segundos para o formato 'hh:mm:ss'</td> <td></td> <td></td> </tr><tr><th>[[<code>AND</code><code>DECODE()</code>]</th> <td>Retorne o segundo (0-59)</td> <td></td> <td></td> </tr><tr><th>[[<code>AND</code><code>DEFAULT()</code>]</th> <td>Sinônimo de USER()</td> <td></td> <td></td> </tr><tr><th>[[<code>AND</code><code>DEGREES()</code>], [[<code>AND</code><code>DES_DECRYPT()</code>]</th> <td>Calcule um checksum de 160 bits SHA-1</td> <td></td> <td></td> </tr><tr><th>[[<code>AND</code><code>DES_ENCRYPT()</code>]</th> <td>Calcule um checksum SHA-2</td> <td></td> <td></td> </tr><tr><th>[[<code>AND</code><code>Dimension()</code>]</th> <td>Retorne o sinal do argumento</td> <td></td> <td></td> </tr><tr><th>[[<code>&amp;&amp;</code><code>DAYNAME()</code>]</th> <td>Retorne o seno do argumento</td> <td></td> <td></td> </tr><tr><th>[[<code>&amp;&amp;</code><code>DAYNAME()</code>]</th> <td>Durma por alguns segundos</td> <td></td> <td></td> </tr><tr><th>[[<code>&amp;&amp;</code><code>DAYOFWEEK()</code>]</th> <td>Retorne uma string soundex</td> <td></td> <td></td> </tr><tr><th>[[<code>&amp;&amp;</code><code>DAYOFYEAR()</code>]</th> <td>Compare os sons</td> <td></td> <td></td> </tr><tr><th>[[<code>&amp;&amp;</code><code>DECODE()</code>]</th> <td>Retorne uma string com o número especificado de espaços</td> <td></td> <td></td> </tr><tr><th>[[<code>&amp;&amp;</code><code>DEFAULT()</code>]</th> <td>A distância entre duas geometrias</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>&amp;&amp;</code><code>DEGREES()</code>]</th> <td>Retorne a raiz quadrada do argumento</td> <td></td> <td></td> </tr><tr><th>[[<code>&amp;&amp;</code><code>DES_DECRYPT()</code>]</th> <td>ID do sistema de referência espacial de retorno para a geometria</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>&amp;&amp;</code><code>DES_ENCRYPT()</code>]</th> <td>Área de Retângulo ou MultiRetângulo</td> <td></td> <td></td> </tr><tr><th>[[<code>&amp;&amp;</code><code>Dimension()</code>], [[<code>ANY_VALUE()</code><code>DAYNAME()</code>]</th> <td>Converter de formato de geometria interna para WKB</td> <td></td> <td></td> </tr><tr><th>[[<code>ANY_VALUE()</code><code>DAYNAME()</code>]</th> <td>Gerar objeto GeoJSON a partir da geometria</td> <td></td> <td></td> </tr><tr><th>[[<code>ANY_VALUE()</code><code>DAYOFWEEK()</code>], [[<code>ANY_VALUE()</code><code>DAYOFYEAR()</code>]</th> <td>Converter de formato de geometria interna para WKT</td> <td></td> <td></td> </tr><tr><th>[[<code>ANY_VALUE()</code><code>DECODE()</code>]</th> <td>Geometria de retorno de pontos dentro da distância dada da geometria</td> <td></td> <td></td> </tr><tr><th>[[<code>ANY_VALUE()</code><code>DEFAULT()</code>]</th> <td>Produza a opção de estratégia para o ST_Buffer()</td> <td></td> <td></td> </tr><tr><th>[[<code>ANY_VALUE()</code><code>DEGREES()</code>]</th> <td>Retorne o centroide como um ponto</td> <td></td> <td></td> </tr><tr><th>[[<code>ANY_VALUE()</code><code>DES_DECRYPT()</code>]</th> <td>Se uma geometria contém outra</td> <td></td> <td></td> </tr><tr><th>[[<code>ANY_VALUE()</code><code>DES_ENCRYPT()</code>]</th> <td>Hull convexo de geometria</td> <td></td> <td></td> </tr><tr><th>[[<code>ANY_VALUE()</code><code>Dimension()</code>]</th> <td>Se uma geometria cruza outra</td> <td></td> <td></td> </tr><tr><th>[[<code>Area()</code><code>DAYNAME()</code>]</th> <td>Diferença de ponto de retorno entre duas geometrias</td> <td></td> <td></td> </tr><tr><th>[[<code>Area()</code><code>DAYNAME()</code>]</th> <td>Dimensão da geometria</td> <td></td> <td></td> </tr><tr><th>[[<code>Area()</code><code>DAYOFWEEK()</code>]</th> <td>Se uma geometria for disjunta de outra</td> <td></td> <td></td> </tr><tr><th>[[<code>Area()</code><code>DAYOFYEAR()</code>]</th> <td>A distância entre duas geometrias</td> <td></td> <td></td> </tr><tr><th>[[<code>Area()</code><code>DECODE()</code>]</th> <td>Distância mínima na Terra entre duas geometrias</td> <td></td> <td></td> </tr><tr><th>[[<code>Area()</code><code>DEFAULT()</code>]</th> <td>Ponto final de LineString</td> <td></td> <td></td> </tr><tr><th>[[<code>Area()</code><code>DEGREES()</code>]</th> <td>Retorno do MBR da geometria</td> <td></td> <td></td> </tr><tr><th>[[<code>Area()</code><code>DES_DECRYPT()</code>]</th> <td>Se uma geometria é igual à outra</td> <td></td> <td></td> </tr><tr><th>[[<code>Area()</code><code>DES_ENCRYPT()</code>]</th> <td>Anel exterior do Polygon</td> <td></td> <td></td> </tr><tr><th>[[<code>Area()</code><code>Dimension()</code>]</th> <td>Produza um valor geohash</td> <td></td> <td></td> </tr><tr><th>[[<code>AsBinary()</code><code>DAYNAME()</code>], [[<code>AsBinary()</code><code>DAYNAME()</code>], [[<code>AsBinary()</code><code>DAYOFWEEK()</code>]</th> <td>Coleção de geometria de retorno a partir de WKT</td> <td></td> <td></td> </tr><tr><th>[[<code>AsBinary()</code><code>DAYOFYEAR()</code>], [[<code>AsBinary()</code><code>DECODE()</code>]</th> <td>Coleção de geometrias de retorno do WKB</td> <td></td> <td></td> </tr><tr><th>[[<code>AsBinary()</code><code>DEFAULT()</code>]</th> <td>Retorne a N-ésima geometria da coleção de geometrias</td> <td></td> <td></td> </tr><tr><th>[[<code>AsBinary()</code><code>DEGREES()</code>]</th> <td>Retorne o nome do tipo de geometria</td> <td></td> <td></td> </tr><tr><th>[[<code>AsBinary()</code><code>DES_DECRYPT()</code>]</th> <td>Gerar geometria a partir do objeto GeoJSON</td> <td></td> <td></td> </tr><tr><th>[[<code>AsBinary()</code><code>DES_ENCRYPT()</code>], [[<code>AsBinary()</code><code>Dimension()</code>]</th> <td>Geometria de retorno a partir de WKT</td> <td></td> <td></td> </tr><tr><th>[[<code>AsWKB()</code><code>DAYNAME()</code>], [[<code>AsWKB()</code><code>DAYNAME()</code>]</th> <td>Geometria de retorno do WKB</td> <td></td> <td></td> </tr><tr><th>[[<code>AsWKB()</code><code>DAYOFWEEK()</code>]</th> <td>Retorno do N-ésimo anel interno do polígono</td> <td></td> <td></td> </tr><tr><th>[[<code>AsWKB()</code><code>DAYOFYEAR()</code>]</th> <td>Ponto de retorno definido pela interseção de duas geometrias</td> <td></td> <td></td> </tr><tr><th>[[<code>AsWKB()</code><code>DECODE()</code>]</th> <td>Se uma geometria intersecta outra</td> <td></td> <td></td> </tr><tr><th>[[<code>AsWKB()</code><code>DEFAULT()</code>]</th> <td>Se uma geometria é fechada e simples</td> <td></td> <td></td> </tr><tr><th>[[<code>AsWKB()</code><code>DEGREES()</code>]</th> <td>Se uma geometria está vazia</td> <td></td> <td></td> </tr><tr><th>[[<code>AsWKB()</code><code>DES_DECRYPT()</code>]</th> <td>Se uma geometria é simples</td> <td></td> <td></td> </tr><tr><th>[[<code>AsWKB()</code><code>DES_ENCRYPT()</code>]</th> <td>Se uma geometria é válida</td> <td></td> <td></td> </tr><tr><th>[[<code>AsWKB()</code><code>Dimension()</code>]</th> <td>Retorne a latitude a partir do valor geohash</td> <td></td> <td></td> </tr><tr><th>[[<code>ASCII()</code><code>DAYNAME()</code>]</th> <td>Comprimento de retorno da linha String</td> <td></td> <td></td> </tr><tr><th>[[<code>ASCII()</code><code>DAYNAME()</code>], [[<code>ASCII()</code><code>DAYOFWEEK()</code>]</th> <td>Construa uma linha String a partir de WKT</td> <td></td> <td></td> </tr><tr><th>[[<code>ASCII()</code><code>DAYOFYEAR()</code>], [[<code>ASCII()</code><code>DECODE()</code>]</th> <td>Construa uma linha String a partir de WKB</td> <td></td> <td></td> </tr><tr><th>[[<code>ASCII()</code><code>DEFAULT()</code>]</th> <td>Retorne a longitude a partir do valor geohash</td> <td></td> <td></td> </tr><tr><th>[[<code>ASCII()</code><code>DEGREES()</code>]</th> <td>Retângulo ao redor de dois pontos</td> <td></td> <td></td> </tr><tr><th>[[<code>ASCII()</code><code>DES_DECRYPT()</code>], [[<code>ASCII()</code><code>DES_ENCRYPT()</code>]</th> <td>Construir MultiLineString a partir de WKT</td> <td></td> <td></td> </tr><tr><th>[[<code>ASCII()</code><code>Dimension()</code>], [[<code>ASIN()</code><code>DAYNAME()</code>]</th> <td>Construir MultiLineString a partir de WKB</td> <td></td> <td></td> </tr><tr><th>[[<code>ASIN()</code><code>DAYNAME()</code>], [[<code>ASIN()</code><code>DAYOFWEEK()</code>]</th> <td>Construa o MultiPoint a partir do WKT</td> <td></td> <td></td> </tr><tr><th>[[<code>ASIN()</code><code>DAYOFYEAR()</code>], [[<code>ASIN()</code><code>DECODE()</code>]</th> <td>Construa o MultiPoint a partir do WKB</td> <td></td> <td></td> </tr><tr><th>[[<code>ASIN()</code><code>DEFAULT()</code>], [[<code>ASIN()</code><code>DEGREES()</code>]</th> <td>Construa MultiPolygon a partir de WKT</td> <td></td> <td></td> </tr><tr><th>[[<code>ASIN()</code><code>DES_DECRYPT()</code>], [[<code>ASIN()</code><code>DES_ENCRYPT()</code>]</th> <td>Construir MultiPolygon a partir de WKB</td> <td></td> <td></td> </tr><tr><th>[[<code>ASIN()</code><code>Dimension()</code>]</th> <td>Número de geometrias de volta na coleção de geometrias</td> <td></td> <td></td> </tr><tr><th>[[<code>AsText()</code><code>DAYNAME()</code>], [[<code>AsText()</code><code>DAYNAME()</code>]</th> <td>Número de anéis internos na Polygon</td> <td></td> <td></td> </tr><tr><th>[[<code>AsText()</code><code>DAYOFWEEK()</code>]</th> <td>Retorne o número de pontos na LineString</td> <td></td> <td></td> </tr><tr><th>[[<code>AsText()</code><code>DAYOFYEAR()</code>]</th> <td>Se uma geometria se sobrepõe a outra</td> <td></td> <td></td> </tr><tr><th>[[<code>AsText()</code><code>DECODE()</code>]</th> <td>Converta o valor geohash para o valor POINT</td> <td></td> <td></td> </tr><tr><th>[[<code>AsText()</code><code>DEFAULT()</code>]</th> <td>Construir ponto a partir de WKT</td> <td></td> <td></td> </tr><tr><th>[[<code>AsText()</code><code>DEGREES()</code>]</th> <td>Construa o Ponto de WKB</td> <td></td> <td></td> </tr><tr><th>[[<code>AsText()</code><code>DES_DECRYPT()</code>]</th> <td>Retorne o N-ésimo ponto da LineString</td> <td></td> <td></td> </tr><tr><th>[[<code>AsText()</code><code>DES_ENCRYPT()</code>], [[<code>AsText()</code><code>Dimension()</code>]</th> <td>Construir polígono a partir de WKT</td> <td></td> <td></td> </tr><tr><th>[[<code>AsWKT()</code><code>DAYNAME()</code>], [[<code>AsWKT()</code><code>DAYNAME()</code>]</th> <td>Construa o polígono a partir do WKB</td> <td></td> <td></td> </tr><tr><th>[[<code>AsWKT()</code><code>DAYOFWEEK()</code>]</th> <td>Retorne a geometria simplificada</td> <td></td> <td></td> </tr><tr><th>[[<code>AsWKT()</code><code>DAYOFYEAR()</code>]</th> <td>ID do sistema de referência espacial de retorno para a geometria</td> <td></td> <td></td> </tr><tr><th>[[<code>AsWKT()</code><code>DECODE()</code>]</th> <td>Ponto de início da linha String</td> <td></td> <td></td> </tr><tr><th>[[<code>AsWKT()</code><code>DEFAULT()</code>]</th> <td>Ponto de retorno definido como diferença simétrica de duas geometrias</td> <td></td> <td></td> </tr><tr><th>[[<code>AsWKT()</code><code>DEGREES()</code>]</th> <td>Se uma geometria toca outra</td> <td></td> <td></td> </tr><tr><th>[[<code>AsWKT()</code><code>DES_DECRYPT()</code>]</th> <td>União de pontos de retorno de duas geometrias</td> <td></td> <td></td> </tr><tr><th>[[<code>AsWKT()</code><code>DES_ENCRYPT()</code>]</th> <td>Retorno da geometria validada</td> <td></td> <td></td> </tr><tr><th>[[<code>AsWKT()</code><code>Dimension()</code>]</th> <td>Se uma geometria está dentro de outra</td> <td></td> <td></td> </tr><tr><th>[[<code>ATAN()</code><code>DAYNAME()</code>]</th> <td>Coordenada X de retorno do Ponto</td> <td></td> <td></td> </tr><tr><th>[[<code>ATAN()</code><code>DAYNAME()</code>]</th> <td>Coordenada Y de retorno do Ponto</td> <td></td> <td></td> </tr><tr><th>[[<code>ATAN()</code><code>DAYOFWEEK()</code>]</th> <td>Ponto de início da linha String</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>ATAN()</code><code>DAYOFYEAR()</code>]</th> <td>Retorne a desvio padrão populacional</td> <td></td> <td></td> </tr><tr><th>[[<code>ATAN()</code><code>DECODE()</code>]</th> <td>Retorne a desvio padrão populacional</td> <td></td> <td></td> </tr><tr><th>[[<code>ATAN()</code><code>DEFAULT()</code>]</th> <td>Retorne a desvio padrão populacional</td> <td></td> <td></td> </tr><tr><th>[[<code>ATAN()</code><code>DEGREES()</code>]</th> <td>Retorne a desvio padrão da amostra</td> <td></td> <td></td> </tr><tr><th>[[<code>ATAN()</code><code>DES_DECRYPT()</code>]</th> <td>Converter uma string em uma data</td> <td></td> <td></td> </tr><tr><th>[[<code>ATAN()</code><code>DES_ENCRYPT()</code>]</th> <td>Compare duas strings</td> <td></td> <td></td> </tr><tr><th>[[<code>ATAN()</code><code>Dimension()</code>]</th> <td>Sinônimo de DATE_SUB() quando invocado com três argumentos</td> <td></td> <td></td> </tr><tr><th>[[<code>ATAN2()</code><code>DAYNAME()</code>]</th> <td>Retorne a subcadeia especificada</td> <td></td> <td></td> </tr><tr><th>[[<code>ATAN2()</code><code>DAYNAME()</code>]</th> <td>Retorne a subcadeia especificada</td> <td></td> <td></td> </tr><tr><th>[[<code>ATAN2()</code><code>DAYOFWEEK()</code>]</th> <td>Retorne uma subcadeia de uma string antes do número especificado de ocorrências do delimitador</td> <td></td> <td></td> </tr><tr><th>[[<code>ATAN2()</code><code>DAYOFYEAR()</code>]</th> <td>Subtraia vezes</td> <td></td> <td></td> </tr><tr><th>[[<code>ATAN2()</code><code>DECODE()</code>]</th> <td>Devolva a soma</td> <td></td> <td></td> </tr><tr><th>[[<code>ATAN2()</code><code>DEFAULT()</code>]</th> <td>Retorne o momento em que a função é executada</td> <td></td> <td></td> </tr><tr><th>[[<code>ATAN2()</code><code>DEGREES()</code>]</th> <td>Sinônimo de USER()</td> <td></td> <td></td> </tr><tr><th>[[<code>ATAN2()</code><code>DES_DECRYPT()</code>]</th> <td>Retorne a tangente do argumento</td> <td></td> <td></td> </tr><tr><th>[[<code>ATAN2()</code><code>DES_ENCRYPT()</code>]</th> <td>Extraia a porção de tempo da expressão passada</td> <td></td> <td></td> </tr><tr><th>[[<code>ATAN2()</code><code>Dimension()</code>]</th> <td>Formato como tempo</td> <td></td> <td></td> </tr><tr><th>[[<code>ATAN()</code><code>DAYNAME()</code>]</th> <td>Retorne o argumento convertido em segundos</td> <td></td> <td></td> </tr><tr><th>[[<code>ATAN()</code><code>DAYNAME()</code>]</th> <td>Subtraia o tempo</td> <td></td> <td></td> </tr><tr><th>[[<code>ATAN()</code><code>DAYOFWEEK()</code>]</th> <td>Com um único argumento, essa função retorna a expressão de data ou datetime; com dois argumentos, a soma dos argumentos.</td> <td></td> <td></td> </tr><tr><th>[[<code>ATAN()</code><code>DAYOFYEAR()</code>]</th> <td>Adicione um intervalo a uma expressão de data e hora</td> <td></td> <td></td> </tr><tr><th>[[<code>ATAN()</code><code>DECODE()</code>]</th> <td>Retorne a diferença entre duas expressões de data e hora, usando as unidades especificadas</td> <td></td> <td></td> </tr><tr><th>[[<code>ATAN()</code><code>DEFAULT()</code>]</th> <td>Retorne o argumento convertido em uma string base-64</td> <td></td> <td></td> </tr><tr><th>[[<code>ATAN()</code><code>DEGREES()</code>]</th> <td>Retorne o argumento de data convertido em dias</td> <td></td> <td></td> </tr><tr><th>[[<code>ATAN()</code><code>DES_DECRYPT()</code>]</th> <td>Retorne o argumento de data ou datetime convertido em segundos desde o ano 0</td> <td></td> <td></td> </tr><tr><th>[[<code>ATAN()</code><code>DES_ENCRYPT()</code>]</th> <td>Se uma geometria toca outra</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>ATAN()</code><code>Dimension()</code>]</th> <td>Remova espaços em branco no início e no final</td> <td></td> <td></td> </tr><tr><th>[[<code>AVG()</code><code>DAYNAME()</code>]</th> <td>Reduzir para o número especificado de casas decimais</td> <td></td> <td></td> </tr><tr><th>[[<code>AVG()</code><code>DAYNAME()</code>]</th> <td>Sinônimo de UPPER()</td> <td></td> <td></td> </tr><tr><th>[[<code>AVG()</code><code>DAYOFWEEK()</code>]</th> <td>Descompactar uma string compactada</td> <td></td> <td></td> </tr><tr><th>[[<code>AVG()</code><code>DAYOFYEAR()</code>]</th> <td>Retorne o comprimento de uma string antes da compressão</td> <td></td> <td></td> </tr><tr><th>[[<code>AVG()</code><code>DECODE()</code>]</th> <td>Retorne uma string contendo a representação hexadecimal de um número</td> <td></td> <td></td> </tr><tr><th>[[<code>AVG()</code><code>DEFAULT()</code>]</th> <td>Retorne um timestamp Unix</td> <td></td> <td></td> </tr><tr><th>[[<code>AVG()</code><code>DEGREES()</code>]</th> <td>Retorno substituiu o fragmento XML</td> <td></td> <td></td> </tr><tr><th>[[<code>AVG()</code><code>DES_DECRYPT()</code>]</th> <td>Converta para maiúsculas</td> <td></td> <td></td> </tr><tr><th>[[<code>AVG()</code><code>DES_ENCRYPT()</code>]</th> <td>O nome de usuário e o nome do host fornecidos pelo cliente</td> <td></td> <td></td> </tr><tr><th>[[<code>AVG()</code><code>Dimension()</code>]</th> <td>Retorne a data atual UTC</td> <td></td> <td></td> </tr><tr><th>[[<code>BENCHMARK()</code><code>DAYNAME()</code>]</th> <td>Retorne a hora atual UTC</td> <td></td> <td></td> </tr><tr><th>[[<code>BENCHMARK()</code><code>DAYNAME()</code>]</th> <td>Retorne a data e hora atuais em UTC</td> <td></td> <td></td> </tr><tr><th>[[<code>BENCHMARK()</code><code>DAYOFWEEK()</code>]</th> <td>Retorne um Identificador Único Universal (UUID)</td> <td></td> <td></td> </tr><tr><th>[[<code>BENCHMARK()</code><code>DAYOFYEAR()</code>]</th> <td>Retorne um identificador universal com valor inteiro</td> <td></td> <td></td> </tr><tr><th>[[<code>BENCHMARK()</code><code>DECODE()</code>]</th> <td>Determine a força da senha</td> <td></td> <td></td> </tr><tr><th>[[<code>BENCHMARK()</code><code>DEFAULT()</code>]</th> <td>Defina os valores a serem usados durante um INSERT</td> <td></td> <td></td> </tr><tr><th>[[<code>BENCHMARK()</code><code>DEGREES()</code>]</th> <td>Retorne a variância padrão da população</td> <td></td> <td></td> </tr><tr><th>[[<code>BENCHMARK()</code><code>DES_DECRYPT()</code>]</th> <td>Retorne a variância da amostra</td> <td></td> <td></td> </tr><tr><th>[[<code>BENCHMARK()</code><code>DES_ENCRYPT()</code>]</th> <td>Retorne a variância padrão da população</td> <td></td> <td></td> </tr><tr><th>[[<code>BENCHMARK()</code><code>Dimension()</code>]</th> <td>Retorne uma string que indique a versão do servidor MySQL</td> <td></td> <td></td> </tr><tr><th>[[<code>BETWEEN ... AND ...</code><code>DAYNAME()</code>]</th> <td>Aguarde até que os GTIDs fornecidos tenham sido executados na replica.</td> <td></td> <td></td> </tr><tr><th>[[<code>BETWEEN ... AND ...</code><code>DAYNAME()</code>]</th> <td>Use [[<code>BETWEEN ... AND ...</code><code>DAYOFWEEK()</code>].</td> <td></td> <td></td> </tr><tr><th>[[<code>BETWEEN ... AND ...</code><code>DAYOFYEAR()</code>]</th> <td>Retorne o número da semana</td> <td></td> <td></td> </tr><tr><th>[[<code>BETWEEN ... AND ...</code><code>DECODE()</code>]</th> <td>Retorne o índice do dia da semana</td> <td></td> <td></td> </tr><tr><th>[[<code>BETWEEN ... AND ...</code><code>DEFAULT()</code>]</th> <td>Retorne a semana do calendário da data (1-53)</td> <td></td> <td></td> </tr><tr><th>[[<code>BETWEEN ... AND ...</code><code>DEGREES()</code>]</th> <td>Retorne a string de peso para uma string</td> <td></td> <td></td> </tr><tr><th>[[<code>BETWEEN ... AND ...</code><code>DES_DECRYPT()</code>]</th> <td>Se o MBR de uma geometria estiver dentro do MBR de outra</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>BETWEEN ... AND ...</code><code>DES_ENCRYPT()</code>]</th> <td>Coordenada X de retorno do Ponto</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>BETWEEN ... AND ...</code><code>Dimension()</code>]</th> <td>XOR lógico</td> <td></td> <td></td> </tr><tr><th>[[<code>BIN()</code><code>DAYNAME()</code>]</th> <td>Coordenada Y de retorno do Ponto</td> <td></td> <td>Sim</td> </tr><tr><th>[[<code>BIN()</code><code>DAYNAME()</code>]</th> <td>Retorne o ano</td> <td></td> <td></td> </tr><tr><th>[[<code>BIN()</code><code>DAYOFWEEK()</code>]</th> <td>Retorne o ano e a semana</td> <td></td> <td></td> </tr><tr><th>[[<code>BIN()</code><code>DAYOFYEAR()</code>]</th> <td>Bitwise OU</td> <td></td> <td></td> </tr><tr><th>[[<code>BIN()</code><code>DECODE()</code>]</th> <td>Inversão bit a bit</td> <td></td> <td></td> </tr></tbody></table>
