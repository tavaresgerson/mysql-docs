### 12.16.1 Referência de Função Espacial

A tabela a seguir lista cada função espacial e fornece uma breve descrição de cada uma.

**Tabela 12.21 Funções Espaciais**

<table frame="box" rules="all" summary="Uma referência que lista todas as funções espaciais."><col style="width: 25%"/><col style="width: 62%"/><col style="width: 12%"/><thead><tr><th>Nome</th> <th>Descrição</th> <th>Desatualizado</th> </tr></thead><tbody><tr><th>[[PH_HTML_CODE_<code>ST_GeomCollFromText()</code>]</th> <td>Área de Retângulo ou MultiRetângulo</td> <td>Sim</td> </tr><tr><th>[[PH_HTML_CODE_<code>ST_GeomCollFromText()</code>], [[PH_HTML_CODE_<code>ST_GeomCollFromTxt()</code>]</th> <td>Converter de formato de geometria interna para WKB</td> <td>Sim</td> </tr><tr><th>[[PH_HTML_CODE_<code>ST_GeomCollFromWKB()</code>], [[PH_HTML_CODE_<code>ST_GeometryCollectionFromWKB()</code>]</th> <td>Converter de formato de geometria interna para WKT</td> <td>Sim</td> </tr><tr><th>[[PH_HTML_CODE_<code>ST_GeometryN()</code>]</th> <td>Geometria de retorno de pontos dentro da distância dada da geometria</td> <td>Sim</td> </tr><tr><th>[[PH_HTML_CODE_<code>ST_GeometryType()</code>]</th> <td>Retorne o centroide como um ponto</td> <td>Sim</td> </tr><tr><th>[[PH_HTML_CODE_<code>ST_GeomFromGeoJSON()</code>]</th> <td>Se o MBR de uma geometria contém o MBR de outra</td> <td>Sim</td> </tr><tr><th>[[PH_HTML_CODE_<code>ST_GeomFromText()</code>]</th> <td>Hull convexo de geometria</td> <td>Sim</td> </tr><tr><th>[[PH_HTML_CODE_<code>ST_GeometryFromText()</code>]</th> <td>Se uma geometria cruza outra</td> <td>Sim</td> </tr><tr><th>[[<code>AsBinary()</code><code>ST_GeomCollFromText()</code>]</th> <td>Dimensão da geometria</td> <td>Sim</td> </tr><tr><th>[[<code>AsBinary()</code><code>ST_GeomCollFromText()</code>]</th> <td>Se os MBRs de duas geometrias são disjuntos</td> <td>Sim</td> </tr><tr><th>[[<code>AsBinary()</code><code>ST_GeomCollFromTxt()</code>]</th> <td>Ponto final de LineString</td> <td>Sim</td> </tr><tr><th>[[<code>AsBinary()</code><code>ST_GeomCollFromWKB()</code>]</th> <td>Retorno do MBR da geometria</td> <td>Sim</td> </tr><tr><th>[[<code>AsBinary()</code><code>ST_GeometryCollectionFromWKB()</code>]</th> <td>Se os MBRs de duas geometrias são iguais</td> <td>Sim</td> </tr><tr><th>[[<code>AsBinary()</code><code>ST_GeometryN()</code>]</th> <td>Anel exterior do Polygon</td> <td>Sim</td> </tr><tr><th>[[<code>AsBinary()</code><code>ST_GeometryType()</code>], [[<code>AsBinary()</code><code>ST_GeomFromGeoJSON()</code>]</th> <td>Coleção de geometria de retorno a partir de WKT</td> <td>Sim</td> </tr><tr><th>[[<code>AsBinary()</code><code>ST_GeomFromText()</code>], [[<code>AsBinary()</code><code>ST_GeometryFromText()</code>]</th> <td>Coleção de geometrias de retorno do WKB</td> <td>Sim</td> </tr><tr><th>[[<code>AsWKB()</code><code>ST_GeomCollFromText()</code>]</th> <td>Construa a coleção de geometrias a partir de geometrias</td> <td></td> </tr><tr><th>[[<code>AsWKB()</code><code>ST_GeomCollFromText()</code>]</th> <td>Retorne a N-ésima geometria da coleção de geometrias</td> <td>Sim</td> </tr><tr><th>[[<code>AsWKB()</code><code>ST_GeomCollFromTxt()</code>]</th> <td>Retorne o nome do tipo de geometria</td> <td>Sim</td> </tr><tr><th>[[<code>AsWKB()</code><code>ST_GeomCollFromWKB()</code>], [[<code>AsWKB()</code><code>ST_GeometryCollectionFromWKB()</code>]</th> <td>Geometria de retorno a partir de WKT</td> <td>Sim</td> </tr><tr><th>[[<code>AsWKB()</code><code>ST_GeometryN()</code>], [[<code>AsWKB()</code><code>ST_GeometryType()</code>]</th> <td>Geometria de retorno do WKB</td> <td>Sim</td> </tr><tr><th>[[<code>AsWKB()</code><code>ST_GeomFromGeoJSON()</code>]</th> <td>Comprimento de retorno da linha String</td> <td>Sim</td> </tr><tr><th>[[<code>AsWKB()</code><code>ST_GeomFromText()</code>]</th> <td>Retorno do N-ésimo anel interno do polígono</td> <td>Sim</td> </tr><tr><th>[[<code>AsWKB()</code><code>ST_GeometryFromText()</code>]</th> <td>Se os MBRs de duas geometrias se intersectam</td> <td>Sim</td> </tr><tr><th>[[<code>AsText()</code><code>ST_GeomCollFromText()</code>]</th> <td>Se uma geometria é fechada e simples</td> <td>Sim</td> </tr><tr><th>[[<code>AsText()</code><code>ST_GeomCollFromText()</code>]</th> <td>Se uma geometria está vazia</td> <td>Sim</td> </tr><tr><th>[[<code>AsText()</code><code>ST_GeomCollFromTxt()</code>]</th> <td>Se uma geometria é simples</td> <td>Sim</td> </tr><tr><th>[[<code>AsText()</code><code>ST_GeomCollFromWKB()</code>], [[<code>AsText()</code><code>ST_GeometryCollectionFromWKB()</code>]</th> <td>Construa uma linha String a partir de WKT</td> <td>Sim</td> </tr><tr><th>[[<code>AsText()</code><code>ST_GeometryN()</code>], [[<code>AsText()</code><code>ST_GeometryType()</code>]</th> <td>Construa uma linha String a partir de WKB</td> <td>Sim</td> </tr><tr><th>[[<code>AsText()</code><code>ST_GeomFromGeoJSON()</code>]</th> <td>Construa uma linha String a partir de valores de ponto</td> <td></td> </tr><tr><th>[[<code>AsText()</code><code>ST_GeomFromText()</code>]</th> <td>Se o MBR de uma geometria contém o MBR de outra</td> <td></td> </tr><tr><th>[[<code>AsText()</code><code>ST_GeometryFromText()</code>]</th> <td>Se um MBR estiver coberto por outro</td> <td></td> </tr><tr><th>[[<code>AsWKT()</code><code>ST_GeomCollFromText()</code>]</th> <td>Se um MBR cobre outro</td> <td></td> </tr><tr><th>[[<code>AsWKT()</code><code>ST_GeomCollFromText()</code>]</th> <td>Se os MBRs de duas geometrias são disjuntos</td> <td></td> </tr><tr><th>[[<code>AsWKT()</code><code>ST_GeomCollFromTxt()</code>]</th> <td>Se os MBRs de duas geometrias são iguais</td> <td>Sim</td> </tr><tr><th>[[<code>AsWKT()</code><code>ST_GeomCollFromWKB()</code>]</th> <td>Se os MBRs de duas geometrias são iguais</td> <td></td> </tr><tr><th>[[<code>AsWKT()</code><code>ST_GeometryCollectionFromWKB()</code>]</th> <td>Se os MBRs de duas geometrias se intersectam</td> <td></td> </tr><tr><th>[[<code>AsWKT()</code><code>ST_GeometryN()</code>]</th> <td>Se os MBRs de duas geometrias se sobrepõem</td> <td></td> </tr><tr><th>[[<code>AsWKT()</code><code>ST_GeometryType()</code>]</th> <td>Se os MBRs de duas geometrias se tocam</td> <td></td> </tr><tr><th>[[<code>AsWKT()</code><code>ST_GeomFromGeoJSON()</code>]</th> <td>Se o MBR de uma geometria estiver dentro do MBR de outra</td> <td></td> </tr><tr><th>[[<code>AsWKT()</code><code>ST_GeomFromText()</code>], [[<code>AsWKT()</code><code>ST_GeometryFromText()</code>]</th> <td>Construir MultiLineString a partir de WKT</td> <td>Sim</td> </tr><tr><th>[[<code>Buffer()</code><code>ST_GeomCollFromText()</code>], [[<code>Buffer()</code><code>ST_GeomCollFromText()</code>]</th> <td>Construir MultiLineString a partir de WKB</td> <td>Sim</td> </tr><tr><th>[[<code>Buffer()</code><code>ST_GeomCollFromTxt()</code>], [[<code>Buffer()</code><code>ST_GeomCollFromWKB()</code>]</th> <td>Construa o MultiPoint a partir do WKT</td> <td>Sim</td> </tr><tr><th>[[<code>Buffer()</code><code>ST_GeometryCollectionFromWKB()</code>], [[<code>Buffer()</code><code>ST_GeometryN()</code>]</th> <td>Construa o MultiPoint a partir do WKB</td> <td>Sim</td> </tr><tr><th>[[<code>Buffer()</code><code>ST_GeometryType()</code>], [[<code>Buffer()</code><code>ST_GeomFromGeoJSON()</code>]</th> <td>Construa MultiPolygon a partir de WKT</td> <td>Sim</td> </tr><tr><th>[[<code>Buffer()</code><code>ST_GeomFromText()</code>], [[<code>Buffer()</code><code>ST_GeometryFromText()</code>]</th> <td>Construir MultiPolygon a partir de WKB</td> <td>Sim</td> </tr><tr><th>[[<code>Centroid()</code><code>ST_GeomCollFromText()</code>]</th> <td>Construir MultiLineString a partir de valores de LineString</td> <td></td> </tr><tr><th>[[<code>Centroid()</code><code>ST_GeomCollFromText()</code>]</th> <td>Construa o MultiPoint a partir de valores de ponto</td> <td></td> </tr><tr><th>[[<code>Centroid()</code><code>ST_GeomCollFromTxt()</code>]</th> <td>Construir MultiPolygon a partir de valores Polygon</td> <td></td> </tr><tr><th>[[<code>Centroid()</code><code>ST_GeomCollFromWKB()</code>]</th> <td>Número de geometrias de volta na coleção de geometrias</td> <td>Sim</td> </tr><tr><th>[[<code>Centroid()</code><code>ST_GeometryCollectionFromWKB()</code>]</th> <td>Número de anéis internos na Polygon</td> <td>Sim</td> </tr><tr><th>[[<code>Centroid()</code><code>ST_GeometryN()</code>]</th> <td>Retorne o número de pontos na LineString</td> <td>Sim</td> </tr><tr><th>[[<code>Centroid()</code><code>ST_GeometryType()</code>]</th> <td>Se os MBRs de duas geometrias se sobrepõem</td> <td>Sim</td> </tr><tr><th>[[<code>Centroid()</code><code>ST_GeomFromGeoJSON()</code>]</th> <td>Construir ponto a partir de coordenadas</td> <td></td> </tr><tr><th>[[<code>Centroid()</code><code>ST_GeomFromText()</code>]</th> <td>Construir ponto a partir de WKT</td> <td>Sim</td> </tr><tr><th>[[<code>Centroid()</code><code>ST_GeometryFromText()</code>]</th> <td>Construa o Ponto de WKB</td> <td>Sim</td> </tr><tr><th>[[<code>Contains()</code><code>ST_GeomCollFromText()</code>]</th> <td>Retorne o N-ésimo ponto da LineString</td> <td>Sim</td> </tr><tr><th>[[<code>Contains()</code><code>ST_GeomCollFromText()</code>], [[<code>Contains()</code><code>ST_GeomCollFromTxt()</code>]</th> <td>Construir polígono a partir de WKT</td> <td>Sim</td> </tr><tr><th>[[<code>Contains()</code><code>ST_GeomCollFromWKB()</code>], [[<code>Contains()</code><code>ST_GeometryCollectionFromWKB()</code>]</th> <td>Construa o polígono a partir do WKB</td> <td>Sim</td> </tr><tr><th>[[<code>Contains()</code><code>ST_GeometryN()</code>]</th> <td>Construir polígono a partir de argumentos LineString</td> <td></td> </tr><tr><th>[[<code>Contains()</code><code>ST_GeometryType()</code>]</th> <td>A distância entre duas geometrias</td> <td>Sim</td> </tr><tr><th>[[<code>Contains()</code><code>ST_GeomFromGeoJSON()</code>]</th> <td>ID do sistema de referência espacial de retorno para a geometria</td> <td>Sim</td> </tr><tr><th>[[<code>Contains()</code><code>ST_GeomFromText()</code>]</th> <td>Área de Retângulo ou MultiRetângulo</td> <td></td> </tr><tr><th>[[<code>Contains()</code><code>ST_GeometryFromText()</code>], [[<code>ConvexHull()</code><code>ST_GeomCollFromText()</code>]</th> <td>Converter de formato de geometria interna para WKB</td> <td></td> </tr><tr><th>[[<code>ConvexHull()</code><code>ST_GeomCollFromText()</code>]</th> <td>Gerar objeto GeoJSON a partir da geometria</td> <td></td> </tr><tr><th>[[<code>ConvexHull()</code><code>ST_GeomCollFromTxt()</code>], [[<code>ConvexHull()</code><code>ST_GeomCollFromWKB()</code>]</th> <td>Converter de formato de geometria interna para WKT</td> <td></td> </tr><tr><th>[[<code>ConvexHull()</code><code>ST_GeometryCollectionFromWKB()</code>]</th> <td>Geometria de retorno de pontos dentro da distância dada da geometria</td> <td></td> </tr><tr><th>[[<code>ConvexHull()</code><code>ST_GeometryN()</code>]</th> <td>Produza a opção de estratégia para o ST_Buffer()</td> <td></td> </tr><tr><th>[[<code>ConvexHull()</code><code>ST_GeometryType()</code>]</th> <td>Retorne o centroide como um ponto</td> <td></td> </tr><tr><th>[[<code>ConvexHull()</code><code>ST_GeomFromGeoJSON()</code>]</th> <td>Se uma geometria contém outra</td> <td></td> </tr><tr><th>[[<code>ConvexHull()</code><code>ST_GeomFromText()</code>]</th> <td>Hull convexo de geometria</td> <td></td> </tr><tr><th>[[<code>ConvexHull()</code><code>ST_GeometryFromText()</code>]</th> <td>Se uma geometria cruza outra</td> <td></td> </tr><tr><th>[[<code>Crosses()</code><code>ST_GeomCollFromText()</code>]</th> <td>Diferença de ponto de retorno entre duas geometrias</td> <td></td> </tr><tr><th>[[<code>Crosses()</code><code>ST_GeomCollFromText()</code>]</th> <td>Dimensão da geometria</td> <td></td> </tr><tr><th>[[<code>Crosses()</code><code>ST_GeomCollFromTxt()</code>]</th> <td>Se uma geometria for disjunta de outra</td> <td></td> </tr><tr><th>[[<code>Crosses()</code><code>ST_GeomCollFromWKB()</code>]</th> <td>A distância entre duas geometrias</td> <td></td> </tr><tr><th>[[<code>Crosses()</code><code>ST_GeometryCollectionFromWKB()</code>]</th> <td>Distância mínima na Terra entre duas geometrias</td> <td></td> </tr><tr><th>[[<code>Crosses()</code><code>ST_GeometryN()</code>]</th> <td>Ponto final de LineString</td> <td></td> </tr><tr><th>[[<code>Crosses()</code><code>ST_GeometryType()</code>]</th> <td>Retorno do MBR da geometria</td> <td></td> </tr><tr><th>[[<code>Crosses()</code><code>ST_GeomFromGeoJSON()</code>]</th> <td>Se uma geometria é igual à outra</td> <td></td> </tr><tr><th>[[<code>Crosses()</code><code>ST_GeomFromText()</code>]</th> <td>Anel exterior do Polygon</td> <td></td> </tr><tr><th>[[<code>Crosses()</code><code>ST_GeometryFromText()</code>]</th> <td>Produza um valor geohash</td> <td></td> </tr><tr><th>[[PH_HTML_CÓDIGO_10<code>ST_GeomCollFromText()</code>], [[PH_HTML_CÓDIGO_10<code>ST_GeomCollFromText()</code>], [[PH_HTML_CÓDIGO_10<code>ST_GeomCollFromTxt()</code>]</th> <td>Coleção de geometria de retorno a partir de WKT</td> <td></td> </tr><tr><th>[[<code>ST_GeomCollFromWKB()</code>]], [[<code>ST_GeometryCollectionFromWKB()</code>]]</th> <td>Coleção de geometrias de retorno do WKB</td> <td></td> </tr><tr><th>[[<code>ST_GeometryN()</code>]]</th> <td>Retorne a N-ésima geometria da coleção de geometrias</td> <td></td> </tr><tr><th>[[<code>ST_GeometryType()</code>]]</th> <td>Retorne o nome do tipo de geometria</td> <td></td> </tr><tr><th>[[<code>ST_GeomFromGeoJSON()</code>]]</th> <td>Gerar geometria a partir do objeto GeoJSON</td> <td></td> </tr><tr><th>[[<code>ST_GeomFromText()</code>]], [[<code>ST_GeometryFromText()</code>]]</th> <td>Geometria de retorno a partir de WKT</td> <td></td> </tr><tr><th>[[<code>Disjoint()</code><code>ST_GeomCollFromText()</code>], [[<code>Disjoint()</code><code>ST_GeomCollFromText()</code>]</th> <td>Geometria de retorno do WKB</td> <td></td> </tr><tr><th>[[<code>Disjoint()</code><code>ST_GeomCollFromTxt()</code>]</th> <td>Retorno do N-ésimo anel interno do polígono</td> <td></td> </tr><tr><th>[[<code>Disjoint()</code><code>ST_GeomCollFromWKB()</code>]</th> <td>Ponto de retorno definido pela interseção de duas geometrias</td> <td></td> </tr><tr><th>[[<code>Disjoint()</code><code>ST_GeometryCollectionFromWKB()</code>]</th> <td>Se uma geometria intersecta outra</td> <td></td> </tr><tr><th>[[<code>Disjoint()</code><code>ST_GeometryN()</code>]</th> <td>Se uma geometria é fechada e simples</td> <td></td> </tr><tr><th>[[<code>Disjoint()</code><code>ST_GeometryType()</code>]</th> <td>Se uma geometria está vazia</td> <td></td> </tr><tr><th>[[<code>Disjoint()</code><code>ST_GeomFromGeoJSON()</code>]</th> <td>Se uma geometria é simples</td> <td></td> </tr><tr><th>[[<code>Disjoint()</code><code>ST_GeomFromText()</code>]</th> <td>Se uma geometria é válida</td> <td></td> </tr><tr><th>[[<code>Disjoint()</code><code>ST_GeometryFromText()</code>]</th> <td>Retorne a latitude a partir do valor geohash</td> <td></td> </tr><tr><th>[[<code>EndPoint()</code><code>ST_GeomCollFromText()</code>]</th> <td>Comprimento de retorno da linha String</td> <td></td> </tr><tr><th>[[<code>EndPoint()</code><code>ST_GeomCollFromText()</code>], [[<code>EndPoint()</code><code>ST_GeomCollFromTxt()</code>]</th> <td>Construa uma linha String a partir de WKT</td> <td></td> </tr><tr><th>[[<code>EndPoint()</code><code>ST_GeomCollFromWKB()</code>], [[<code>EndPoint()</code><code>ST_GeometryCollectionFromWKB()</code>]</th> <td>Construa uma linha String a partir de WKB</td> <td></td> </tr><tr><th>[[<code>EndPoint()</code><code>ST_GeometryN()</code>]</th> <td>Retorne a longitude a partir do valor geohash</td> <td></td> </tr><tr><th>[[<code>EndPoint()</code><code>ST_GeometryType()</code>]</th> <td>Retângulo ao redor de dois pontos</td> <td></td> </tr><tr><th>[[<code>EndPoint()</code><code>ST_GeomFromGeoJSON()</code>], [[<code>EndPoint()</code><code>ST_GeomFromText()</code>]</th> <td>Construir MultiLineString a partir de WKT</td> <td></td> </tr><tr><th>[[<code>EndPoint()</code><code>ST_GeometryFromText()</code>], [[<code>Envelope()</code><code>ST_GeomCollFromText()</code>]</th> <td>Construir MultiLineString a partir de WKB</td> <td></td> </tr><tr><th>[[<code>Envelope()</code><code>ST_GeomCollFromText()</code>], [[<code>Envelope()</code><code>ST_GeomCollFromTxt()</code>]</th> <td>Construa o MultiPoint a partir do WKT</td> <td></td> </tr><tr><th>[[<code>Envelope()</code><code>ST_GeomCollFromWKB()</code>], [[<code>Envelope()</code><code>ST_GeometryCollectionFromWKB()</code>]</th> <td>Construa o MultiPoint a partir do WKB</td> <td></td> </tr><tr><th>[[<code>Envelope()</code><code>ST_GeometryN()</code>], [[<code>Envelope()</code><code>ST_GeometryType()</code>]</th> <td>Construa MultiPolygon a partir de WKT</td> <td></td> </tr><tr><th>[[<code>Envelope()</code><code>ST_GeomFromGeoJSON()</code>], [[<code>Envelope()</code><code>ST_GeomFromText()</code>]</th> <td>Construir MultiPolygon a partir de WKB</td> <td></td> </tr><tr><th>[[<code>Envelope()</code><code>ST_GeometryFromText()</code>]</th> <td>Número de geometrias de volta na coleção de geometrias</td> <td></td> </tr><tr><th>[[<code>Equals()</code><code>ST_GeomCollFromText()</code>], [[<code>Equals()</code><code>ST_GeomCollFromText()</code>]</th> <td>Número de anéis internos na Polygon</td> <td></td> </tr><tr><th>[[<code>Equals()</code><code>ST_GeomCollFromTxt()</code>]</th> <td>Retorne o número de pontos na LineString</td> <td></td> </tr><tr><th>[[<code>Equals()</code><code>ST_GeomCollFromWKB()</code>]</th> <td>Se uma geometria se sobrepõe a outra</td> <td></td> </tr><tr><th>[[<code>Equals()</code><code>ST_GeometryCollectionFromWKB()</code>]</th> <td>Converta o valor geohash para o valor POINT</td> <td></td> </tr><tr><th>[[<code>Equals()</code><code>ST_GeometryN()</code>]</th> <td>Construir ponto a partir de WKT</td> <td></td> </tr><tr><th>[[<code>Equals()</code><code>ST_GeometryType()</code>]</th> <td>Construa o Ponto de WKB</td> <td></td> </tr><tr><th>[[<code>Equals()</code><code>ST_GeomFromGeoJSON()</code>]</th> <td>Retorne o N-ésimo ponto da LineString</td> <td></td> </tr><tr><th>[[<code>Equals()</code><code>ST_GeomFromText()</code>], [[<code>Equals()</code><code>ST_GeometryFromText()</code>]</th> <td>Construir polígono a partir de WKT</td> <td></td> </tr><tr><th>[[<code>ExteriorRing()</code><code>ST_GeomCollFromText()</code>], [[<code>ExteriorRing()</code><code>ST_GeomCollFromText()</code>]</th> <td>Construa o polígono a partir do WKB</td> <td></td> </tr><tr><th>[[<code>ExteriorRing()</code><code>ST_GeomCollFromTxt()</code>]</th> <td>Retorne a geometria simplificada</td> <td></td> </tr><tr><th>[[<code>ExteriorRing()</code><code>ST_GeomCollFromWKB()</code>]</th> <td>ID do sistema de referência espacial de retorno para a geometria</td> <td></td> </tr><tr><th>[[<code>ExteriorRing()</code><code>ST_GeometryCollectionFromWKB()</code>]</th> <td>Ponto de início da linha String</td> <td></td> </tr><tr><th>[[<code>ExteriorRing()</code><code>ST_GeometryN()</code>]</th> <td>Ponto de retorno definido como diferença simétrica de duas geometrias</td> <td></td> </tr><tr><th>[[<code>ExteriorRing()</code><code>ST_GeometryType()</code>]</th> <td>Se uma geometria toca outra</td> <td></td> </tr><tr><th>[[<code>ExteriorRing()</code><code>ST_GeomFromGeoJSON()</code>]</th> <td>União de pontos de retorno de duas geometrias</td> <td></td> </tr><tr><th>[[<code>ExteriorRing()</code><code>ST_GeomFromText()</code>]</th> <td>Retorno da geometria validada</td> <td></td> </tr><tr><th>[[<code>ExteriorRing()</code><code>ST_GeometryFromText()</code>]</th> <td>Se uma geometria está dentro de outra</td> <td></td> </tr><tr><th>[[<code>GeomCollFromText()</code><code>ST_GeomCollFromText()</code>]</th> <td>Coordenada X de retorno do Ponto</td> <td></td> </tr><tr><th>[[<code>GeomCollFromText()</code><code>ST_GeomCollFromText()</code>]</th> <td>Coordenada Y de retorno do Ponto</td> <td></td> </tr><tr><th>[[<code>GeomCollFromText()</code><code>ST_GeomCollFromTxt()</code>]</th> <td>Ponto de início da linha String</td> <td>Sim</td> </tr><tr><th>[[<code>GeomCollFromText()</code><code>ST_GeomCollFromWKB()</code>]</th> <td>Se uma geometria toca outra</td> <td>Sim</td> </tr><tr><th>[[<code>GeomCollFromText()</code><code>ST_GeometryCollectionFromWKB()</code>]</th> <td>Se o MBR de uma geometria estiver dentro do MBR de outra</td> <td>Sim</td> </tr><tr><th>[[<code>GeomCollFromText()</code><code>ST_GeometryN()</code>]</th> <td>Coordenada X de retorno do Ponto</td> <td>Sim</td> </tr><tr><th>[[<code>GeomCollFromText()</code><code>ST_GeometryType()</code>]</th> <td>Coordenada Y de retorno do Ponto</td> <td>Sim</td> </tr></tbody></table>
