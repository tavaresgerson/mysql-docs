### 7.5.2 Recuperação no Ponto de Tempo Usando Posições de Eventos

A última seção, Seção 7.5.1, “Recuperação em Ponto no Tempo Usando Log Binary”, explica a ideia geral de usar o log binary para realizar uma recuperação em ponto no tempo. A seção explica a operação em detalhes com um exemplo.

Como exemplo, suponha que, por volta das 13:00:00 de 27 de maio de 2020, uma instrução SQL foi executada para excluir uma tabela. Você pode realizar uma recuperação em um ponto específico para restaurar o servidor até seu estado imediatamente antes da exclusão da tabela. Aqui estão alguns passos de exemplo para isso:

1. Restaure a última cópia de segurança completa criada antes do ponto de interesse (chame-a de `tp`, que é 13:00:00 em 27 de maio de 2020, no nosso exemplo). Quando terminar, anote a posição do log binário até a qual você restaurou o servidor para uso posterior e reinicie o servidor.

  Nota

  Embora a última posição do log binário recuperada também seja exibida pelo InnoDB após a restauração e o reinício do servidor, essa não é uma maneira confiável de obter a posição final do log da restauração, pois podem ocorrer eventos de DDL e alterações não relacionadas ao InnoDB após o tempo refletido pela posição exibida. Sua ferramenta de backup e restauração deve fornecer a última posição do log binário para sua recuperação: por exemplo, se você estiver usando o **mysqlbinlog** para a tarefa, verifique a posição de parada da reprodução do log binário; se estiver usando o MySQL Enterprise Backup, a última posição do log binário foi salva em seu backup. Veja a Recuperação em Ponto no Tempo.

2. Encontre a posição exata do evento de log binário correspondente ao momento até o qual deseja restaurar seu banco de dados. No nosso exemplo, dado que sabemos o horário aproximado em que a exclusão da tabela ocorreu (`tp`), podemos encontrar a posição do log verificando o conteúdo do log por volta desse tempo usando o utilitário **mysqlbinlog**. Use as opções `--start-datetime` e `--stop-datetime` para especificar um curto período de tempo em torno de `tp`, e então procure o evento na saída. Por exemplo:

   ```sh
   $> mysqlbinlog   --start-datetime="2020-05-27 12:59:00" --stop-datetime="2020-05-27 13:06:00" \
     --verbose /var/lib/mysql/bin.123456 | grep -C 12 "DROP TABLE"
   # at 1868
   #200527 13:00:30 server id 2  end_log_pos 1985 CRC32 0x8b894489 	Query	thread_id=8	exec_time=0	error_code=0
   use `pets`/*!*/;
   SET TIMESTAMP=1590598830/*!*/;
   SET @@session.pseudo_thread_id=8/*!*/;
   SET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0, @@session.unique_checks=1, @@session.autocommit=1/*!*/;
   SET @@session.sql_mode=1436549152/*!80005 &~0x1003ff00*//*!*/;
   SET @@session.auto_increment_increment=1, @@session.auto_increment_offset=1/*!*/;
   /*!\C latin1 *//*!*/;
   SET @@session.character_set_client=8,@@session.collation_connection=8,@@session.collation_server=8/*!*/;
   SET @@session.lc_time_names=0/*!*/;
   SET @@session.collation_database=DEFAULT/*!*/;
   DROP TABLE `cats` /* generated by server */
   /*!*/;
   # at 1985
   #200527 13:05:06 server id 2  end_log_pos 2050 CRC32 0x2f8d0249 	Anonymous_GTID	last_committed=6	sequence_number=7	rbr_only=yes	original_committed_timestamp=0	immediate_commit_timestamp=0	transaction_length=0
   /*!50718 SET TRANSACTION ISOLATION LEVEL READ COMMITTED*//*!*/;
   # original_commit_timestamp=0 (1969-12-31 19:00:00.000000 EST)
   # immediate_commit_timestamp=0 (1969-12-31 19:00:00.000000 EST)
   /*!80001 SET @@session.original_commit_timestamp=0*//*!*/;
   /*!80014 SET @@session.original_server_version=0*//*!*/;
   /*!80014 SET @@session.immediate_server_version=0*//*!*/;
   SET @@SESSION.GTID_NEXT= 'ANONYMOUS'/*!*/;
   # at 2050
   #200527 13:05:06 server id 2  end_log_pos 2122 CRC32 0x56280bb1 	Query	thread_id=8	exec_time=0	error_code=0
   ```

   No resultado do **mysqlbinlog**, a instrução `DROP TABLE `pets`.`cats`pode ser encontrada no segmento do log binário entre a linha`# em 1868`e`# em 1985`, o que significa que a instrução ocorre *após* a posição do log 1868, e o log está na posição 1985 após a instrução `DROP TABLE\`.

  Nota

  Use apenas as opções `--start-datetime` e `--stop-datetime` para ajudá-lo a encontrar as posições reais dos eventos de interesse. Não é recomendado usar as duas opções para especificar o intervalo de segmento de log binário a ser aplicado, pois há um risco maior de perder eventos de log binário ao usar essas opções. Use `--start-position` e `--stop-position` em vez disso.

3. Aplique os eventos no arquivo de log binário no servidor, começando com a posição do log que você encontrou no passo 1 (assumindo que é 1006) e terminando na posição que você encontrou no passo 2, que é *antes* do seu ponto de interesse (que é 1868):

   ```sh
   $> mysqlbinlog --start-position=1006 --stop-position=1868 /var/lib/mysql/bin.123456 \
            | mysql -u root -p
   ```

   O comando recupera todas as transações a partir da posição inicial até pouco antes da posição de parada. Como o resultado do **mysqlbinlog** inclui as instruções `SET TIMESTAMP` antes de cada instrução SQL registrada, os dados recuperados e os logs do MySQL relacionados refletem os tempos originais em que as transações foram executadas.

   Seu banco de dados foi restaurado ao ponto de interesse, `tp`, logo antes da tabela `pets.cats` ter sido excluída.

4. Além da recuperação no ponto no tempo que foi concluída, se você também quiser reexecutar todas as declarações *após* o seu ponto no tempo de interesse, use **mysqlbinlog** novamente para aplicar todos os eventos após `tp` ao servidor. Observamos no passo 2 que, após a declaração que queríamos pular, o log está na posição 1985; podemos usá-lo para a opção `--start-position`, para que quaisquer declarações após a posição sejam incluídas:

   ```sh
   $> mysqlbinlog --start-position=1985 /var/lib/mysql/bin.123456 \
            | mysql -u root -p
   ```

   Seu banco de dados foi restaurado com a última declaração registrada no arquivo de log binário, mas o evento selecionado foi ignorado.
