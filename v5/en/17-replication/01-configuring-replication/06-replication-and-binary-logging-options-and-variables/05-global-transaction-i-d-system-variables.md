#### 16.1.6.5 Global Transaction ID System Variables

The MySQL Server system variables described in this section are used to monitor and control Global Transaction Identifiers (GTIDs). For additional information, see [Section 16.1.3, “Replication with Global Transaction Identifiers”](replication-gtids.html "16.1.3 Replication with Global Transaction Identifiers").

* [`binlog_gtid_simple_recovery`](replication-options-gtids.html#sysvar_binlog_gtid_simple_recovery)

  <table frame="box" rules="all" summary="Properties for binlog_gtid_simple_recovery"><col style="width: 30%"/><col style="width: 70%"/><tbody><tr><th>Command-Line Format</th> <td><code class="literal">--binlog-gtid-simple-recovery[={OFF|ON}]</code></td> </tr><tr><th>System Variable</th> <td><code class="literal"><a class="link" href="replication-options-gtids.html#sysvar_binlog_gtid_simple_recovery">binlog_gtid_simple_recovery</a></code></td> </tr><tr><th>Scope</th> <td>Global</td> </tr><tr><th>Dynamic</th> <td>No</td> </tr><tr><th>Type</th> <td>Boolean</td> </tr><tr><th>Default Value</th> <td><code class="literal">ON</code></td> </tr></tbody></table>

  This variable controls how binary log files are iterated during the search for GTIDs when MySQL starts or restarts.

  When [`binlog_gtid_simple_recovery=TRUE`](replication-options-gtids.html#sysvar_binlog_gtid_simple_recovery), which is the default, the values of [`gtid_executed`](replication-options-gtids.html#sysvar_gtid_executed) and [`gtid_purged`](replication-options-gtids.html#sysvar_gtid_purged) are computed at startup based on the values of `Previous_gtids_log_event` in the most recent and oldest binary log files. For a description of the computation, see [The `gtid_purged` System Variable](replication-gtids-lifecycle.html#replication-gtids-gtid-purged "The gtid_purged System Variable"). This setting accesses only two binary log files during server restart. If all binary logs on the server were generated using MySQL 5.7.8 or later and you are using MySQL 5.7.8 or later, [`binlog_gtid_simple_recovery=TRUE`](replication-options-gtids.html#sysvar_binlog_gtid_simple_recovery) can always safely be used.

  With [`binlog_gtid_simple_recovery=TRUE`](replication-options-gtids.html#sysvar_binlog_gtid_simple_recovery), [`gtid_executed`](replication-options-gtids.html#sysvar_gtid_executed) and [`gtid_purged`](replication-options-gtids.html#sysvar_gtid_purged) might be initialized incorrectly in the following two situations:

  + The newest binary log was generated by MySQL 5.7.5 or earlier, and [`gtid_mode`](replication-options-gtids.html#sysvar_gtid_mode) was `ON` for some binary logs but `OFF` for the newest binary log.

  + A `SET @@GLOBAL.gtid_purged` statement was issued on MySQL 5.7.7 or earlier, and the binary log that was active at the time of the `SET @@GLOBAL.gtid_purged` statement has not yet been purged.

  If an incorrect GTID set is computed in either situation, it remains incorrect even if the server is later restarted with [`binlog_gtid_simple_recovery=FALSE`](replication-options-gtids.html#sysvar_binlog_gtid_simple_recovery). If either of these situations applies on the server, set [`binlog_gtid_simple_recovery=FALSE`](replication-options-gtids.html#sysvar_binlog_gtid_simple_recovery) before starting or restarting the server. To check for the second situation, if you are using MySQL 5.7.7 or earlier, after issuing a `SET @@GLOBAL.gtid_purged` statement note down the current binary log file name, which can be checked using [`SHOW MASTER STATUS`](show-master-status.html "13.7.5.23 SHOW MASTER STATUS Statement"). If the server is restarted before this file has been purged, then you should set [`binlog_gtid_simple_recovery=FALSE`](replication-options-gtids.html#sysvar_binlog_gtid_simple_recovery).

  When [`binlog_gtid_simple_recovery=FALSE`](replication-options-gtids.html#sysvar_binlog_gtid_simple_recovery) is set, the method of computing [`gtid_executed`](replication-options-gtids.html#sysvar_gtid_executed) and [`gtid_purged`](replication-options-gtids.html#sysvar_gtid_purged) as described in [The `gtid_purged` System Variable](replication-gtids-lifecycle.html#replication-gtids-gtid-purged "The gtid_purged System Variable") is changed to iterate the binary log files as follows:

  + Instead of using the value of `Previous_gtids_log_event` and GTID log events from the newest binary log file, the computation for [`gtid_executed`](replication-options-gtids.html#sysvar_gtid_executed) iterates from the newest binary log file, and uses the value of `Previous_gtids_log_event` and any GTID log events from the first binary log file where it finds a `Previous_gtids_log_event` value. If the server's most recent binary log files do not have GTID log events, for example if [`gtid_mode=ON`](replication-options-gtids.html#sysvar_gtid_mode) was used but the server was later changed to [`gtid_mode=OFF`](replication-options-gtids.html#sysvar_gtid_mode), this process can take a long time.

  + Instead of using the value of `Previous_gtids_log_event` from the oldest binary log file, the computation for [`gtid_purged`](replication-options-gtids.html#sysvar_gtid_purged) iterates from the oldest binary log file, and uses the value of `Previous_gtids_log_event` from the first binary log file where it finds either a nonempty `Previous_gtids_log_event` value, or at least one GTID log event (indicating that the use of GTIDs starts at that point). If the server's older binary log files do not have GTID log events, for example if [`gtid_mode=ON`](replication-options-gtids.html#sysvar_gtid_mode) was only set recently on the server, this process can take a long time.

  In MySQL version 5.7.5, this variable was added as `simplified_binlog_gtid_recovery` and in MySQL version 5.7.6 it was renamed to `binlog_gtid_simple_recovery`.

* [`enforce_gtid_consistency`](replication-options-gtids.html#sysvar_enforce_gtid_consistency)

  <table frame="box" rules="all" summary="Properties for enforce_gtid_consistency"><col style="width: 30%"/><col style="width: 70%"/><tbody><tr><th>Command-Line Format</th> <td><code class="literal">--enforce-gtid-consistency[=value]</code></td> </tr><tr><th>System Variable</th> <td><code class="literal"><a class="link" href="replication-options-gtids.html#sysvar_enforce_gtid_consistency">enforce_gtid_consistency</a></code></td> </tr><tr><th>Scope</th> <td>Global</td> </tr><tr><th>Dynamic</th> <td>Yes</td> </tr><tr><th>Type</th> <td>Enumeration</td> </tr><tr><th>Default Value</th> <td><code class="literal">OFF</code></td> </tr><tr><th>Valid Values</th> <td><p class="valid-value"><code class="literal">OFF</code></p><p class="valid-value"><code class="literal">ON</code></p><p class="valid-value"><code class="literal">WARN</code></p></td> </tr></tbody></table>

  Depending on the value of this variable, the server enforces GTID consistency by allowing execution of only statements that can be safely logged using a GTID. You *must* set this variable to `ON` before enabling GTID based replication.

  The values that [`enforce_gtid_consistency`](replication-options-gtids.html#sysvar_enforce_gtid_consistency) can be configured to are:

  + `OFF`: all transactions are allowed to violate GTID consistency.

  + `ON`: no transaction is allowed to violate GTID consistency.

  + `WARN`: all transactions are allowed to violate GTID consistency, but a warning is generated in this case. `WARN` was added in MySQL 5.7.6.

  Only statements that can be logged using GTID safe statements can be logged when [`enforce_gtid_consistency`](replication-options-gtids.html#sysvar_enforce_gtid_consistency) is set to `ON`, so the operations listed here cannot be used with this option:

  + [`CREATE TABLE ... SELECT`](create-table-select.html "13.1.18.4 CREATE TABLE ... SELECT Statement") statements

  + [`CREATE TEMPORARY TABLE`](create-table.html "13.1.18 CREATE TABLE Statement") or [`DROP TEMPORARY TABLE`](drop-table.html "13.1.29 DROP TABLE Statement") statements inside transactions

  + Transactions or statements that update both transactional and nontransactional tables. There is an exception that nontransactional DML is allowed in the same transaction or in the same statement as transactional DML, if all *nontransactional* tables are temporary.

  [`--enforce-gtid-consistency`](replication-options-gtids.html#sysvar_enforce_gtid_consistency) only takes effect if binary logging takes place for a statement. If binary logging is disabled on the server, or if statements are not written to the binary log because they are removed by a filter, GTID consistency is not checked or enforced for the statements that are not logged.

  For more information, see [Section 16.1.3.6, “Restrictions on Replication with GTIDs”](replication-gtids-restrictions.html "16.1.3.6 Restrictions on Replication with GTIDs").

  Prior to MySQL 5.7.6, the boolean [`enforce_gtid_consistency`](replication-options-gtids.html#sysvar_enforce_gtid_consistency) defaulted to `OFF`. To maintain compatibility with previous releases, in MySQL 5.7.6 the enumeration defaults to `OFF`, and setting [`--enforce-gtid-consistency`](replication-options-gtids.html#sysvar_enforce_gtid_consistency) without a value is interpreted as setting the value to `ON`. The variable also has multiple textual aliases for the values: `0=OFF=FALSE`, `1=ON=TRUE`,`2=WARN`. This differs from other enumeration types but maintains compatibility with the boolean type used in previous versions. These changes impact on what is returned by the variable. Using `SELECT @@ENFORCE_GTID_CONSISTENCY`, `SHOW VARIABLES LIKE 'ENFORCE_GTID_CONSISTENCY'`, and `SELECT * FROM INFORMATION_SCHEMA.VARIABLES WHERE 'VARIABLE_NAME' = 'ENFORCE_GTID_CONSISTENCY'`, all return the textual form, not the numeric form. This is an incompatible change, since `@@ENFORCE_GTID_CONSISTENCY` returns the numeric form for booleans but returns the textual form for `SHOW` and the Information Schema.

* [`gtid_executed`](replication-options-gtids.html#sysvar_gtid_executed)

  <table frame="box" rules="all" summary="Properties for gtid_executed"><col style="width: 30%"/><col style="width: 70%"/><tbody><tr><th>System Variable</th> <td><code class="literal"><a class="link" href="replication-options-gtids.html#sysvar_gtid_executed">gtid_executed</a></code></td> </tr><tr><th>Scope</th> <td>Global</td> </tr><tr><th>Dynamic</th> <td>No</td> </tr><tr><th>Type</th> <td>String</td> </tr><tr><th>Unit</th> <td>set of GTIDs</td> </tr></tbody></table>

  When used with global scope, this variable contains a representation of the set of all transactions executed on the server and GTIDs that have been set by a [`SET`](set-variable.html "13.7.4.1 SET Syntax for Variable Assignment") [`gtid_purged`](replication-options-gtids.html#sysvar_gtid_purged) statement. This is the same as the value of the `Executed_Gtid_Set` column in the output of [`SHOW MASTER STATUS`](show-master-status.html "13.7.5.23 SHOW MASTER STATUS Statement") and [`SHOW SLAVE STATUS`](show-slave-status.html "13.7.5.34 SHOW SLAVE STATUS Statement"). The value of this variable is a GTID set, see [GTID Sets](replication-gtids-concepts.html#replication-gtids-concepts-gtid-sets "GTID Sets") for more information.

  When the server starts, `@@GLOBAL.gtid_executed` is initialized. See [`binlog_gtid_simple_recovery`](replication-options-gtids.html#sysvar_binlog_gtid_simple_recovery) for more information on how binary logs are iterated to populate [`gtid_executed`](replication-options-gtids.html#sysvar_gtid_executed). GTIDs are then added to the set as transactions are executed, or if any [`SET`](set-variable.html "13.7.4.1 SET Syntax for Variable Assignment") [`gtid_purged`](replication-options-gtids.html#sysvar_gtid_purged) statement is executed.

  The set of transactions that can be found in the binary logs at any given time is equal to [`GTID_SUBTRACT(@@GLOBAL.gtid_executed, @@GLOBAL.gtid_purged)`](gtid-functions.html#function_gtid-subtract); that is, to all transactions in the binary log that have not yet been purged.

  Issuing [`RESET MASTER`](reset-master.html "13.4.1.2 RESET MASTER Statement") causes the global value (but not the session value) of this variable to be reset to an empty string. GTIDs are not otherwise removed from this set other than when the set is cleared due to `RESET MASTER`.

  Prior to MySQL 5.7.7, this variable could also be used with session scope, where it contained a representation of the set of transactions that are written to the cache in the current session. The session scope was deprecated in MySQL 5.7.7.

* [`gtid_executed_compression_period`](replication-options-gtids.html#sysvar_gtid_executed_compression_period)

  <table frame="box" rules="all" summary="Properties for gtid_executed_compression_period"><col style="width: 30%"/><col style="width: 70%"/><tbody><tr><th>Command-Line Format</th> <td><code class="literal">--gtid-executed-compression-period=#</code></td> </tr><tr><th>System Variable</th> <td><code class="literal"><a class="link" href="replication-options-gtids.html#sysvar_gtid_executed_compression_period">gtid_executed_compression_period</a></code></td> </tr><tr><th>Scope</th> <td>Global</td> </tr><tr><th>Dynamic</th> <td>Yes</td> </tr><tr><th>Type</th> <td>Integer</td> </tr><tr><th>Default Value</th> <td><code class="literal">1000</code></td> </tr><tr><th>Minimum Value</th> <td><code class="literal">0</code></td> </tr><tr><th>Maximum Value</th> <td><code class="literal">4294967295</code></td> </tr></tbody></table>

  Compress the `mysql.gtid_executed` table each time this many transactions have been processed. When binary logging is enabled on the server, this compression method is not used, and instead the `mysql.gtid_executed` table is compressed on each binary log rotation. When binary logging is disabled on the server, the compression thread sleeps until the specified number of transactions have been executed, then wakes up to perform compression of the `mysql.gtid_executed` table. Setting the value of this system variable to 0 means that the thread never wakes up, so this explicit compression method is not used. Instead, compression occurs implicitly as required.

  See [mysql.gtid\_executed Table Compression](replication-gtids-concepts.html#replication-gtids-gtid-executed-table-compression "mysql.gtid_executed Table Compression") for more information.

  This variable was added in MySQL version 5.7.5 as `executed_gtids_compression_period` and renamed in MySQL version 5.7.6 to `gtid_executed_compression_period`.

* [`gtid_mode`](replication-options-gtids.html#sysvar_gtid_mode)

  <table frame="box" rules="all" summary="Properties for gtid_mode"><col style="width: 30%"/><col style="width: 70%"/><tbody><tr><th>Command-Line Format</th> <td><code class="literal">--gtid-mode=MODE</code></td> </tr><tr><th>System Variable</th> <td><code class="literal"><a class="link" href="replication-options-gtids.html#sysvar_gtid_mode">gtid_mode</a></code></td> </tr><tr><th>Scope</th> <td>Global</td> </tr><tr><th>Dynamic</th> <td>Yes</td> </tr><tr><th>Type</th> <td>Enumeration</td> </tr><tr><th>Default Value</th> <td><code class="literal">OFF</code></td> </tr><tr><th>Valid Values</th> <td><p class="valid-value"><code class="literal">OFF</code></p><p class="valid-value"><code class="literal">OFF_PERMISSIVE</code></p><p class="valid-value"><code class="literal">ON_PERMISSIVE</code></p><p class="valid-value"><code class="literal">ON</code></p></td> </tr></tbody></table>

  Controls whether GTID based logging is enabled and what type of transactions the logs can contain. Prior to MySQL 5.7.6, this variable was read-only and was set using [`--gtid-mode`](replication-options-gtids.html#sysvar_gtid_mode) at server startup only. Prior to MySQL 5.7.5, starting the server with [`--gtid-mode=ON`](replication-options-gtids.html#sysvar_gtid_mode) required that the server also be started with the [`--log-bin`](replication-options-binary-log.html#option_mysqld_log-bin) and [`--log-slave-updates`](replication-options-binary-log.html#sysvar_log_slave_updates) options. As of MySQL 5.7.5, this is no longer a requirement. See [mysql.gtid\_executed Table](replication-gtids-concepts.html#replication-gtids-gtid-executed-table "mysql.gtid_executed Table").

  MySQL 5.7.6 enables this variable to be set dynamically. You must have privileges sufficient to set global system variables. See [Section 5.1.8.1, “System Variable Privileges”](system-variable-privileges.html "5.1.8.1 System Variable Privileges"). [`enforce_gtid_consistency`](replication-options-gtids.html#sysvar_enforce_gtid_consistency) must be set to `ON` before you can set [`gtid_mode=ON`](replication-options-gtids.html#sysvar_gtid_mode). Before modifying this variable, see [Section 16.1.4, “Changing Replication Modes on Online Servers”](replication-mode-change-online.html "16.1.4 Changing Replication Modes on Online Servers").

  Transactions logged in MySQL 5.7.6 and higher can be either anonymous or use GTIDs. Anonymous transactions rely on binary log file and position to identify specific transactions. GTID transactions have a unique identifier that is used to refer to transactions. The `OFF_PERMISSIVE` and `ON_PERMISSIVE` modes added in MySQL 5.7.6 permit a mix of these transaction types in the topology. The different modes are now:

  + `OFF`: Both new and replicated transactions must be anonymous.

  + `OFF_PERMISSIVE`: New transactions are anonymous. Replicated transactions can be either anonymous or GTID transactions.

  + `ON_PERMISSIVE`: New transactions are GTID transactions. Replicated transactions can be either anonymous or GTID transactions.

  + `ON`: Both new and replicated transactions must be GTID transactions.

  Changes from one value to another can only be one step at a time. For example, if [`gtid_mode`](replication-options-gtids.html#sysvar_gtid_mode) is currently set to `OFF_PERMISSIVE`, it is possible to change to `OFF` or `ON_PERMISSIVE` but not to `ON`.

  In MySQL 5.7.6 and higher, the values of [`gtid_purged`](replication-options-gtids.html#sysvar_gtid_purged) and [`gtid_executed`](replication-options-gtids.html#sysvar_gtid_executed) are persistent regardless of the value of [`gtid_mode`](replication-options-gtids.html#sysvar_gtid_mode). Therefore even after changing the value of [`gtid_mode`](replication-options-gtids.html#sysvar_gtid_mode), these variables contain the correct values. In MySQL 5.7.5 and earlier, the values of [`gtid_purged`](replication-options-gtids.html#sysvar_gtid_purged) and [`gtid_executed`](replication-options-gtids.html#sysvar_gtid_executed) are not persistent while [`gtid_mode=OFF`](replication-options-gtids.html#sysvar_gtid_mode). Therefore, after changing [`gtid_mode`](replication-options-gtids.html#sysvar_gtid_mode) to `OFF`, once all binary logs containing GTIDs are purged, the values of these variables are lost.

* [`gtid_next`](replication-options-gtids.html#sysvar_gtid_next)

  <table frame="box" rules="all" summary="Properties for gtid_next"><col style="width: 30%"/><col style="width: 70%"/><tbody><tr><th>System Variable</th> <td><code class="literal"><a class="link" href="replication-options-gtids.html#sysvar_gtid_next">gtid_next</a></code></td> </tr><tr><th>Scope</th> <td>Session</td> </tr><tr><th>Dynamic</th> <td>Yes</td> </tr><tr><th>Type</th> <td>Enumeration</td> </tr><tr><th>Default Value</th> <td><code class="literal">AUTOMATIC</code></td> </tr><tr><th>Valid Values</th> <td><p class="valid-value"><code class="literal">AUTOMATIC</code></p><p class="valid-value"><code class="literal">ANONYMOUS</code></p><p class="valid-value"><code class="literal">&lt;UUID&gt;:&lt;NUMBER&gt;</code></p></td> </tr></tbody></table>

  This variable is used to specify whether and how the next GTID is obtained.

  Setting the session value of this system variable is a restricted operation. The session user must have privileges sufficient to set restricted session variables. See [Section 5.1.8.1, “System Variable Privileges”](system-variable-privileges.html "5.1.8.1 System Variable Privileges").

  `gtid_next` can take any of the following values:

  + `AUTOMATIC`: Use the next automatically-generated global transaction ID.

  + `ANONYMOUS`: Transactions do not have global identifiers, and are identified by file and position only.

  + A global transaction ID in *`UUID`*:*`NUMBER`* format.

  Exactly which of the above options are valid depends on the setting of [`gtid_mode`](replication-options-gtids.html#sysvar_gtid_mode), see [Section 16.1.4.1, “Replication Mode Concepts”](replication-mode-change-online-concepts.html "16.1.4.1 Replication Mode Concepts") for more information. Setting this variable has no effect if [`gtid_mode`](replication-options-gtids.html#sysvar_gtid_mode) is `OFF`.

  After this variable has been set to *`UUID`*:*`NUMBER`*, and a transaction has been committed or rolled back, an explicit `SET GTID_NEXT` statement must again be issued before any other statement.

  In MySQL 5.7.5 and higher, `DROP TABLE` or `DROP TEMPORARY TABLE` fails with an explicit error when used on a combination of nontemporary tables with temporary tables, or of temporary tables using transactional storage engines with temporary tables using nontransactional storage engines. Prior to MySQL 5.7.5, when GTIDs were enabled but `gtid_next` was not `AUTOMATIC`, [`DROP TABLE`](drop-table.html "13.1.29 DROP TABLE Statement") did not work correctly when used with either of these combinations of tables. (Bug #17620053)

  In MySQL 5.7.1, you cannot execute any of the statements [`CHANGE MASTER TO`](change-master-to.html "13.4.2.1 CHANGE MASTER TO Statement"), [`START SLAVE`](start-slave.html "13.4.2.5 START SLAVE Statement"), [`STOP SLAVE`](stop-slave.html "13.4.2.6 STOP SLAVE Statement"), [`REPAIR TABLE`](repair-table.html "13.7.2.5 REPAIR TABLE Statement"), [`OPTIMIZE TABLE`](optimize-table.html "13.7.2.4 OPTIMIZE TABLE Statement"), [`ANALYZE TABLE`](analyze-table.html "13.7.2.1 ANALYZE TABLE Statement"), [`CHECK TABLE`](check-table.html "13.7.2.2 CHECK TABLE Statement"), [`CREATE SERVER`](create-server.html "13.1.17 CREATE SERVER Statement"), [`ALTER SERVER`](alter-server.html "13.1.7 ALTER SERVER Statement"), [`DROP SERVER`](drop-server.html "13.1.28 DROP SERVER Statement"), [`CACHE INDEX`](cache-index.html "13.7.6.2 CACHE INDEX Statement"), [`LOAD INDEX INTO CACHE`](load-index.html "13.7.6.5 LOAD INDEX INTO CACHE Statement"), [`FLUSH`](flush.html "13.7.6.3 FLUSH Statement"), or [`RESET`](reset.html "13.7.6.6 RESET Statement") when [`gtid_next`](replication-options-gtids.html#sysvar_gtid_next) is set to any value other than `AUTOMATIC`; in such cases, the statement fails with an error. Such statements are *not* disallowed in MySQL 5.7.2 and later. (Bug #16062608, Bug #16715809, Bug #69045) (Bug #16062608)

* [`gtid_owned`](replication-options-gtids.html#sysvar_gtid_owned)

  <table frame="box" rules="all" summary="Properties for gtid_owned"><col style="width: 30%"/><col style="width: 70%"/><tbody><tr><th>System Variable</th> <td><code class="literal"><a class="link" href="replication-options-gtids.html#sysvar_gtid_owned">gtid_owned</a></code></td> </tr><tr><th>Scope</th> <td>Global, Session</td> </tr><tr><th>Dynamic</th> <td>No</td> </tr><tr><th>Type</th> <td>String</td> </tr><tr><th>Unit</th> <td>set of GTIDs</td> </tr></tbody></table>

  This read-only variable is primarily for internal use. Its contents depend on its scope.

  + When used with global scope, [`gtid_owned`](replication-options-gtids.html#sysvar_gtid_owned) holds a list of all the GTIDs that are currently in use on the server, with the IDs of the threads that own them. This variable is mainly useful for a multi-threaded replica to check whether a transaction is already being applied on another thread. An applier thread takes ownership of a transaction's GTID all the time it is processing the transaction, so `@@global.gtid_owned` shows the GTID and owner for the duration of processing. When a transaction has been committed (or rolled back), the applier thread releases ownership of the GTID.

  + When used with session scope, [`gtid_owned`](replication-options-gtids.html#sysvar_gtid_owned) holds a single GTID that is currently in use by and owned by this session. This variable is mainly useful for testing and debugging the use of GTIDs when the client has explicitly assigned a GTID for the transaction by setting [`gtid_next`](replication-options-gtids.html#sysvar_gtid_next). In this case, `@@session.gtid_owned` displays the GTID all the time the client is processing the transaction, until the transaction has been committed (or rolled back). When the client has finished processing the transaction, the variable is cleared. If [`gtid_next=AUTOMATIC`](replication-options-gtids.html#sysvar_gtid_next) is used for the session, [`gtid_owned`](replication-options-gtids.html#sysvar_gtid_owned) is only populated briefly during the execution of the commit statement for the transaction, so it cannot be observed from the session concerned, although it is listed if `@@global.gtid_owned` is read at the right point. If you have a requirement to track the GTIDs that are handled by a client in a session, you can enable the session state tracker controlled by the [`session_track_gtids`](server-system-variables.html#sysvar_session_track_gtids) system variable.

* [`gtid_purged`](replication-options-gtids.html#sysvar_gtid_purged)

  <table frame="box" rules="all" summary="Properties for gtid_purged"><col style="width: 30%"/><col style="width: 70%"/><tbody><tr><th>System Variable</th> <td><code class="literal"><a class="link" href="replication-options-gtids.html#sysvar_gtid_purged">gtid_purged</a></code></td> </tr><tr><th>Scope</th> <td>Global</td> </tr><tr><th>Dynamic</th> <td>Yes</td> </tr><tr><th>Type</th> <td>String</td> </tr><tr><th>Unit</th> <td>set of GTIDs</td> </tr></tbody></table>

  The global value of the [`gtid_purged`](replication-options-gtids.html#sysvar_gtid_purged) system variable (`@@GLOBAL.gtid_purged`) is a GTID set consisting of the GTIDs of all the transactions that have been committed on the server, but do not exist in any binary log file on the server. [`gtid_purged`](replication-options-gtids.html#sysvar_gtid_purged) is a subset of [`gtid_executed`](replication-options-gtids.html#sysvar_gtid_executed). The following categories of GTIDs are in [`gtid_purged`](replication-options-gtids.html#sysvar_gtid_purged):

  + GTIDs of replicated transactions that were committed with binary logging disabled on the replica.

  + GTIDs of transactions that were written to a binary log file that has now been purged.

  + GTIDs that were added explicitly to the set by the statement `SET @@GLOBAL.gtid_purged`.

  When the server starts or restarts, the global value of [`gtid_purged`](replication-options-gtids.html#sysvar_gtid_purged) is initialized to a set of GTIDs. For information on how this GTID set is computed, see [The `gtid_purged` System Variable](replication-gtids-lifecycle.html#replication-gtids-gtid-purged "The gtid_purged System Variable"). If binary logs from MySQL 5.7.7 or older are present on the server, you might need to set [`binlog_gtid_simple_recovery=FALSE`](replication-options-gtids.html#sysvar_binlog_gtid_simple_recovery) in the server's configuration file to produce the correct computation. See the description for [`binlog_gtid_simple_recovery`](replication-options-gtids.html#sysvar_binlog_gtid_simple_recovery) for details of the situations in which this setting is needed.

  Issuing [`RESET MASTER`](reset-master.html "13.4.1.2 RESET MASTER Statement") causes the value of [`gtid_purged`](replication-options-gtids.html#sysvar_gtid_purged) to be reset to an empty string.

  You can set the value of [`gtid_purged`](replication-options-gtids.html#sysvar_gtid_purged) in order to record on the server that the transactions in a certain GTID set have been applied, although they do not exist in any binary log on the server. An example use case for this action is when you are restoring a backup of one or more databases on a server, but you do not have the relevant binary logs containing the transactions on the server.

  Important

  GTIDs are only available on a server instance up to the number of non-negative values for a signed 64-bit integer (2 to the power of 63, minus 1). If you set the value of [`gtid_purged`](replication-options-gtids.html#sysvar_gtid_purged) to a number that approaches this limit, subsequent commits can cause the server to run out of GTIDs and take the action specified by [`binlog_error_action`](replication-options-binary-log.html#sysvar_binlog_error_action).

  In MySQL 5.7, it is possible to update the value of [`gtid_purged`](replication-options-gtids.html#sysvar_gtid_purged) only when [`gtid_executed`](replication-options-gtids.html#sysvar_gtid_executed) is the empty string, and therefore [`gtid_purged`](replication-options-gtids.html#sysvar_gtid_purged) is the empty string. This is the case either when replication has not been started previously, or when replication did not previously use GTIDs. Prior to MySQL 5.7.6, [`gtid_purged`](replication-options-gtids.html#sysvar_gtid_purged) was also settable only when [`gtid_mode=ON`](replication-options-gtids.html#sysvar_gtid_mode). In MySQL 5.7.6 and higher, [`gtid_purged`](replication-options-gtids.html#sysvar_gtid_purged) is settable regardless of the value of [`gtid_mode`](replication-options-gtids.html#sysvar_gtid_mode).

  To replace the value of [`gtid_purged`](replication-options-gtids.html#sysvar_gtid_purged) with your specified GTID set, use the following statement:

  ```sql
  SET @@GLOBAL.gtid_purged = 'gtid_set'
  ```

  Note

  If you are using MySQL 5.7.7 or earlier, after issuing a `SET @@GLOBAL.gtid_purged` statement, you might need to set [`binlog_gtid_simple_recovery=FALSE`](replication-options-gtids.html#sysvar_binlog_gtid_simple_recovery) in the server's configuration file before restarting the server, otherwise [`gtid_purged`](replication-options-gtids.html#sysvar_gtid_purged) can be computed incorrectly. See the description for [`binlog_gtid_simple_recovery`](replication-options-gtids.html#sysvar_binlog_gtid_simple_recovery) for details of the situations in which this setting is needed. If all binary logs on the server were generated using MySQL 5.7.8 or later and you are using MySQL 5.7.8 or later, [`binlog_gtid_simple_recovery=TRUE`](replication-options-gtids.html#sysvar_binlog_gtid_simple_recovery) (which is the default setting from MySQL 5.7.7) can always safely be used.
