### 7.5.2 Recuperação Pontual (Point-in-Time Recovery) Usando Posições de Eventos

A seção anterior, Seção 7.5.1, “Recuperação Pontual Usando Binary Log”, explica a ideia geral de usar o Binary Log para realizar uma *point-in-time-recovery*. A seção detalha a operação com um exemplo.

Por exemplo, suponha que por volta das 13:00:00 de 27 de maio de 2020, uma SQL statement tenha sido executada, deletando uma tabela. Você pode realizar uma Recuperação Pontual para restaurar o server até o estado imediatamente anterior à deleção da tabela. A seguir estão alguns passos de exemplo para realizar isso:

1. Restaure o último full backup criado antes do ponto no tempo de interesse (chame-o de `tp`, que é 13:00:00 de 27 de maio de 2020 em nosso exemplo). Ao terminar, anote a posição do Binary Log até a qual você restaurou o server para uso posterior e reinicie o server.

   Note

   Embora a última posição do Binary Log recuperada também seja exibida pelo InnoDB após a restauração e reinicialização do server, esse *não* é um meio confiável para obter a ending log position de sua restauração, pois pode haver eventos DDL e alterações não-InnoDB que ocorreram após o horário refletido pela posição exibida. Sua ferramenta de backup e restauração deve fornecer a última posição do Binary Log para sua recovery: por exemplo, se você estiver usando o **mysqlbinlog** para a tarefa, verifique a stop position do Binary Log replay; se você estiver usando o MySQL Enterprise Backup, a última posição do Binary Log foi salva em seu backup. Consulte Recuperação Pontual (Point-in-Time Recovery).

2. Encontre a posição precisa do evento do Binary Log correspondente ao ponto no tempo até o qual você deseja restaurar seu Database. Em nosso exemplo, dado que sabemos o horário aproximado em que a deleção da tabela ocorreu (`tp`), podemos encontrar a log position verificando o conteúdo do log por volta desse horário usando o utilitário **mysqlbinlog**. Use as opções `--start-datetime` e `--stop-datetime` para especificar um curto período de tempo em torno de `tp` e, em seguida, procure o evento na saída. Por exemplo:

   ```sql
   $> mysqlbinlog   --start-datetime="2020-05-27 12:59:00" --stop-datetime="2020-05-27 13:06:00" \
     --verbose /var/lib/mysql/bin.123456 | grep -C 12 "DROP TABLE"
   # at 1868
   #200527 13:00:30 server id 2  end_log_pos 1985 CRC32 0x8b894489 	Query	thread_id=8	exec_time=0	error_code=0
   use `pets`/*!*/;
   SET TIMESTAMP=1590598830/*!*/;
   SET @@session.pseudo_thread_id=8/*!*/;
   SET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0, @@session.unique_checks=1, @@session.autocommit=1/*!*/;
   SET @@session.sql_mode=1436549152/*!80005 &~0x1003ff00*//*!*/;
   SET @@session.auto_increment_increment=1, @@session.auto_increment_offset=1/*!*/;
   /*!\C latin1 *//*!*/;
   SET @@session.character_set_client=8,@@session.collation_connection=8,@@session.collation_server=8/*!*/;
   SET @@session.lc_time_names=0/*!*/;
   SET @@session.collation_database=DEFAULT/*!*/;
   DROP TABLE `cats` /* generated by server */
   /*!*/;
   # at 1985
   #200527 13:05:06 server id 2  end_log_pos 2050 CRC32 0x2f8d0249 	Anonymous_GTID	last_committed=6	sequence_number=7	rbr_only=yes	original_committed_timestamp=0	immediate_commit_timestamp=0	transaction_length=0
   /*!50718 SET TRANSACTION ISOLATION LEVEL READ COMMITTED*//*!*/;
   # original_commit_timestamp=0 (1969-12-31 19:00:00.000000 EST)
   # immediate_commit_timestamp=0 (1969-12-31 19:00:00.000000 EST)
   /*!80001 SET @@session.original_commit_timestamp=0*//*!*/;
   /*!80014 SET @@session.original_server_version=0*//*!*/;
   /*!80014 SET @@session.immediate_server_version=0*//*!*/;
   SET @@SESSION.GTID_NEXT= 'ANONYMOUS'/*!*/;
   # at 2050
   #200527 13:05:06 server id 2  end_log_pos 2122 CRC32 0x56280bb1 	Query	thread_id=8	exec_time=0	error_code=0
   ```

   A partir da saída do **mysqlbinlog**, a statement `` DROP TABLE `pets`.`cats` `` pode ser encontrada no segmento do Binary Log entre a linha `# at 1868` e `# at 1985`, o que significa que a statement ocorre *após* a log position 1868, e o log está na position 1985 após a `DROP TABLE` statement.

   Note

   Use as opções `--start-datetime` e `--stop-datetime` apenas para ajudar a encontrar as event positions de interesse. Não é recomendado usar as duas opções para especificar o range do segmento do Binary Log a ser aplicado: há um risco maior de perder eventos do Binary Log ao usar essas opções. Use `--start-position` e `--stop-position` em vez disso.

3. Aplique os eventos no arquivo Binary Log ao server, começando com a log position que você encontrou no passo 1 (assumindo que seja 1006) e terminando na position que você encontrou no passo 2 que está *antes* do seu ponto no tempo de interesse (que é 1868):

   ```sql
   $> mysqlbinlog --start-position=1006 --stop-position=1868 /var/lib/mysql/bin.123456 \
            | mysql -u root -p
   ```

   O comando recupera todas as transactions desde a starting position até imediatamente antes da stop position. Como a saída do **mysqlbinlog** inclui `SET TIMESTAMP` statements antes de cada SQL statement registrada, os dados recuperados e os logs MySQL relacionados refletem os horários originais em que as transactions foram executadas.

   Seu Database foi agora restaurado ao ponto no tempo de interesse, `tp`, imediatamente antes da tabela `pets.cats` ser dropada.

4. Além da Recuperação Pontual que foi concluída, se você também quiser reexecutar todas as statements *após* seu ponto no tempo de interesse, use o **mysqlbinlog** novamente para aplicar todos os eventos após `tp` ao server. Observamos no passo 2 que, após a statement que queríamos pular, o log está na position 1985; podemos usá-la para a opção `--start-position`, de modo que quaisquer statements após essa posição sejam incluídas:

   ```sql
   $> mysqlbinlog --start-position=1985 /var/lib/mysql/bin.123456 \
            | mysql -u root -p
   ```

   Seu Database foi restaurado até a statement mais recente registrada no arquivo Binary Log, mas com o evento selecionado ignorado.
