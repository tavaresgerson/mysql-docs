### 8.11.3 Insertions Concorrentes

O storage engine `MyISAM` suporta insertions concorrentes para reduzir a contenção (contention) entre leitores e escritores para uma determinada tabela: Se uma tabela `MyISAM` não tiver buracos no arquivo de dados (linhas excluídas no meio), uma instrução `INSERT` pode ser executada para adicionar linhas ao final da tabela ao mesmo tempo que as instruções `SELECT` estão lendo linhas da tabela. Se houver múltiplas instruções `INSERT`, elas são enfileiradas e executadas em sequência, concorrentemente com as instruções `SELECT`. Os resultados de um `INSERT` concorrente podem não estar visíveis imediatamente.

A variável de sistema `concurrent_insert` pode ser configurada para modificar o processamento de insertion concorrente. Por padrão, a variável é definida como `AUTO` (ou 1) e as insertions concorrentes são tratadas conforme descrito. Se `concurrent_insert` for definida como `NEVER` (ou 0), as insertions concorrentes são desabilitadas. Se a variável for definida como `ALWAYS` (ou 2), as insertions concorrentes no final da tabela são permitidas mesmo para tabelas que possuem linhas excluídas. Veja também a descrição da variável de sistema `concurrent_insert`.

Se você estiver usando o binary log, as insertions concorrentes são convertidas em insertions normais para instruções `CREATE ... SELECT` ou `INSERT ... SELECT`. Isso é feito para garantir que você possa recriar uma cópia exata de suas tabelas aplicando o log durante uma operação de backup. Veja a Seção 5.4.4, “The Binary Log”. Além disso, para essas instruções, um read lock é colocado na tabela de onde os dados estão sendo selecionados, de modo que os inserts nessa tabela sejam bloqueados. O efeito é que as insertions concorrentes para essa tabela também devem aguardar.

Com `LOAD DATA`, se você especificar `CONCURRENT` com uma tabela `MyISAM` que satisfaça a condição para insertions concorrentes (ou seja, ela não contém blocos livres no meio), outras sessions podem recuperar dados da tabela enquanto `LOAD DATA` está sendo executado. O uso da opção `CONCURRENT` afeta um pouco a performance de `LOAD DATA`, mesmo que nenhuma outra session esteja usando a tabela ao mesmo tempo.

Se você especificar `HIGH_PRIORITY`, isso anula o efeito da opção `--low-priority-updates`, caso o server tenha sido iniciado com essa opção. Isso também faz com que as insertions concorrentes não sejam usadas.

Para `LOCK TABLE`, a diferença entre `READ LOCAL` e `READ` é que `READ LOCAL` permite que instruções `INSERT` não conflitantes (insertions concorrentes) sejam executadas enquanto o lock é mantido. No entanto, isso não pode ser usado se você for manipular o Database usando processos externos ao server enquanto o lock estiver ativo.