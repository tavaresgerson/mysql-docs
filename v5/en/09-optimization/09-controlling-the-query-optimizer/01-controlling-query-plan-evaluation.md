### 8.9.1 Controlando a Avaliação do Query Plan

A tarefa do otimizador de Query (query optimizer) é encontrar um Plan ótimo para a execução de uma Query SQL. Como a diferença de performance entre Plans "bons" e "ruins" pode ser de ordens de magnitude (ou seja, segundos versus horas ou até dias), a maioria dos otimizadores de Query, incluindo o do MySQL, realiza uma busca mais ou menos exaustiva por um Plan ótimo entre todos os Plans de avaliação de Query possíveis. Para Queries de JOIN, o número de Plans possíveis investigados pelo otimizador do MySQL cresce exponencialmente com o número de tabelas referenciadas na Query. Para um pequeno número de tabelas (geralmente menos de 7 a 10), isso não é um problema. No entanto, quando Queries maiores são submetidas, o tempo gasto na otimização da Query pode facilmente se tornar o principal gargalo (bottleneck) na performance do servidor.

Um método mais flexível para otimização de Query permite ao usuário controlar o quão exaustivo é o otimizador em sua busca por um Plan de avaliação de Query ótimo. A ideia geral é que, quanto menos Plans o otimizador investigar, menos tempo ele gastará na compilação de uma Query. Por outro lado, como o otimizador ignora alguns Plans, ele pode deixar de encontrar um Plan ótimo.

O comportamento do otimizador em relação ao número de Plans que ele avalia pode ser controlado usando duas variáveis de sistema:

*   A variável `optimizer_prune_level` instrui o otimizador a ignorar certos Plans com base em estimativas do número de linhas acessadas para cada tabela. Nossa experiência mostra que este tipo de "chute fundamentado" (educated guess) raramente perde Plans ótimos e pode reduzir drasticamente os tempos de compilação de Query. É por isso que esta opção está ativada (`optimizer_prune_level=1`) por padrão. No entanto, se você acreditar que o otimizador perdeu um Query Plan melhor, esta opção pode ser desativada (`optimizer_prune_level=0`) com o risco de que a compilação da Query demore muito mais. Note que, mesmo com o uso desta heurística, o otimizador ainda explora um número de Plans aproximadamente exponencial.

*   A variável `optimizer_search_depth` informa o quão longe no "futuro" de cada Plan incompleto o otimizador deve procurar para avaliar se ele deve ser expandido. Valores menores de `optimizer_search_depth` podem resultar em tempos de compilação de Query ordens de magnitude menores. Por exemplo, Queries com 12, 13 ou mais tabelas podem facilmente exigir horas ou até dias para compilar se `optimizer_search_depth` estiver próximo do número de tabelas na Query. Ao mesmo tempo, se compilado com `optimizer_search_depth` igual a 3 ou 4, o otimizador pode compilar em menos de um minuto para a mesma Query. Se você não tiver certeza de qual é um valor razoável para `optimizer_search_depth`, esta variável pode ser definida como 0 para instruir o otimizador a determinar o valor automaticamente.