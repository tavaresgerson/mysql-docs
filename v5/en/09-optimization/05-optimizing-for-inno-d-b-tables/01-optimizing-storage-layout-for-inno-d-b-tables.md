### 8.5.1 Otimizando o Layout de Armazenamento para Tabelas InnoDB

*   Depois que seus dados atingirem um tamanho estável, ou uma tabela em crescimento aumentar em dezenas ou algumas centenas de megabytes, considere usar o comando `OPTIMIZE TABLE` para reorganizar a tabela e compactar qualquer espaço desperdiçado. As tabelas reorganizadas exigem menos disk I/O para realizar scans de tabela completos. Esta é uma técnica direta que pode melhorar o performance quando outras técnicas, como aprimorar o uso de Index ou ajustar o código da aplicação, não são práticas.

    O `OPTIMIZE TABLE` copia a parte de dados da tabela e reconstrói os Indexes. Os benefícios vêm do empacotamento melhorado dos dados dentro dos Indexes e da fragmentação reduzida dentro dos tablespaces e no disco. Os benefícios variam dependendo dos dados em cada tabela. Você pode descobrir que há ganhos significativos para algumas e não para outras, ou que os ganhos diminuem com o tempo até que você otimize a tabela novamente. Esta operação pode ser lenta se a tabela for grande ou se os Indexes sendo reconstruídos não couberem no Buffer Pool. A primeira execução após adicionar muitos dados a uma tabela é geralmente muito mais lenta do que as execuções posteriores.

*   No `InnoDB`, ter uma `PRIMARY KEY` longa (seja uma única coluna com um valor extenso, ou várias colunas que formam um valor composto longo) desperdiça muito espaço em disco. O valor da Primary Key para uma linha é duplicado em todos os registros do Secondary Index que apontam para a mesma linha. (Consulte a Seção 14.6.2.1, “Indexes Clusterizados e Secundários”.) Crie uma coluna `AUTO_INCREMENT` como Primary Key se sua Primary Key for longa, ou crie um Index em um prefixo de uma coluna `VARCHAR` longa em vez da coluna inteira.

*   Use o tipo de dado `VARCHAR` em vez de `CHAR` para armazenar strings de comprimento variável ou para colunas com muitos valores `NULL`. Uma coluna `CHAR(N)` sempre ocupa *`N`* caracteres para armazenar dados, mesmo que a string seja mais curta ou seu valor seja `NULL`. Tabelas menores cabem melhor no Buffer Pool e reduzem o disk I/O.

    Ao usar o formato de linha `COMPACT` (o formato padrão do `InnoDB`) e conjuntos de caracteres de comprimento variável, como `utf8` ou `sjis`, as colunas `CHAR(N)` ocupam uma quantidade variável de espaço, mas ainda assim, pelo menos *`N`* bytes.

*   Para tabelas que são grandes, ou contêm muitos dados numéricos ou de texto repetitivo, considere usar o formato de linha `COMPRESSED`. Menos disk I/O é necessário para trazer os dados para o Buffer Pool ou para realizar scans de tabela completos. Antes de tomar uma decisão permanente, meça a quantidade de compressão que você pode alcançar usando o formato de linha `COMPRESSED` versus `COMPACT`.