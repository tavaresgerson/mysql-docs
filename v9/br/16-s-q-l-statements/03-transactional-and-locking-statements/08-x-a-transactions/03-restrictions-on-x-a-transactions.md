#### 15.3.8.3 Restrições para transações XA

O suporte para transações XA é limitado ao motor de armazenamento `InnoDB`.

Para "XA externo", um servidor MySQL atua como Gestor de Recursos e os programas cliente atuam como Gestores de Transação. Para "XA interno", os motores de armazenamento dentro de um servidor MySQL atuam como RM, e o próprio servidor atua como TM. O suporte interno XA é limitado pelas capacidades dos motores de armazenamento individuais. O XA interno é necessário para o tratamento de transações XA que envolvem mais de um motor de armazenamento. A implementação do XA interno requer que um motor de armazenamento suporte o compromisso em duas fases no nível do manipulador de tabela, e atualmente isso é verdadeiro apenas para `InnoDB`.

Para `XA START`, as cláusulas `JOIN` e `RESUME` são reconhecidas, mas não têm efeito.

Para `XA END`, a cláusula `SUSPEND [FOR MIGRATE]` é reconhecida, mas não tem efeito.

O requisito de que a parte *`bqual`* do valor *`xid`* seja diferente para cada transação XA dentro de uma transação global é uma limitação da implementação atual do XA do MySQL. Não faz parte da especificação XA.

Uma transação XA é escrita no log binário em duas partes. Quando o `XA PREPARE` é emitido, a primeira parte da transação até o `XA PREPARE` é escrita usando um GTID inicial. Um `XA_prepare_log_event` é usado para identificar tais transações no log binário. Quando o `XA COMMIT` ou `XA ROLLBACK` é emitido, uma segunda parte da transação, contendo apenas a declaração `XA COMMIT` ou `XA ROLLBACK`, é escrita usando um segundo GTID. Note que a parte inicial da transação, identificada pelo `XA_prepare_log_event`, não é necessariamente seguida por sua declaração `XA COMMIT` ou `XA ROLLBACK`, o que pode causar o registro interrompido do log binário de qualquer duas transações XA. As duas partes da transação XA podem até aparecer em diferentes arquivos de log binário. Isso significa que uma transação XA no estado `PREPARED` agora é persistente até que uma declaração explícita `XA COMMIT` ou `XA ROLLBACK` seja emitida, garantindo que as transações XA sejam compatíveis com a replicação.
Em uma replica, imediatamente após a transação XA ser preparada, ela é desvinculada do thread do aplicador de replicação e pode ser confirmada ou revertida por qualquer thread na replica. Isso significa que a mesma transação XA pode aparecer na tabela `events_transactions_current` com diferentes estados em diferentes threads. A tabela `events_transactions_current` exibe o status atual do evento de transação monitorado mais recente no thread e não atualiza esse status quando o thread está inativo. Portanto, a transação XA ainda pode ser exibida no estado `PREPARED` para o thread do aplicador original, após ter sido processada por outro thread. Para identificar positivamente as transações XA que ainda estão no estado `PREPARED` e precisam ser recuperadas, use a declaração `XA RECOVER` em vez das tabelas de transação do Schema de Desempenho.

As seguintes restrições existem para o uso de transações XA:

* O uso de filtros de replicação ou filtros de log binário em combinação com transações XA não é suportado. A filtragem de tabelas pode fazer com que uma transação XA fique vazia em uma replica, e transações XA vazias não são suportadas. Além disso, com o repositório de metadados de conexão da replica e o repositório de metadados do aplicador armazenados em tabelas `InnoDB` (o padrão), o estado interno da transação do mecanismo de dados é alterado após uma transação XA filtrada, podendo ficar inconsistente com o estado do contexto da transação de replicação.

  O erro `ER_XA_REPLICATION_FILTERS` é registrado sempre que uma transação XA é impactada por um filtro de replicação, independentemente de a transação ter ficado vazia como resultado. Se a transação não estiver vazia, a replica poderá continuar funcionando, mas você deve tomar medidas para descontinuar o uso de filtros de replicação com transações XA para evitar problemas potenciais. Se a transação estiver vazia, a replica para. Nesse caso, a replica pode estar em um estado indeterminado em que a consistência do processo de replicação pode ser comprometida. Em particular, o conjunto `gtid_executed` em uma replica da replica pode estar inconsistente com o da fonte. Para resolver essa situação, isole a fonte e pare toda a replicação, depois verifique a consistência do GTID em toda a topologia de replicação. Desfaça a transação XA que gerou a mensagem de erro, depois reinicie a replicação.

* As transações XA são consideradas inseguras para a replicação baseada em declarações. Se duas transações XA confirmadas em paralelo na fonte estiverem sendo preparadas na replica na ordem inversa, podem ocorrer dependências de bloqueio que não podem ser resolvidas com segurança, e é possível que a replicação falhe com um impasse na replica. Esta situação pode ocorrer para uma replica de um único ou múltiplos threads. Quando `binlog_format=STATEMENT` é definido, um aviso é emitido para declarações DML dentro das transações XA. Quando `binlog_format=MIXED` ou `binlog_format=ROW` é definido, as declarações DML dentro das transações XA são registradas usando a replicação baseada em linhas, e o problema potencial não está presente.

* Você deve estar ciente de que, quando o mesmo ID de transação X é usado para executar transações XA sequencialmente e ocorrer um travamento durante o processamento de `XA COMMIT ... UMA FASE`, pode não ser mais possível sincronizar o estado entre o log binário e o motor de armazenamento. Isso pode ocorrer se a série de eventos descrita anteriormente ocorrer após essa transação ter sido preparada no motor de armazenamento, enquanto a declaração `XA COMMIT` ainda estiver sendo executada. Este é um problema conhecido.