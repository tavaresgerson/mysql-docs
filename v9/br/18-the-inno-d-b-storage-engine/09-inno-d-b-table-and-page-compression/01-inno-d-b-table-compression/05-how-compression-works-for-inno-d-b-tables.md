#### 17.9.1.5 Como a compressão funciona para as tabelas InnoDB

Esta seção descreve alguns detalhes de implementação interna sobre a compressão para tabelas InnoDB. As informações apresentadas aqui podem ser úteis para o ajuste de desempenho, mas não são necessárias para o uso básico da compressão.

##### Algoritmos de compressão

Alguns sistemas operacionais implementam a compressão no nível do sistema de arquivos. Os arquivos são tipicamente divididos em blocos de tamanho fixo que são comprimidos em blocos de tamanho variável, o que facilmente leva à fragmentação. Toda vez que algo dentro de um bloco é modificado, todo o bloco é recomprimido antes de ser escrito no disco. Essas propriedades tornam essa técnica de compressão inadequada para uso em um sistema de banco de dados intensivo em atualizações.

O MySQL implementa a compressão com a ajuda da conhecida biblioteca zlib, que implementa o algoritmo de compressão LZ77. Esse algoritmo de compressão é maduro, robusto e eficiente tanto na utilização da CPU quanto na redução do tamanho dos dados. O algoritmo é "sem perda", de modo que os dados originais não comprimidos sempre podem ser reconstruídos a partir da forma comprimida. A compressão LZ77 funciona encontrando sequências de dados que são repetidas dentro dos dados a serem comprimidos. Os padrões de valores em seus dados determinam o quão bem ele é comprimido, mas dados típicos de usuários geralmente compactam em 50% ou mais.

Ao contrário da compressão realizada por uma aplicação ou das características de compressão de alguns outros sistemas de gerenciamento de banco de dados, a compressão do InnoDB aplica-se tanto aos dados do usuário quanto aos índices. Em muitos casos, os índices podem constituir de 40% a 50% ou mais do tamanho total do banco de dados, então essa diferença é significativa. Quando a compressão está funcionando bem para um conjunto de dados, o tamanho dos arquivos de dados do InnoDB (os arquivos `.ibd` do espaço de tabela por arquivo ou espaço de tabela geral) é de 25% a 50% do tamanho descomprimido ou possivelmente menor. Dependendo da carga de trabalho, esse banco de dados menor pode, por sua vez, levar a uma redução no I/O e a um aumento no desempenho, com um custo modesto em termos de aumento da utilização da CPU. Você pode ajustar o equilíbrio entre o nível de compressão e o overhead da CPU modificando a opção de configuração `innodb_compression_level`.

##### Armazenamento e Compressão de Dados do InnoDB

Todos os dados do usuário nas tabelas do InnoDB são armazenados em páginas que compõem um índice de árvore B (o índice agrupado). Em alguns outros sistemas de banco de dados, esse tipo de índice é chamado de "tabela organizada por índice". Cada linha no nó do índice contém os valores da chave primária (especificada pelo usuário ou gerada pelo sistema) e todas as outras colunas da tabela.

Os índices secundários nas tabelas do InnoDB também são árvores B, contendo pares de valores: a chave do índice e um ponteiro para uma linha no índice agrupado. O ponteiro é, na verdade, o valor da chave primária da tabela, que é usado para acessar o índice agrupado se forem necessárias colunas além da chave primária e da chave do índice. Os registros dos índices secundários devem caber sempre em uma única página da árvore B.

A compressão dos nós da árvore B (tanto dos índices agrupados quanto dos secundários) é tratada de maneira diferente da compressão das páginas de overflow usadas para armazenar colunas longas de `VARCHAR`, `BLOB` ou `TEXT`, conforme explicado nas seções seguintes.

##### Compressão de Páginas da Árvore B

Como elas são frequentemente atualizadas, as páginas da árvore B requerem um tratamento especial. É importante minimizar o número de vezes que os nós da árvore B são divididos, bem como minimizar a necessidade de descomprimir e recomprimir seu conteúdo.

Uma técnica que o MySQL usa é manter algumas informações do sistema na forma descomprimiu do nó da árvore B, facilitando assim certas atualizações in-place. Por exemplo, isso permite que as linhas sejam marcadas para exclusão e excluídas sem nenhuma operação de compressão.

Além disso, o MySQL tenta evitar a descomprimagem e recomprimagem desnecessárias das páginas de índice quando elas são alteradas. Dentro de cada página da árvore B, o sistema mantém um "log de modificação" descomprimiu para registrar as alterações feitas na página. Atualizações e inserções de registros pequenos podem ser escritas neste log de modificação sem a necessidade de reconstruir completamente a página.

Quando o espaço para o log de modificação esgota, o InnoDB descomprime a página, aplica as alterações e recomprime a página. Se a recomprimagem falhar (uma situação conhecida como falha de compressão), os nós da árvore B são divididos e o processo é repetido até que a atualização ou inserção seja bem-sucedida.

Para evitar falhas frequentes de compressão em cargas de trabalho intensivas em escrita, como em aplicações OLTP, o MySQL às vezes reserva um espaço vazio (tampão) na página, para que o log de modificações seja preenchido mais rapidamente e a página seja recompressa enquanto ainda há espaço suficiente para evitar a divisão. A quantidade de espaço de tampão restante em cada página varia à medida que o sistema acompanha a frequência de divisões de páginas. Em um servidor ocupado que realiza escritas frequentes em tabelas compactadas, você pode ajustar as opções de configuração `innodb_compression_failure_threshold_pct` e `innodb_compression_pad_pct_max` para ajustar esse mecanismo.

Geralmente, o MySQL exige que cada página B-tree em uma tabela InnoDB possa acomodar pelo menos dois registros. Para tabelas compactadas, esse requisito foi relaxado. As páginas de folha dos nós B-tree (seja da chave primária ou de índices secundários) precisam apenas acomodar um registro, mas esse registro deve caber, na forma descompactada, no log de modificações por página. Se `innodb_strict_mode` estiver ativado, o MySQL verifica o tamanho máximo da linha durante a `CREATE TABLE` ou `CREATE INDEX`. Se a linha não caber, o seguinte mensagem de erro é emitida: `ERROR HY000: Linha muito grande`.

Se você criar uma tabela quando o `innodb_strict_mode` estiver desativado e uma subsequente instrução `INSERT` ou `UPDATE` tentar criar uma entrada de índice que não cabe no tamanho da página compactada, a operação falhará com `ERROR 42000: Tamanho da linha muito grande`. (Esta mensagem de erro não nomeia o índice para o qual a linha é muito grande, nem menciona o comprimento do registro do índice ou o tamanho máximo do registro naquela página específica do índice.) Para resolver esse problema, reconstrua a tabela com `ALTER TABLE` e selecione um tamanho de página compactada maior (`KEY_BLOCK_SIZE`), reduza quaisquer índices de prefixo de coluna ou desabilite a compactação completamente com `ROW_FORMAT=DYNAMIC` ou `ROW_FORMAT=COMPACT`.

`innodb_strict_mode` não é aplicável a espaços de tabelas gerais, que também suportam tabelas compactadas. As regras de gerenciamento de espaços de tabelas para espaços de tabelas gerais são rigorosamente aplicadas independentemente do `innodb_strict_mode`. Para mais informações, consulte a Seção 15.1.25, “Instrução CREATE TABLESPACE”.

##### Compactação de Colunas BLOB, VARCHAR e TEXT

Em uma tabela InnoDB, as colunas `BLOB`, `VARCHAR` e `TEXT` que não fazem parte da chave primária podem ser armazenadas em páginas de overflow alocadas separadamente. Esses colunas são chamadas de colunas fora da página. Seus valores são armazenados em listas de páginas de overflow vinculadas individualmente.

Para tabelas criadas em `ROW_FORMAT=DYNAMIC` ou `ROW_FORMAT=COMPRESSED`, os valores das colunas `BLOB`, `TEXT` ou `VARCHAR` podem ser armazenados completamente fora da página, dependendo de seu comprimento e do comprimento da própria linha. Para colunas armazenadas fora da página, o registro do índice agrupado contém apenas ponteiros de 20 bytes para as páginas de sobreposição, um por coluna. Se alguma coluna for armazenada fora da página, isso depende do tamanho da página e do tamanho total da linha. Quando a linha é muito longa para caber inteiramente na página do índice agrupado, o MySQL escolhe as colunas mais longas para armazenamento fora da página até que a linha se encaixe na página do índice agrupado. Como mencionado acima, se uma linha não cabe sozinha em uma página compactada, ocorre um erro.

Nota

Para tabelas criadas em `ROW_FORMAT=DYNAMIC` ou `ROW_FORMAT=COMPRESSED`, as colunas `TEXT` e `BLOB` que têm menos de ou igual a 40 bytes são sempre armazenadas em linha.

Tabelas que usam `ROW_FORMAT=REDUNDANT` e `ROW_FORMAT=COMPACT` armazenam os primeiros 768 bytes das colunas `BLOB`, `VARCHAR` e `TEXT` no registro do índice agrupado, juntamente com a chave primária. O prefixo de 768 bytes é seguido por um ponteiro de 20 bytes para as páginas de sobreposição que contêm o restante do valor da coluna.

Quando uma tabela está no formato `COMPRESSED`, todos os dados escritos nas páginas de excedente são comprimidos "como estão"; ou seja, o MySQL aplica o algoritmo de compressão zlib ao item de dados inteiro. Além dos dados, as páginas de excedente comprimidas contêm um cabeçalho e um trailer não comprimidos que incluem um checksum da página e um link para a próxima página de excedente, entre outras coisas. Portanto, é possível obter economias significativas de armazenamento para colunas `BLOB`, `TEXT` ou `VARCHAR` mais longas se os dados forem altamente compressivos, como é frequentemente o caso com dados de texto. Dados de imagem, como `JPEG`, geralmente já estão comprimidos e, portanto, não se beneficiam muito de serem armazenados em uma tabela comprimida; a compressão dupla pode desperdiçar ciclos de CPU por pouco ou nenhum ganho de espaço.

As páginas de excedente têm o mesmo tamanho que outras páginas. Uma linha contendo dez colunas armazenadas fora da página ocupa dez páginas de excedente, mesmo que o comprimento total das colunas seja apenas 8K bytes. Em uma tabela não comprimida, dez páginas de excedente não comprimidas ocupam 160K bytes. Em uma tabela comprimida com um tamanho de página de 8K, elas ocupam apenas 80K bytes. Assim, muitas vezes é mais eficiente usar o formato de tabela comprimida para tabelas com valores de coluna longos.

Para espaços de tabelas por arquivo, usar um tamanho de página comprimida de 16K pode reduzir os custos de armazenamento e I/O para colunas `BLOB`, `VARCHAR` ou `TEXT`, porque esses dados geralmente se comprimem bem e, portanto, podem exigir menos páginas de excedente, mesmo que os próprios nós da árvore B ocupem tantas páginas quanto na forma não comprimida. Espaços de tabelas gerais não suportam um tamanho de página comprimida de 16K (`KEY_BLOCK_SIZE`). Para mais informações, consulte a Seção 17.6.3.3, “Espaços de Tabelas Gerais”.

Em uma tabela `InnoDB` compactada, cada página compactada (seja de 1K, 2K, 4K ou 8K) corresponde a uma página não compactada de 16K bytes (ou um tamanho menor se `innodb_page_size` estiver definido). Para acessar os dados de uma página, o MySQL lê a página compactada do disco se ela não estiver já no pool de buffer, e depois descompacta a página para sua forma original. Esta seção descreve como o `InnoDB` gerencia o pool de buffer em relação às páginas de tabelas compactadas.

Para minimizar o I/O e reduzir a necessidade de descompactação de uma página, às vezes o pool de buffer contém tanto a forma compactada quanto a não compactada de uma página do banco de dados. Para dar espaço para outras páginas do banco de dados necessárias, o MySQL pode expulsar de um pool de buffer uma página não compactada, enquanto deixa a página compactada na memória. Ou, se uma página não foi acessada há algum tempo, a forma compactada da página pode ser escrita no disco, para liberar espaço para outros dados. Assim, em qualquer momento, o pool de buffer pode conter tanto as formas compactada quanto não compactada da página, ou apenas a forma compactada da página, ou nenhuma das duas.

O MySQL mantém um registro de quais páginas devem ser mantidas na memória e quais devem ser removidas usando uma lista de uso menos recentemente (LRU), para que os dados quentes (acessados com frequência) tendem a permanecer na memória. Quando tabelas compactadas são acessadas, o MySQL usa um algoritmo LRU adaptativo para alcançar um equilíbrio apropriado entre páginas compactadas e não compactadas na memória. Esse algoritmo adaptativo é sensível ao fato de que o sistema esteja executando de forma limitada por I/O ou por CPU. O objetivo é evitar gastar muito tempo de processamento descompactando páginas quando a CPU está ocupada e evitar fazer excesso de I/O quando a CPU tem ciclos disponíveis que podem ser usados para descompactar páginas compactadas (que podem já estar na memória). Quando o sistema está limitado por I/O, o algoritmo prefere remover a cópia não compactada de uma página em vez de ambas as cópias, para fazer mais espaço para outras páginas do disco se tornarem residentes na memória. Quando o sistema está limitado por CPU, o MySQL prefere remover tanto a página compactada quanto a não compactada, para que mais memória possa ser usada para páginas "quentes" e reduzir a necessidade de descompactar dados na memória apenas na forma compactada.

##### Compressão e os Arquivos de Log Redo do InnoDB

Antes de uma página compactada ser escrita em um arquivo de dados, o MySQL escreve uma cópia da página no log de refazer (se ela tiver sido compactada novamente desde a última vez que foi escrita no banco de dados). Isso é feito para garantir que os logs de refazer sejam utilizáveis para recuperação em caso de falha, mesmo no caso improvável de a biblioteca `zlib` ser atualizada e que a mudança introduza um problema de compatibilidade com os dados compactados. Portanto, pode-se esperar um aumento no tamanho dos arquivos de log ou uma necessidade de verificações mais frequentes ao usar a compactação. A quantidade de aumento no tamanho do arquivo de log ou na frequência de verificações depende do número de vezes que páginas compactadas são modificadas de uma maneira que requer reorganização e compactação.

Para criar uma tabela compactada em um espaço de tabelas por arquivo, `innodb_file_per_table` deve ser habilitado. Não há dependência do ajuste `innodb_file_per_table` ao criar uma tabela compactada em um espaço de tabelas geral. Para mais informações, consulte a Seção 17.6.3.3, “Espaços de Tabelas Gerais”.