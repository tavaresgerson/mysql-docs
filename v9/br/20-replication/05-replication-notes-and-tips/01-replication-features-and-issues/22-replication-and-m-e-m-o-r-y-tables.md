#### 19.5.1.22 Replicação e Tabelas de MEMÓRIA

Quando um servidor de origem de replicação é desligado e reiniciado, suas tabelas de `MEMÓRIA` ficam vazias. Para replicar esse efeito nas réplicas, na primeira vez que a origem usar uma tabela de `MEMÓRIA` específica após a inicialização, ela registra um evento que notifica as réplicas de que a tabela deve ser esvaziada, escrevendo uma instrução `DELETE` ou `TRUNCATE TABLE` para essa tabela no log binário. Esse evento gerado é identificável por um comentário no log binário, e, se GTIDs estiverem em uso no servidor, ele recebe um GTID atribuído. A instrução é sempre registrada no formato de instrução, mesmo que o formato de registro binário esteja configurado para `ROW`, e é escrita mesmo que o modo `read_only` ou `super_read_only` esteja configurado no servidor. Observe que a réplica ainda tem dados desatualizados em uma tabela de `MEMÓRIA` durante o intervalo entre o reinício da origem e seu primeiro uso da tabela. Para evitar esse intervalo, quando uma consulta direta à réplica pode retornar dados desatualizados, você pode definir a variável de sistema `init_file` para nomear um arquivo que contém instruções que preenchem a tabela de `MEMÓRIA` na origem durante a inicialização.

Quando um servidor de réplica é desligado e reiniciado, suas tabelas de `MEMÓRIA` ficam vazias. Isso faz com que a réplica fique fora de sincronia com a origem e pode levar a outras falhas ou fazer com que a réplica pare:

* As atualizações e exclusões de formato de linha recebidas da origem podem falhar com `Não foi encontrado registro em 'memory_table'`.

* Instruções como `INSERT INTO ... SELECT FROM memory_table` podem inserir um conjunto diferente de linhas na origem e na réplica.

A réplica também escreve uma instrução `DELETE` ou `TRUNCATE TABLE` em seu próprio log binário, que é passada para quaisquer réplicas subsequentes, fazendo com que elas esvaziem suas próprias tabelas de `MEMÓRIA`.

A maneira segura de reiniciar uma replica que está replicando tabelas `MEMORY` é primeiro excluir ou apagar todas as linhas das tabelas `MEMORY` na fonte e esperar até que essas alterações tenham sido replicadas para a replica. Em seguida, é seguro reiniciar a replica.

Um método alternativo de reinício pode ser aplicado em alguns casos. Quando `binlog_format=ROW`, você pode impedir que a replica pare se definir `replica_exec_mode=IDEMPOTENT` antes de reiniciar a replica. Isso permite que a replica continue a replicar, mas suas tabelas `MEMORY` ainda diferem das da fonte. Isso é aceitável se a lógica do aplicativo for tal que o conteúdo das tabelas `MEMORY` possa ser perdido com segurança (por exemplo, se as tabelas `MEMORY` forem usadas para cache). `replica_exec_mode=IDEMPOTENT` se aplica globalmente a todas as tabelas, então pode ocultar outros erros de replicação em tabelas não `MEMORY`.

(O método descrito acima não é aplicável no NDB Cluster, onde `replica_exec_mode` é sempre `IDEMPOTENT` e não pode ser alterado.)

O tamanho das tabelas `MEMORY` é limitado pelo valor da variável de sistema `max_heap_table_size`, que não é replicada (consulte a Seção 19.5.1.40, “Replicação e Variáveis”). Uma alteração no `max_heap_table_size` entra em vigor para as tabelas `MEMORY` que são criadas ou atualizadas usando `ALTER TABLE ... ENGINE = MEMORY` ou `TRUNCATE TABLE` após a alteração, ou para todas as tabelas `MEMORY` após o reinício do servidor. Se você aumentar o valor dessa variável na fonte sem fazer isso na replica, torna-se possível que uma tabela na fonte cresça mais do que sua contraparte na replica, levando a inserções que têm sucesso na fonte, mas falham na replica com erros de Table is full. Esse é um problema conhecido (Bug #48666). Nesses casos, você deve definir o valor global de `max_heap_table_size` na replica, assim como na fonte, e, em seguida, reiniciar a replicação. Também é recomendável que você reinicie os servidores MySQL da fonte e da replica, para garantir que o novo valor tenha efeito completo (global) em cada um deles.

Consulte a Seção 18.3, “O Motor de Armazenamento MEMORY”, para obter mais informações sobre as tabelas `MEMORY`.