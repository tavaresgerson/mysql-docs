### 19.4.2 Gerenciamento de uma Parada Inesperada de uma Replicação

Para que a replicação seja resiliente a paradas inesperadas do servidor (às vezes descrita como segura em caso de falha), deve ser possível para a replica recuperar seu estado antes de parar. Esta seção descreve o impacto de uma parada inesperada de uma replica durante a replicação e como configurar uma replica para ter a melhor chance de recuperação para continuar a replicação.

Após uma parada inesperada de uma replica, ao ser reiniciado, o thread de replicação SQL deve recuperar informações sobre quais transações já foram executadas. As informações necessárias para a recuperação são armazenadas no repositório de metadados do aplicável da replica. Esse repositório é criado por padrão como uma tabela `InnoDB` chamada `mysql.slave_relay_log_info`. Ao usar esse mecanismo de armazenamento transacional, as informações são sempre recuperáveis ao reiniciar. As atualizações no repositório de metadados do aplicável são comprometidas junto com as transações, o que significa que as informações de progresso da replica registradas nesse repositório estão sempre consistentes com o que foi aplicado ao banco de dados, mesmo em caso de uma parada inesperada do servidor. Para mais informações sobre o repositório de metadados do aplicável, consulte a Seção 19.2.4, “Repositórios de Log de Relay e Metadados de Replicação”.

As transações DML e também as atualizações DDL atômicas atualizam as posições de replicação no repositório de metadados do aplicável da replica na tabela `mysql.slave_relay_log_info`, juntamente com a aplicação das alterações no banco de dados, como uma operação atômica. Em todos os outros casos, incluindo declarações DDL que não são totalmente atômicas e motores de armazenamento excluídos que não suportam DDL atômico, a tabela `mysql.slave_relay_log_info` pode estar faltando atualizações associadas aos dados replicados se o servidor parar inesperadamente. Restaurar as atualizações neste caso é um processo manual. Para obter detalhes sobre o suporte a DDL atômico no MySQL 9.5 e o comportamento resultante para a replicação de certas declarações, consulte a Seção 15.1.1, “Suporte a Declarações de Definição de Dados Atômicos”.

O processo de recuperação pelo qual uma replica se recupera de uma parada inesperada varia dependendo da configuração da replica. Os detalhes do processo de recuperação são influenciados pelo método de replicação escolhido, se a replica é monofila ou multifila, e pelo ajuste de variáveis de sistema relevantes. O objetivo geral do processo de recuperação é identificar quais transações já haviam sido aplicadas no banco de dados da replica antes da parada inesperada ocorrer e recuperar e aplicar as transações que a replica perdeu após a parada inesperada.

* Para a replicação baseada em GTID, o processo de recuperação precisa dos GTIDs das transações que já foram recebidas ou comprometidas pela replica. As transações ausentes podem ser recuperadas da fonte usando a autoposição de GTIDs, que compara automaticamente as transações da fonte com as transações da replica e identifica as transações ausentes.

* Para a replicação baseada na posição do arquivo, o processo de recuperação precisa de uma posição precisa do fio de SQL de replicação (aplicador) que mostre a última transação aplicada na réplica. Com base nessa posição, o fio de I/O de replicação (receptor) recupera do log binário da fonte todas as transações que devem ser aplicadas na réplica a partir desse ponto.

A replicação baseada em GTID facilita a configuração da replicação para ser resiliente a interrupções inesperadas. A autoposição do GTID significa que a réplica pode identificar e recuperar de forma confiável as transações ausentes, mesmo que haja lacunas na sequência de transações aplicadas.

As seguintes informações fornecem combinações de configurações apropriadas para diferentes tipos de réplicas para garantir a recuperação, na medida em que isso está sob o controle da replicação.

Importante

Alguns fatores fora do controle da replicação podem ter um impacto no processo de recuperação da replicação e no estado geral da replicação após o processo de recuperação. Em particular, as configurações que influenciam o processo de recuperação para motores de armazenamento individuais podem resultar na perda de transações no caso de uma interrupção inesperada de uma réplica, e, portanto, indisponíveis para o processo de recuperação da replicação. A configuração `innodb_flush_log_at_trx_commit=1` mencionada na lista abaixo é uma configuração chave para uma configuração de replicação que usa `InnoDB` com transações. No entanto, outras configurações específicas de `InnoDB` ou de outros motores de armazenamento, especialmente aquelas relacionadas ao descarte ou sincronização, também podem ter um impacto. Sempre verifique e aplique as recomendações feitas pelos motores de armazenamento escolhidos sobre configurações resistentes a falhas.

A seguinte combinação de configurações em uma réplica é a mais resiliente a interrupções inesperadas:

* Quando a replicação baseada em GTID está em uso (`gtid_mode=ON`), defina `SOURCE_AUTO_POSITION=1`, o que ativa a autoposição de GTID para a conexão com a fonte para identificar e recuperar automaticamente as transações ausentes. Esta opção é definida usando uma declaração `CHANGE REPLICATION SOURCE TO`. Se a réplica tiver vários canais de replicação, é necessário definir esta opção individualmente para cada canal. Para obter detalhes sobre como a autoposição de GTID funciona, consulte a Seção 19.1.3.3, “Autoposição de GTID”. Quando a replicação baseada na posição de arquivo está em uso, `SOURCE_AUTO_POSITION=1` não é usada, e, em vez disso, a posição do log binário ou a posição do log de relevo é usada para controlar onde a replicação começa.

* Quando a replicação baseada em GTID está em uso (`gtid_mode=ON`), defina `GTID_ONLY=1`, o que faz com que a réplica use apenas GTIDs no processo de recuperação e pare de persistir nomes e posições de arquivos de log binário e log de relevo nos repositórios de metadados de replicação. Esta opção é definida usando uma declaração `CHANGE REPLICATION SOURCE TO`. Se a réplica tiver vários canais de replicação, é necessário definir esta opção individualmente para cada canal. Com `GTID_ONLY=1`, durante a recuperação, as informações de posição de arquivo são ignoradas e o auto-salto de GTID é usado para pular transações que já foram fornecidas, em vez de identificar a posição correta do arquivo. Esta estratégia é mais eficiente, desde que você limpe os logs de relevo usando o ajuste padrão para `relay_log_purge`, o que significa que apenas um arquivo de log de relevo precisa ser inspecionado.

* Defina `sync_relay_log=1`, o que instrui o thread receptor de replicação a sincronizar o log de retransmissão com o disco após cada transação recebida ser escrita nele. Isso significa que o registro da replica da posição atual lida no log binário da fonte (no repositório de metadados do aplicável) nunca fica à frente do registro das transações salvas no log de retransmissão. Observe que, embora essa configuração seja a mais segura, também é a mais lenta devido ao número de escritas no disco envolvidas. Com `sync_relay_log > 1`, ou `sync_relay_log=0` (onde a sincronização é gerenciada pelo sistema operacional), no caso de uma parada inesperada de uma replica, pode haver transações confirmadas que não foram sincronizadas com o disco. Tais transações podem causar o falha do processo de recuperação se a replica de recuperação, com base nas informações que ela tem no log de retransmissão na última sincronização com o disco, tentar recuperar e aplicar as transações novamente em vez de pular. Definir `sync_relay_log=1` é particularmente importante para uma replica multi-threaded, onde o processo de recuperação falha se as lacunas na sequência de transações não puderem ser preenchidas usando as informações no log de retransmissão. Para uma replica single-threaded, o processo de recuperação só precisa usar o log de retransmissão se as informações relevantes não estiverem disponíveis no repositório de metadados do aplicável.

* Defina `innodb_flush_log_at_trx_commit=1`, que sincroniza os logs do `InnoDB` com o disco antes de cada transação ser confirmada. Esta configuração, que é a padrão, garante que as tabelas do `InnoDB` e os logs do `InnoDB` sejam salvos no disco, para que não haja mais a necessidade de informações no log de retransmissão em relação à transação. Combinada com a configuração `sync_relay_log=1`, esta configuração garante ainda que o conteúdo das tabelas do `InnoDB` e dos logs do `InnoDB` esteja consistente com o conteúdo do log de retransmissão em todos os momentos, para que a purga dos arquivos do log de retransmissão não cause lacunas não preenchíveis na história das transações da replica em caso de uma parada inesperada.

* Defina `relay_log_info_repository = TABLE`, que armazena a posição do fio de transação SQL de replicação na tabela `mysql.slave_relay_log_info` do `InnoDB` e a atualiza junto com o commit da transação para garantir um registro sempre preciso. Esta configuração é a padrão; `FILE` está desatualizado. A própria variável de sistema também está desatualizada, então omita-a e permita que ela assuma o padrão. Se `FILE` for usado, as informações são armazenadas em um arquivo no diretório de dados que é atualizado após a transação ter sido aplicada. Isso cria um risco de perda de sincronia com a fonte dependendo em que estágio do processamento de uma transação a replica para, ou até mesmo a corrupção do próprio arquivo. Com `relay_log_info_repository = FILE`, a recuperação não é garantida.

* Defina `relay_log_recovery = ON`, o que habilita a recuperação automática do log do retransmissor imediatamente após a inicialização do servidor. Esta variável global tem o valor padrão `OFF` e é somente de leitura durante a execução, mas você pode defini-la como `ON` com a opção `--relay-log-recovery` durante a inicialização da replica após uma parada inesperada de uma replica. Observe que essa configuração ignora os arquivos de log do retransmissor existentes, caso estejam corrompidos ou inconsistentes. O processo de recuperação do log do retransmissor cria um novo arquivo de log do retransmissor e recupera as transações da fonte, começando na posição do fio SQL de replicação registrada no repositório de metadados do aplicável. Os arquivos de log do retransmissor anteriores são removidos ao longo do tempo pelo mecanismo de purga normal da replica.

Para uma replica multitelada, definir `relay_log_recovery = ON` lida automaticamente com quaisquer inconsistências e lacunas na sequência de transações que foram executadas a partir do log do retransmissor. Essas lacunas podem ocorrer quando a replicação baseada em posição de arquivo está em uso. (Para mais detalhes, consulte a Seção 19.5.1.35, “Inconsistências de Replicação e Transações”.) O processo de recuperação do log do retransmissor lida com as lacunas usando o mesmo método que a instrução `START REPLICA UNTIL SQL_AFTER_MTS_GAPS` faria. Quando a replica atinge um estado consistente sem lacunas, o processo de recuperação do log do retransmissor continua a recuperar transações adicionais da fonte, começando na posição do fio SQL de replicação. Quando a replicação baseada em GTID está em uso, uma replica multitelada verifica primeiro se `SOURCE_AUTO_POSITION` está definido como `ON`, e se estiver, omite o passo de calcular as transações que devem ser ignoradas ou não ignoradas, para que os antigos logs do retransmissor não sejam necessários para o processo de recuperação.