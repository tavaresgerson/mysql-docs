#### 25.6.7.1 Adicionando Nodos de Dados do NDB Cluster Online: Problemas Gerais

Esta seção fornece informações gerais sobre o comportamento e as limitações atuais na adição de nós do NDB Cluster online.

**Redistribuição de Dados.** A capacidade de adicionar novos nós online inclui um meio de reorganizar os dados e índices da tabela `NDBCLUSTER` para que sejam distribuídos por todos os nós de dados, incluindo os novos, por meio da instrução `ALTER TABLE ... REORGANIZE PARTITION`. A reorganização da tabela, tanto de tabelas de Dados em Memória quanto de Dados em Disco, é suportada. Essa redistribuição atualmente não inclui índices únicos (somente índices ordenados são redistribuídos).

A redistribuição para tabelas `NDBCLUSTER` que já existiam antes da adição dos novos nós de dados não é automática, mas pode ser realizada usando instruções SQL simples no **mysql** ou em outra aplicação cliente do MySQL. No entanto, todos os dados e índices adicionados a tabelas criadas após a adição de um novo grupo de nós são distribuídos automaticamente por todos os nós de dados do cluster, incluindo os adicionados como parte do novo grupo de nós.

**Inícios Parciais.** É possível adicionar um novo grupo de nós sem que todos os novos nós de dados estejam iniciados. Também é possível adicionar um novo grupo de nós a um cluster degradado — ou seja, um cluster que está apenas parcialmente iniciado, ou onde um ou mais nós de dados não estão em execução. Neste último caso, o cluster deve ter no mínimo alguns nós em execução para ser viável antes que o novo grupo de nós possa ser adicionado.

**Efeitos nas operações em andamento.** As operações normais de manipulação de dados (DML) usando os dados do NDB Cluster não são impedidas pela criação ou adição de um novo grupo de nós, nem pela reorganização da tabela. No entanto, não é possível realizar DDL simultaneamente com a reorganização da tabela — ou seja, nenhuma outra instrução DDL pode ser emitida enquanto uma instrução `ALTER TABLE ... REORGANIZE PARTITION` estiver sendo executada. Além disso, durante a execução de `ALTER TABLE ... REORGANIZE PARTITION` (ou a execução de qualquer outra instrução DDL), não é possível reiniciar os nós de dados do cluster.

**Tratamento de falhas.** As falhas dos nós de dados durante a criação do grupo de nós e a reorganização da tabela são tratadas conforme mostrado na tabela a seguir:

**Tabela 25.38 Tratamento de falhas de nós de dados durante a criação do grupo de nós e a reorganização da tabela**

<table><col style="width: 25%"/><col style="width: 25%"/><col style="width: 25%"/><col style="width: 25%"/><thead><tr> <th>Falha durante</th> <th>Falha no nó <span class="quote">“<span class="quote">antigo</span>”</span></th> <th>Falha no nó <span class="quote">“<span class="quote">novo</span>”</span></th> <th>Falha no sistema</th> </tr></thead><tbody><tr> <th>Criação de grupo de nós</th> <td> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>Se um nó diferente do mestre falhar: </b> A criação do grupo de nós é sempre avançada. </p></li><li class="listitem"><p><b>Se o mestre falhar: </b></p> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><b>Se o ponto de commit interno tiver sido alcançado: </b> A criação do grupo de nós é avançada. </p></li><li class="listitem"><p><b>Se o ponto de commit interno ainda não tiver sido alcançado. </b> A criação do grupo de nós é revertida </p></li></ul> </div> </li></ul> </div> </td> <td> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>Se um nó diferente do mestre falhar: </b> A criação do grupo de nós é sempre avançada. </p></li><li class="listitem"><p><b>Se o mestre falhar: </b></p> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><b>Se o ponto de commit interno tiver sido alcançado: </b> A criação do grupo de nós é avançada. </p></li><li class="listitem"><p><b>Se o ponto de commit interno ainda não tiver sido alcançado. </b> A criação do grupo de nós é revertida </p></li></ul> </div> </li></ul> </div> </td> <td> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>Se a execução do comando CREATE NODEGROUP tiver alcançado o ponto de commit interno: </b> Quando reiniciado, o clúster inclui o novo grupo de nós. Caso contrário, não inclui. </p></li><li class="listitem"><p><b>Se a execução do comando CREATE NODEGROUP ainda não tiver alcançado o ponto de commit interno: </b> Quando reiniciado, o clúster não inclui o novo grupo de nós. </p></li></ul> </div> </td> </tr><tr> <th>Reorganização da tabela</th> <td> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>Se um nó diferente do mestre falhar: </b> A reorganização da tabela é sempre avançada. </p></li><li class="listitem"><p><b>Se o mestre falhar: </b></p> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><b>Se o ponto de commit interno tiver sido alcançado: </b> A reorganização da tabela é avançada. </p></li><li class="listitem"><p><b>Se o ponto de commit interno ainda não tiver sido alcançado. </b> A reorganização da tabela é revertida. </p></li></ul> </div> </li></ul> </div> </td> <td> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>Se um nó diferente do mestre falhar: </b> A reorganização da tabela é sempre avançada. </p></li><li class="listitem"><p><b>Se o mestre falhar: </b></p> <div class="itemizedlist"> <ul class="itemizedlist" style="list-style-

**Desativação de grupos de nós.** O cliente **ndb_mgm** suporta o comando `DROP NODEGROUP`, mas é possível desativar um grupo de nós apenas quando nenhum nó de dados no grupo de nós contiver nenhum dado. Como atualmente não há como "esvaziar" um nó de dados ou um grupo de nós específico, este comando só funciona nos seguintes dois casos:

1. Após emitir `CREATE NODEGROUP` no cliente **ndb_mgm**, mas antes de emitir quaisquer declarações `ALTER TABLE ... REORGANIZE PARTITION` no cliente **mysql**.

2. Após desativar todas as tabelas **NDBCLUSTER** usando `DROP TABLE`.

`TRUNCATE TABLE` não funciona para esse propósito porque os nós de dados continuam a armazenar as definições da tabela.